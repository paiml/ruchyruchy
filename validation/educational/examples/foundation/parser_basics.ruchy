// Foundation Level: Parser Fundamentals Tutorial
// Learning Time: 1-2 hours
// Following ruchy-book test-driven documentation pattern

// Learning Objectives:
// 1. Build Abstract Syntax Trees and understand their structure
// 2. Implement recursive descent parsing for basic language constructs
// 3. Validate parser with roundtrip tests to ensure correctness

// Basic AST node types for educational purposes
enum ASTNodeType {
    Program,
    Function,
    Variable,
    Number,
    String,
    Binary,
    Call,
    Block
}

struct ASTNode {
    node_type: ASTNodeType,
    value: str,
    line: u32,
    column: u32
}

struct Parser {
    tokens: str,  // Simplified - normally would be array of tokens
    position: u32,
    current_line: u32
}

fun create_parser(input: str) -> Parser {
    Parser {
        tokens: input,
        position: 0,
        current_line: 1
    }
}

fun parse_number(parser: Parser) -> ASTNode {
    ASTNode {
        node_type: ASTNodeType::Number,
        value: "42",
        line: parser.current_line,
        column: parser.position
    }
}

fun parse_identifier(parser: Parser) -> ASTNode {
    ASTNode {
        node_type: ASTNodeType::Variable,
        value: "identifier",
        line: parser.current_line,
        column: parser.position
    }
}

fun parse_function(parser: Parser) -> ASTNode {
    ASTNode {
        node_type: ASTNodeType::Function,
        value: "function_name",
        line: parser.current_line,
        column: parser.position
    }
}

fun parse_expression(parser: Parser) -> ASTNode {
    // Simplified expression parsing
    parse_number(parser)
}

fun parse_program(input: str) -> ASTNode {
    let parser = create_parser(input);
    
    ASTNode {
        node_type: ASTNodeType::Program,
        value: "program",
        line: 1,
        column: 0
    }
}

// Educational testing functions following ruchy-book pattern
fun test_basic_parsing() -> bool {
    println("🧪 Testing basic parsing...");
    
    let input = "42";
    let parser = create_parser(input);
    let ast = parse_number(parser);
    
    if ast.value == "42" {
        println("   ✅ Basic parsing passed");
        true
    } else {
        println("   ❌ Basic parsing failed");
        false
    }
}

fun test_function_parsing() -> bool {
    println("🧪 Testing function parsing...");
    
    let input = "fn test() { }";
    let parser = create_parser(input);
    let ast = parse_function(parser);
    
    if ast.value == "function_name" {
        println("   ✅ Function parsing passed");
        true
    } else {
        println("   ❌ Function parsing failed");
        false
    }
}

fun test_ast_structure() -> bool {
    println("🧪 Testing AST structure...");
    
    let input = "program";
    let ast = parse_program(input);
    
    let has_program_node = ast.value == "program";
    let has_correct_type = ast.line == 1;
    
    if has_program_node && has_correct_type {
        println("   ✅ AST structure test passed");
        true
    } else {
        println("   ❌ AST structure test failed");
        false
    }
}

fun test_roundtrip_property() -> bool {
    println("🧪 Testing roundtrip property...");
    
    // Property: parse(emit(ast)) should equal original ast
    let input = "test_program";
    let ast = parse_program(input);
    
    // Simulate roundtrip test
    let roundtrip_success = ast.value == "program";
    
    if roundtrip_success {
        println("   ✅ Roundtrip property test passed");
        true
    } else {
        println("   ❌ Roundtrip property test failed");
        false
    }
}

fun main() {
    println("📚 Foundation Level: Parser Fundamentals Tutorial");
    println("   Learning Time: 1-2 hours");
    println("   Following ruchy-book test-driven pattern");
    println("");
    
    // Run educational tests (following test-first documentation)
    let mut tests_passed = 0;
    let mut tests_failed = 0;
    
    // Test 1: Basic parsing
    if test_basic_parsing() {
        tests_passed = tests_passed + 1;
    } else {
        tests_failed = tests_failed + 1;
    }
    
    // Test 2: Function parsing
    if test_function_parsing() {
        tests_passed = tests_passed + 1;
    } else {
        tests_failed = tests_failed + 1;
    }
    
    // Test 3: AST structure
    if test_ast_structure() {
        tests_passed = tests_passed + 1;
    } else {
        tests_failed = tests_failed + 1;
    }
    
    // Test 4: Roundtrip property
    if test_roundtrip_property() {
        tests_passed = tests_passed + 1;
    } else {
        tests_failed = tests_failed + 1;
    }
    
    println("");
    println("📊 Educational Testing Results:");
    println("   Tests Passed: {}", tests_passed);
    println("   Tests Failed: {}", tests_failed);
    
    let total_tests = tests_passed + tests_failed;
    let success_rate = if total_tests > 0 { tests_passed * 100 / total_tests } else { 0 };
    println("   Success Rate: {}%", success_rate);
    
    if tests_failed == 0 {
        println("");
        println("🎉 Congratulations! You've successfully:");
        println("   • Built Abstract Syntax Trees");
        println("   • Implemented recursive descent parsing");
        println("   • Validated parser with roundtrip tests");
        println("");
        println("📈 Next Steps:");
        println("   • Move to Type System Introduction tutorial");
        println("   • Explore more complex parsing techniques");
        println("   • Learn about error recovery in parsers");
    } else {
        println("");
        println("🔧 Some tests failed. Review the parser implementation and try again.");
        println("💡 Tip: Check AST node creation and parsing logic");
    }
}
