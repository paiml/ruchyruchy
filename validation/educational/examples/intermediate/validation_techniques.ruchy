// Intermediate Level: Validation Techniques Tutorial  
// Learning Time: 1 week
// Following ruchy validation patterns from Phase 2

// Learning Objectives:
// 1. Master comprehensive validation strategies for compilers
// 2. Implement differential testing between compiler implementations
// 3. Build automated validation pipelines with quality gates

// Validation framework for compiler testing
enum ValidationLevel {
    Syntax,
    Semantic,
    Performance,
    Correctness
}

struct ValidationResult {
    level: ValidationLevel,
    passed: bool,
    error_message: str,
    execution_time: u32
}

struct DifferentialTest {
    source_code: str,
    expected_output: str,
    actual_output: str,
    implementations: [str]
}

struct ValidationPipeline {
    name: str,
    tests_run: u32,
    tests_passed: u32,
    coverage_percentage: f64
}

fn create_validation_result(level: ValidationLevel, passed: bool, message: str) -> ValidationResult {
    ValidationResult {
        level: level,
        passed: passed,
        error_message: message,
        execution_time: 0
    }
}

// Syntax validation - first line of defense
fn validate_syntax(source: str) -> ValidationResult {
    println("   ðŸ” Validating syntax...");
    
    // Simulate syntax validation
    let has_balanced_parens = count_chars(source, "(") == count_chars(source, ")");
    let has_balanced_braces = count_chars(source, "{") == count_chars(source, "}");
    
    if has_balanced_parens && has_balanced_braces {
        create_validation_result(ValidationLevel::Syntax, true, "Syntax valid")
    } else {
        create_validation_result(ValidationLevel::Syntax, false, "Unbalanced delimiters")
    }
}

// Semantic validation - check meaning and types
fn validate_semantics(source: str) -> ValidationResult {
    println("   ðŸ§  Validating semantics...");
    
    // Simulate semantic analysis
    let has_main_function = contains_substring(source, "fn main");
    let has_valid_types = !contains_substring(source, "undefined_type");
    
    if has_main_function && has_valid_types {
        create_validation_result(ValidationLevel::Semantic, true, "Semantics valid")
    } else {
        create_validation_result(ValidationLevel::Semantic, false, "Semantic error detected")
    }
}

// Performance validation - ensure efficiency bounds
fn validate_performance(source: str) -> ValidationResult {
    println("   âš¡ Validating performance...");
    
    // Simulate performance analysis
    let estimated_complexity = estimate_complexity(source);
    let within_limits = estimated_complexity < 1000;
    
    if within_limits {
        create_validation_result(ValidationLevel::Performance, true, "Performance acceptable")
    } else {
        create_validation_result(ValidationLevel::Performance, false, "Performance exceeds limits")
    }
}

// Correctness validation - check program behavior
fn validate_correctness(source: str) -> ValidationResult {
    println("   âœ… Validating correctness...");
    
    // Simulate correctness checking
    let produces_output = simulate_execution(source) != "";
    let no_runtime_errors = !contains_substring(source, "panic");
    
    if produces_output && no_runtime_errors {
        create_validation_result(ValidationLevel::Correctness, true, "Program correct")
    } else {
        create_validation_result(ValidationLevel::Correctness, false, "Correctness issues found")
    }
}

// Differential testing - compare multiple implementations
fn run_differential_test(test: DifferentialTest) -> bool {
    println("   ðŸ”„ Running differential test...");
    
    // Simulate running the same source on different implementations
    let impl1_output = simulate_compile_with_impl(test.source_code, "impl1");
    let impl2_output = simulate_compile_with_impl(test.source_code, "impl2");
    
    // Check if outputs match
    impl1_output == impl2_output
}

// Comprehensive validation pipeline
fn run_validation_pipeline(source: str) -> ValidationPipeline {
    println("ðŸš€ Running validation pipeline for source code...");
    
    let mut pipeline = ValidationPipeline {
        name: "Comprehensive Validation",
        tests_run: 0,
        tests_passed: 0,
        coverage_percentage: 0.0
    };
    
    // Run all validation levels
    let validations = [
        validate_syntax(source),
        validate_semantics(source),
        validate_performance(source),
        validate_correctness(source)
    ];
    
    pipeline.tests_run = 4;
    
    for validation in validations {
        if validation.passed {
            pipeline.tests_passed = pipeline.tests_passed + 1;
        }
    }
    
    // Calculate coverage percentage
    pipeline.coverage_percentage = if pipeline.tests_run > 0 {
        (pipeline.tests_passed * 100.0) / pipeline.tests_run
    } else {
        0.0
    };
    
    pipeline
}

// Quality gate implementation
fn check_quality_gates(pipeline: ValidationPipeline) -> bool {
    println("ðŸ”’ Checking quality gates...");
    
    // Quality gate requirements
    let min_coverage = 80.0;
    let min_pass_rate = pipeline.tests_passed >= 3; // At least 3 of 4 tests must pass
    let coverage_ok = pipeline.coverage_percentage >= min_coverage;
    
    if min_pass_rate && coverage_ok {
        println("   âœ… Quality gates passed");
        true
    } else {
        println("   âŒ Quality gates failed");
        false
    }
}

// Utility functions for validation
fn count_chars(text: str, target: str) -> u32 {
    // Simplified character counting
    if contains_substring(text, target) {
        1
    } else {
        0
    }
}

fn contains_substring(text: str, substring: str) -> bool {
    // Simplified substring check - in real implementation would be more sophisticated
    text != "" && substring != ""
}

fn estimate_complexity(source: str) -> u32 {
    // Simplified complexity estimation based on source length
    source.length * 10
}

fn simulate_execution(source: str) -> str {
    // Simulate program execution
    if contains_substring(source, "println") {
        "output"
    } else {
        ""
    }
}

fn simulate_compile_with_impl(source: str, implementation: str) -> str {
    // Simulate compilation with different implementations
    if implementation == "impl1" {
        "compiled_output_v1"
    } else {
        "compiled_output_v1" // Same output for successful test
    }
}

// Educational testing functions
fn test_syntax_validation() -> bool {
    println("ðŸ§ª Testing syntax validation...");
    
    let valid_code = "fn main() { println(\"Hello\"); }";
    let invalid_code = "fn main( { println(\"Hello\"; }";
    
    let valid_result = validate_syntax(valid_code);
    let invalid_result = validate_syntax(invalid_code);
    
    if valid_result.passed && !invalid_result.passed {
        println("   âœ… Syntax validation test passed");
        true
    } else {
        println("   âŒ Syntax validation test failed");
        false
    }
}

fn test_semantic_validation() -> bool {
    println("ðŸ§ª Testing semantic validation...");
    
    let valid_code = "fn main() { let x: int = 42; }";
    let invalid_code = "fn other() { let x: undefined_type = 42; }";
    
    let valid_result = validate_semantics(valid_code);
    let invalid_result = validate_semantics(invalid_code);
    
    if valid_result.passed && !invalid_result.passed {
        println("   âœ… Semantic validation test passed");
        true
    } else {
        println("   âŒ Semantic validation test failed");
        false
    }
}

fn test_differential_testing() -> bool {
    println("ðŸ§ª Testing differential testing...");
    
    let test = DifferentialTest {
        source_code: "fn main() { println(\"test\"); }",
        expected_output: "compiled_output_v1",
        actual_output: "compiled_output_v1",
        implementations: ["impl1", "impl2"]
    };
    
    let result = run_differential_test(test);
    
    if result {
        println("   âœ… Differential testing passed");
        true
    } else {
        println("   âŒ Differential testing failed");
        false
    }
}

fn test_validation_pipeline() -> bool {
    println("ðŸ§ª Testing validation pipeline...");
    
    let source = "fn main() { println(\"Hello, World!\"); }";
    let pipeline = run_validation_pipeline(source);
    let quality_passed = check_quality_gates(pipeline);
    
    if quality_passed && pipeline.tests_passed >= 3 {
        println("   âœ… Validation pipeline test passed");
        true
    } else {
        println("   âŒ Validation pipeline test failed");
        false
    }
}

fn main() {
    println("ðŸ“š Intermediate Level: Validation Techniques Tutorial");
    println("   Learning Time: 1 week");
    println("   Comprehensive compiler validation strategies");
    println("");
    
    // Run validation technique tests
    let mut tests_passed = 0;
    let mut tests_failed = 0;
    
    // Test 1: Syntax validation
    if test_syntax_validation() {
        tests_passed = tests_passed + 1;
    } else {
        tests_failed = tests_failed + 1;
    }
    
    // Test 2: Semantic validation  
    if test_semantic_validation() {
        tests_passed = tests_passed + 1;
    } else {
        tests_failed = tests_failed + 1;
    }
    
    // Test 3: Differential testing
    if test_differential_testing() {
        tests_passed = tests_passed + 1;
    } else {
        tests_failed = tests_failed + 1;
    }
    
    // Test 4: Full validation pipeline
    if test_validation_pipeline() {
        tests_passed = tests_passed + 1;
    } else {
        tests_failed = tests_failed + 1;
    }
    
    println("");
    println("ðŸ“Š Validation Techniques Results:");
    println("   Validation Tests Passed: {}", tests_passed);
    println("   Validation Tests Failed: {}", tests_failed);
    
    let total_tests = tests_passed + tests_failed;
    let success_rate = if total_tests > 0 { tests_passed * 100 / total_tests } else { 0 };
    println("   Overall Success Rate: {}%", success_rate);
    
    if tests_failed == 0 {
        println("");
        println("ðŸŽ‰ Congratulations! You've mastered validation techniques:");
        println("   â€¢ Built comprehensive validation pipelines");
        println("   â€¢ Implemented quality gates and automated checks");
        println("   â€¢ Created differential testing frameworks");
        println("");
        println("ðŸ“ˆ Next Steps:");
        println("   â€¢ Move to Advanced Level: Fuzz Testing and Boundary Analysis");
        println("   â€¢ Implement continuous validation integration");
        println("   â€¢ Create custom validation rules for your domain");
    } else {
        println("");
        println("ðŸ”§ Some validation tests failed. Review implementations and try again.");
        println("ðŸ’¡ Tip: Focus on comprehensive coverage and multiple validation levels");
    }
}