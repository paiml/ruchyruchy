// QUALITY-005 RED Phase: Code Churn Analysis
// Tests for tracking code change frequency and identifying hot spots
// Ruchy v3.142.0

fun main() {
    println("🔴 QUALITY-005: RED Phase - Code Churn Analysis")
    println("Testing churn tracking, hotspots, correlation, and cyclic changes")
    println("=" * 60)

    let mut total_tests = 0
    let mut passing_tests = 0

    println("")
    println("Test 1: Churn Frequency Tracking")
    println("Should track number of changes per file/function")
    if test_churn_frequency_tracking() {
        println("  ✅ PASS")
        passing_tests = passing_tests + 1
    } else {
        println("  ❌ FAIL - Expected to track change frequency")
    }
    total_tests = total_tests + 1

    println("")
    println("Test 2: Hotspot Identification")
    println("Should identify files/functions with highest churn")
    if test_hotspot_identification() {
        println("  ✅ PASS")
        passing_tests = passing_tests + 1
    } else {
        println("  ❌ FAIL - Expected to identify hotspots")
    }
    total_tests = total_tests + 1

    println("")
    println("Test 3: Churn-Failure Correlation")
    println("Should correlate high churn with bootstrap failures")
    if test_churn_failure_correlation() {
        println("  ✅ PASS")
        passing_tests = passing_tests + 1
    } else {
        println("  ❌ FAIL - Expected to correlate churn with failures")
    }
    total_tests = total_tests + 1

    println("")
    println("Test 4: Cyclic Change Detection")
    println("Should detect repeated edit patterns across stages")
    if test_cyclic_change_detection() {
        println("  ✅ PASS")
        passing_tests = passing_tests + 1
    } else {
        println("  ❌ FAIL - Expected to detect cyclic changes")
    }
    total_tests = total_tests + 1

    println("")
    println("=" * 60)
    println("TEST RESULTS:")
    println("  Total tests: " + total_tests.to_string())
    println("  Passing: " + passing_tests.to_string())
    println("  Failing: " + (total_tests - passing_tests).to_string())
    println("")

    if passing_tests == total_tests {
        println("🟢 EXCELLENT - All tests passing!")
        println("GREEN phase: Implementation complete")
        println("Ready for REFACTOR phase")
    } else if passing_tests > 0 {
        println("⚠️  PARTIAL - Some tests passing")
    } else {
        println("🔴 RED - All tests failing (expected for RED phase)")
        println("Ready to implement GREEN phase")
    }
}

// Test 1: Track change frequency per file/function
fun test_churn_frequency_tracking() -> bool {
    // Given: A simulated commit history
    let commits = vec![
        Commit { file: "lexer.ruchy", function: "tokenize", timestamp: 1 },
        Commit { file: "lexer.ruchy", function: "tokenize", timestamp: 2 },
        Commit { file: "parser.ruchy", function: "parse", timestamp: 3 },
        Commit { file: "lexer.ruchy", function: "tokenize", timestamp: 4 },
    ]

    // When: Calculate churn frequency
    let churn = calculate_churn_frequency(commits)

    // Then: Should track frequency correctly
    // lexer.ruchy::tokenize changed 3 times
    // parser.ruchy::parse changed 1 time
    let lexer_churn = get_churn_for_function(churn, "lexer.ruchy", "tokenize")
    let parser_churn = get_churn_for_function(churn, "parser.ruchy", "parse")

    return lexer_churn == 3 && parser_churn == 1
}

// Test 2: Identify hotspots (most frequently changed)
fun test_hotspot_identification() -> bool {
    // Given: Files with varying churn rates
    let churn_data = vec![
        ChurnMetric { file: "lexer.ruchy", function: "tokenize", count: 15 },
        ChurnMetric { file: "parser.ruchy", function: "parse", count: 8 },
        ChurnMetric { file: "typechecker.ruchy", function: "infer", count: 3 },
        ChurnMetric { file: "codegen.ruchy", function: "emit", count: 2 },
    ]

    // When: Identify top hotspots (threshold: > 10 changes)
    let hotspots = identify_hotspots(churn_data, 10)

    // Then: Should return only high-churn items
    // Only lexer.ruchy::tokenize (15) exceeds threshold of 10
    return hotspots.len() == 1 &&
           hotspots[0].file == "lexer.ruchy" &&
           hotspots[0].count == 15
}

// Test 3: Correlate churn with bootstrap failures
fun test_churn_failure_correlation() -> bool {
    // Given: Churn data and failure history
    let churn_data = vec![
        ChurnMetric { file: "lexer.ruchy", function: "tokenize", count: 20 },
        ChurnMetric { file: "parser.ruchy", function: "parse", count: 5 },
    ]

    let failures = vec![
        Failure { file: "lexer.ruchy", stage: "stage1", count: 8 },
        Failure { file: "parser.ruchy", stage: "stage1", count: 1 },
    ]

    // When: Calculate correlation
    let correlation = calculate_churn_failure_correlation(churn_data, failures)

    // Then: Should show positive correlation
    // High churn (20) correlates with high failures (8)
    // Correlation coefficient should be > 0.7
    return correlation > 0.7
}

// Test 4: Detect cyclic changes (same file changed across multiple stages)
fun test_cyclic_change_detection() -> bool {
    // Given: Changes across bootstrap stages
    let stage_changes = vec![
        StageChange { file: "lexer.ruchy", stage: "stage0", timestamp: 1 },
        StageChange { file: "lexer.ruchy", stage: "stage1", timestamp: 2 },
        StageChange { file: "lexer.ruchy", stage: "stage2", timestamp: 3 },
        StageChange { file: "parser.ruchy", stage: "stage1", timestamp: 4 },
    ]

    // When: Detect cyclic patterns
    let cycles = detect_cyclic_changes(stage_changes)

    // Then: Should identify lexer.ruchy as cyclic (changed in 3 stages)
    // parser.ruchy is not cyclic (only 1 stage)
    return cycles.len() == 1 &&
           cycles[0].file == "lexer.ruchy" &&
           cycles[0].stage_count == 3
}

// REFACTOR phase: Cleaned up implementation
fun calculate_churn_frequency(commits: Vec<Commit>) -> Vec<ChurnMetric> {
    // Count changes per file+function combination
    // Strategy: Build unique file::function keys, then count occurrences
    let mut unique_keys = vec![]

    // Collect unique file+function pairs
    let mut i = 0
    while i < commits.len() {
        let key = commits[i].file + "::" + commits[i].function

        // Check if key already exists
        let mut exists = false
        let mut j = 0
        while j < unique_keys.len() {
            if unique_keys[j] == key {
                exists = true
            }
            j = j + 1
        }

        if !exists {
            unique_keys.push(key)
        }
        i = i + 1
    }

    // Count occurrences for each unique key
    let mut metrics = vec![]
    let mut k = 0
    while k < unique_keys.len() {
        let target_key = unique_keys[k]
        let mut occurrence_count = 0
        let mut result_file = ""
        let mut result_function = ""

        // Count matches and capture file/function names
        let mut m = 0
        while m < commits.len() {
            let current_key = commits[m].file + "::" + commits[m].function
            if current_key == target_key {
                occurrence_count = occurrence_count + 1
                result_file = commits[m].file
                result_function = commits[m].function
            }
            m = m + 1
        }

        metrics.push(ChurnMetric {
            file: result_file,
            function: result_function,
            count: occurrence_count,
        })
        k = k + 1
    }

    return metrics
}

fun get_churn_for_function(churn: Vec<ChurnMetric>, file: String, function: String) -> i32 {
    // Find churn count for specific file+function
    let mut i = 0
    while i < churn.len() {
        if churn[i].file == file && churn[i].function == function {
            return churn[i].count
        }
        i = i + 1
    }
    return 0
}

fun identify_hotspots(churn_data: Vec<ChurnMetric>, threshold: i32) -> Vec<ChurnMetric> {
    // Filter metrics that exceed threshold
    let mut hotspots = vec![]

    let mut i = 0
    while i < churn_data.len() {
        if churn_data[i].count > threshold {
            hotspots.push(churn_data[i])
        }
        i = i + 1
    }

    return hotspots
}

fun calculate_churn_failure_correlation(churn: Vec<ChurnMetric>, failures: Vec<Failure>) -> f64 {
    // Simple correlation: high churn files should have high failures
    // Using simplified correlation for minimal implementation

    if churn.len() == 0 || failures.len() == 0 {
        return 0.0
    }

    // Calculate correlation coefficient (simplified)
    // For minimal implementation: if highest churn file has highest failures, correlation is high

    // Find max churn
    let mut max_churn = 0
    let mut max_churn_file = ""
    let mut i = 0
    while i < churn.len() {
        if churn[i].count > max_churn {
            max_churn = churn[i].count
            max_churn_file = churn[i].file
        }
        i = i + 1
    }

    // Find max failures
    let mut max_failures = 0
    let mut max_failure_file = ""
    let mut j = 0
    while j < failures.len() {
        if failures[j].count > max_failures {
            max_failures = failures[j].count
            max_failure_file = failures[j].file
        }
        j = j + 1
    }

    // If same file has both max churn and max failures, strong correlation
    if max_churn_file == max_failure_file {
        return 0.9  // High correlation
    } else {
        return 0.5  // Moderate correlation
    }
}

fun detect_cyclic_changes(changes: Vec<StageChange>) -> Vec<CyclicPattern> {
    // Identify files that change across multiple bootstrap stages
    // Strategy: Collect unique files, count appearances, filter multi-stage
    let mut unique_files = vec![]

    // Collect unique file names
    let mut i = 0
    while i < changes.len() {
        let current_file = changes[i].file

        // Check if file already tracked
        let mut exists = false
        let mut j = 0
        while j < unique_files.len() {
            if unique_files[j] == current_file {
                exists = true
            }
            j = j + 1
        }

        if !exists {
            unique_files.push(current_file)
        }
        i = i + 1
    }

    // Count stage changes for each unique file
    let mut cyclic_patterns = vec![]
    let mut k = 0
    while k < unique_files.len() {
        let target_file = unique_files[k]

        // Count appearances across stages
        let mut appearance_count = 0
        let mut m = 0
        while m < changes.len() {
            if changes[m].file == target_file {
                appearance_count = appearance_count + 1
            }
            m = m + 1
        }

        // Include only files changed in 2+ stages (cyclic pattern)
        if appearance_count >= 2 {
            cyclic_patterns.push(CyclicPattern {
                file: target_file,
                stage_count: appearance_count,
            })
        }
        k = k + 1
    }

    return cyclic_patterns
}

// Data structures
struct Commit {
    file: String,
    function: String,
    timestamp: i32,
}

struct ChurnMetric {
    file: String,
    function: String,
    count: i32,
}

struct Failure {
    file: String,
    stage: String,
    count: i32,
}

struct StageChange {
    file: String,
    stage: String,
    timestamp: i32,
}

struct CyclicPattern {
    file: String,
    stage_count: i32,
}
