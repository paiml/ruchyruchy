// test_closure_type_mapping_green.ruchy
// GREEN phase tests for WASM-002: Closure Compilation type mapping
// These tests validate the mapping of Ruchy closure types to WebAssembly

// Import the necessary types
import bootstrap::stage3::wasm_closure::Type;

// Mock implementation of RuchyWasmType for testing
struct RuchyWasmType {
    name: String,
    size: i32,
    is_closure: bool,
    params: Vec<RuchyWasmType>,
    result: Option<Box<RuchyWasmType>>,
    captures: Vec<RuchyWasmType>,
}

impl RuchyWasmType {
    // Creates a new type
    fn new(name: String) -> RuchyWasmType {
        let size = match name.as_str() {
            "i32" | "f32" | "bool" => 4,
            "i64" | "f64" => 8,
            _ => 4, // Default to pointer size
        };
        
        RuchyWasmType {
            name: name,
            size: size,
            is_closure: false,
            params: vec![],
            result: None,
            captures: vec![],
        }
    }
    
    // Creates a new closure type
    fn new_closure(params: Vec<RuchyWasmType>, result: RuchyWasmType, 
                  captures: Vec<RuchyWasmType>) -> RuchyWasmType {
        RuchyWasmType {
            name: "closure".to_string(),
            size: 4, // Pointer size
            is_closure: true,
            params: params,
            result: Some(Box::new(result)),
            captures: captures,
        }
    }
    
    // Gets the WASM type
    fn wasm_type(&self) -> Type {
        // All Ruchy types map to one of the WASM types
        match self.name.as_str() {
            "i32" | "bool" => Type::I32(),
            "i64" => Type::I64(),
            "f32" => Type::F32(),
            "f64" => Type::F64(),
            // Closures and other complex types are pointers
            _ => Type::I32(),
        }
    }
    
    // Gets the memory layout
    fn memory_layout(&self) -> MemoryLayout {
        if self.is_closure {
            // Calculate closure record size
            let mut size = 4; // Function index (4 bytes)
            
            // Add captured variable sizes
            for capture in &self.captures {
                size += capture.size;
            }
            
            MemoryLayout::new(size)
        } else {
            MemoryLayout::new(self.size)
        }
    }
}

// Memory layout for testing
struct MemoryLayout {
    size_value: i32,
}

impl MemoryLayout {
    fn new(size: i32) -> MemoryLayout {
        MemoryLayout { size_value: size }
    }
    
    fn size(&self) -> i32 {
        self.size_value
    }
}

// Tests for closure type mapping
fn test_simple_closure_type() {
    // Test a simple closure type with no captures
    let closure_type = RuchyWasmType::new_closure(
        vec![RuchyWasmType::new("i32".to_string())],
        RuchyWasmType::new("i32".to_string()),
        vec![]
    );
    
    // Check that it's a closure
    assert(closure_type.is_closure, 
           "Should be a closure type");
           
    // Check WASM type (should be a pointer)
    assert(closure_type.wasm_type() == Type::I32(), 
           "Closure should map to i32 pointer in WASM");
           
    // Check memory layout (just function index)
    assert_eq(closure_type.memory_layout().size(), 4, 
              "Closure size should be 4 bytes (function index)");

    println("✅ test_simple_closure_type passed");
}

fn test_closure_with_captures() {
    // Test a closure type with captures
    let closure_type = RuchyWasmType::new_closure(
        vec![RuchyWasmType::new("i32".to_string())],
        RuchyWasmType::new("i32".to_string()),
        vec![
            RuchyWasmType::new("i32".to_string()),
            RuchyWasmType::new("i64".to_string())
        ]
    );
    
    // Check memory layout
    // Function index (4) + i32 (4) + i64 (8) = 16 bytes
    assert_eq(closure_type.memory_layout().size(), 16, 
              "Closure size should be 16 bytes (4 + 4 + 8)");

    println("✅ test_closure_with_captures passed");
}

fn test_nested_closure_type() {
    // Test a closure that returns a closure
    let inner_closure = RuchyWasmType::new_closure(
        vec![RuchyWasmType::new("i32".to_string())],
        RuchyWasmType::new("i32".to_string()),
        vec![]
    );
    
    let outer_closure = RuchyWasmType::new_closure(
        vec![RuchyWasmType::new("i32".to_string())],
        inner_closure,
        vec![]
    );
    
    // Check that both are closures
    assert(outer_closure.is_closure, 
           "Outer type should be a closure");
           
    // Both closures are represented as pointers
    assert(outer_closure.wasm_type() == Type::I32(), 
           "Outer closure should map to i32 pointer in WASM");

    println("✅ test_nested_closure_type passed");
}

fn test_closure_in_array() {
    // Test an array of closures
    let closure_type = RuchyWasmType::new_closure(
        vec![RuchyWasmType::new("i32".to_string())],
        RuchyWasmType::new("i32".to_string()),
        vec![]
    );
    
    // Create an array type (mock implementation)
    let array_type = RuchyWasmType {
        name: "array".to_string(),
        size: 4, // Array is a pointer
        is_closure: false,
        params: vec![],
        result: None,
        captures: vec![closure_type],
    };
    
    // Array should be a pointer
    assert(array_type.wasm_type() == Type::I32(), 
           "Array should map to i32 pointer in WASM");

    println("✅ test_closure_in_array passed");
}

// Main function to run all tests
fn main() {
    println("Running WASM-002: Closure Type Mapping GREEN phase tests");
    
    // Run all tests
    test_simple_closure_type();
    test_closure_with_captures();
    test_nested_closure_type();
    test_closure_in_array();
    
    println("✅ All WASM-002 Closure Type Mapping GREEN phase tests completed successfully");
}