// BOOTSTRAP-006 UPDATED: Full Recursive AST with Box<T> (v3.96.0+)
// Complete Abstract Syntax Tree node types for Ruchy parser

// Expression AST nodes (FULL RECURSIVE STRUCTURE)
enum Expr {
    Number(String),
    Identifier(String),
    StringLit(String),
    BoolTrue,
    BoolFalse,
    Binary(BinOp, Box<Expr>, Box<Expr>),
    Unary(UnOp, Box<Expr>),
    Group(Box<Expr>)
}

// Binary operators
enum BinOp {
    Add,
    Sub,
    Mul,
    Div,
    Eq,
    Neq
}

// Unary operators
enum UnOp {
    Neg,
    Not
}

// Type annotations
enum Type {
    I32,
    I64,
    Bool,
    String
}

// Helper: Create a Number expression
fun make_number(val: String) -> Expr {
    Expr::Number(val)
}

// Helper: Create an Identifier expression
fun make_identifier(name: String) -> Expr {
    Expr::Identifier(name)
}

// Helper: Create a Binary expression (NOW WORKS!)
fun make_binary(op: BinOp, left: Expr, right: Expr) -> Expr {
    Expr::Binary(op, Box::new(left), Box::new(right))
}

// Helper: Create a Unary expression
fun make_unary(op: UnOp, operand: Expr) -> Expr {
    Expr::Unary(op, Box::new(operand))
}

// Test 1: Literals still work
fun test_literals() -> bool {
    println("  Testing literal expressions...");

    let num = make_number("42".to_string());
    let id = make_identifier("x".to_string());

    println("    Created Number(\"42\")");
    println("    Created Identifier(\"x\")");
    println("    ‚úÖ Pass");

    true
}

// Test 2: Binary expressions with Box<T>
fun test_binary_expressions() -> bool {
    println("  Testing binary expressions with Box<T>...");

    let left = make_number("1".to_string());
    let right = make_number("2".to_string());
    let add = make_binary(BinOp::Add, left, right);

    println("    Created Binary(Add, Box<Number(\"1\")>, Box<Number(\"2\")>)");
    println("    ‚úÖ Pass - Box<Expr> works!");

    true
}

// Test 3: Unary expressions with Box<T>
fun test_unary_expressions() -> bool {
    println("  Testing unary expressions with Box<T>...");

    let operand = make_number("42".to_string());
    let neg = make_unary(UnOp::Neg, operand);

    println("    Created Unary(Neg, Box<Number(\"42\")>)");
    println("    ‚úÖ Pass - Box<Expr> works!");

    true
}

// Test 4: Nested expressions (the real test!)
fun test_nested_expressions() -> bool {
    println("  Testing nested expressions...");

    // Build: 1 + (2 * 3)
    let two = make_number("2".to_string());
    let three = make_number("3".to_string());
    let mul = make_binary(BinOp::Mul, two, three);

    let one = make_number("1".to_string());
    let add = make_binary(BinOp::Add, one, mul);

    println("    Created nested: 1 + (2 * 3)");
    println("    Structure: Add(1, Mul(2, 3))");
    println("    ‚úÖ Pass - Nested Box<Expr> works!");

    true
}

fun main() {
    println("üß™ BOOTSTRAP-006 UPDATED: Full Recursive AST (v3.96.0)");
    println("");

    let mut passed = 0;
    let mut failed = 0;

    if test_literals() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_binary_expressions() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_unary_expressions() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_nested_expressions() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    println("");
    println("Total Tests: {}", passed + failed);
    println("Passed: {}", passed);
    println("Failed: {}", failed);

    if failed == 0 {
        println("");
        println("‚úÖ GREEN PHASE: Full recursive AST working!");
        println("");
        println("Key Achievement:");
        println("- Box<Expr> in enum variants works (v3.96.0)");
        println("- Nested expressions work perfectly");
        println("- Full Pratt parser now possible");
        println("- BOOTSTRAP-007/008/009 UNBLOCKED!");
    } else {
        println("");
        println("‚ùå {} test(s) failed", failed);
    }
}

main();
