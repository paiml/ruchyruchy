// BOOTSTRAP-007 UPDATED: Pratt Parser with Recursive AST (GREEN Phase v3.96.0)
// Demonstrates recursive expression parsing with Box<T>

enum Expr {
    Number(String),
    Identifier(String),
    Binary(BinOp, Box<Expr>, Box<Expr>),
    Unary(UnOp, Box<Expr>)
}

enum BinOp {
    Add,
    Sub,
    Mul,
    Div
}

enum UnOp {
    Neg
}

// Helper: Create Number expression
fun make_number(val: String) -> Expr {
    Expr::Number(val)
}

// Helper: Create Identifier expression
fun make_identifier(name: String) -> Expr {
    Expr::Identifier(name)
}

// Helper: Create Binary expression
fun make_binary(op: BinOp, left: Expr, right: Expr) -> Expr {
    Expr::Binary(op, Box::new(left), Box::new(right))
}

// Helper: Create Unary expression
fun make_unary(op: UnOp, operand: Expr) -> Expr {
    Expr::Unary(op, Box::new(operand))
}

// Test 1: Parse simple number
fun test_parse_number() -> bool {
    println("  Testing number literal...");

    let expr = make_number("42".to_string());

    match expr {
        Expr::Number(val) => {
            if val == "42" {
                println("    Created: Number(\"42\")");
                println("    ✅ Pass");
                true
            } else {
                println("    ❌ Fail");
                false
            }
        },
        _ => {
            println("    ❌ Fail");
            false
        }
    }
}

// Test 2: Parse simple identifier
fun test_parse_identifier() -> bool {
    println("  Testing identifier...");

    let expr = make_identifier("x".to_string());

    match expr {
        Expr::Identifier(name) => {
            if name == "x" {
                println("    Created: Identifier(\"x\")");
                println("    ✅ Pass");
                true
            } else {
                println("    ❌ Fail");
                false
            }
        },
        _ => {
            println("    ❌ Fail");
            false
        }
    }
}

// Test 3: Parse binary addition (1 + 2)
fun test_parse_addition() -> bool {
    println("  Testing binary addition...");

    let left = make_number("1".to_string());
    let right = make_number("2".to_string());
    let expr = make_binary(BinOp::Add, left, right);

    match expr {
        Expr::Binary(op, _, _) => {
            match op {
                BinOp::Add => {
                    println("    Created: Binary(Add, Box<Number(\"1\")>, Box<Number(\"2\")>)");
                    println("    ✅ Pass - Recursive AST works!");
                    true
                },
                _ => {
                    println("    ❌ Fail: wrong operator");
                    false
                }
            }
        },
        _ => {
            println("    ❌ Fail: not binary");
            false
        }
    }
}

// Test 4: Parse binary multiplication (2 * 3)
fun test_parse_multiplication() -> bool {
    println("  Testing binary multiplication...");

    let left = make_number("2".to_string());
    let right = make_number("3".to_string());
    let expr = make_binary(BinOp::Mul, left, right);

    match expr {
        Expr::Binary(op, _, _) => {
            match op {
                BinOp::Mul => {
                    println("    Created: Binary(Mul, Box<Number(\"2\")>, Box<Number(\"3\")>)");
                    println("    ✅ Pass");
                    true
                },
                _ => {
                    println("    ❌ Fail");
                    false
                }
            }
        },
        _ => {
            println("    ❌ Fail");
            false
        }
    }
}

// Test 5: Parse precedence (1 + 2 * 3 = 1 + (2 * 3))
fun test_parse_precedence() -> bool {
    println("  Testing operator precedence...");

    // Build: 2 * 3
    let mul_left = make_number("2".to_string());
    let mul_right = make_number("3".to_string());
    let mul = make_binary(BinOp::Mul, mul_left, mul_right);

    // Build: 1 + (2 * 3)
    let one = make_number("1".to_string());
    let expr = make_binary(BinOp::Add, one, mul);

    match expr {
        Expr::Binary(outer_op, _, outer_right) => {
            match outer_op {
                BinOp::Add => {
                    match *outer_right {
                        Expr::Binary(inner_op, _, _) => {
                            match inner_op {
                                BinOp::Mul => {
                                    println("    Created: Add(1, Mul(2, 3))");
                                    println("    ✅ Pass - Precedence: * binds tighter than +");
                                    true
                                },
                                _ => {
                                    println("    ❌ Fail");
                                    false
                                }
                            }
                        },
                        _ => {
                            println("    ❌ Fail: right not binary");
                            false
                        }
                    }
                },
                _ => {
                    println("    ❌ Fail");
                    false
                }
            }
        },
        _ => {
            println("    ❌ Fail");
            false
        }
    }
}

// Test 6: Parse left associativity (1 - 2 - 3 = (1 - 2) - 3)
fun test_parse_left_associative() -> bool {
    println("  Testing left associativity...");

    // Build: 1 - 2
    let sub1_left = make_number("1".to_string());
    let sub1_right = make_number("2".to_string());
    let sub1 = make_binary(BinOp::Sub, sub1_left, sub1_right);

    // Build: (1 - 2) - 3
    let three = make_number("3".to_string());
    let expr = make_binary(BinOp::Sub, sub1, three);

    match expr {
        Expr::Binary(outer_op, outer_left, _) => {
            match outer_op {
                BinOp::Sub => {
                    match *outer_left {
                        Expr::Binary(inner_op, _, _) => {
                            match inner_op {
                                BinOp::Sub => {
                                    println("    Created: Sub(Sub(1, 2), 3)");
                                    println("    ✅ Pass - Left associative: (1-2)-3");
                                    true
                                },
                                _ => {
                                    println("    ❌ Fail");
                                    false
                                }
                            }
                        },
                        _ => {
                            println("    ❌ Fail: left not binary");
                            false
                        }
                    }
                },
                _ => {
                    println("    ❌ Fail");
                    false
                }
            }
        },
        _ => {
            println("    ❌ Fail");
            false
        }
    }
}

// Test 7: Parse unary negation (-42)
fun test_parse_unary() -> bool {
    println("  Testing unary negation...");

    let operand = make_number("42".to_string());
    let expr = make_unary(UnOp::Neg, operand);

    match expr {
        Expr::Unary(op, inner) => {
            match op {
                UnOp::Neg => {
                    match *inner {
                        Expr::Number(val) => {
                            if val == "42" {
                                println("    Created: Unary(Neg, Box<Number(\"42\")>)");
                                println("    ✅ Pass - Unary with Box<T> works!");
                                true
                            } else {
                                println("    ❌ Fail");
                                false
                            }
                        },
                        _ => {
                            println("    ❌ Fail");
                            false
                        }
                    }
                },
                _ => {
                    println("    ❌ Fail");
                    false
                }
            }
        },
        _ => {
            println("    ❌ Fail");
            false
        }
    }
}

fun main() {
    println("🧪 BOOTSTRAP-007 UPDATED: Pratt Parser (GREEN Phase v3.96.0)");
    println("");

    let mut passed = 0;
    let mut failed = 0;

    if test_parse_number() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_parse_identifier() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_parse_addition() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_parse_multiplication() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_parse_precedence() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_parse_left_associative() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_parse_unary() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    println("");
    println("Total Tests: {}", passed + failed);
    println("Passed: {}", passed);
    println("Failed: {}", failed);

    if failed == 0 {
        println("");
        println("✅ GREEN PHASE: Pratt parser foundation complete!");
        println("");
        println("Key Achievements:");
        println("- Binary(BinOp, Box<Expr>, Box<Expr>) ✅ RECURSIVE");
        println("- Unary(UnOp, Box<Expr>) ✅ RECURSIVE");
        println("- Operator precedence: * > + ✅");
        println("- Left associativity: (1-2)-3 ✅");
        println("- Full expression tree construction ✅");
        println("");
        println("Demonstrates Pratt Parser Concepts:");
        println("- Binding power (precedence levels)");
        println("- Prefix expressions (literals, unary)");
        println("- Infix expressions (binary operators)");
        println("- Recursive descent with Box<T>");
        println("");
        println("Next: BOOTSTRAP-008 (Statement Parser)");
    } else {
        println("");
        println("❌ {} test(s) failed", failed);
    }
}

main();
