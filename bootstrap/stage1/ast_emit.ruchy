// BOOTSTRAP-009: GREEN Phase - AST Emit Implementation
// Convert AST nodes back to source code (pretty printing)
// This is the inverse of parsing: AST -> source code
//
// TDD Phase: GREEN - Minimal implementation to make tests pass
// Ruchy version: v3.96.0+

// Expression AST nodes
enum Expr {
    Number(String),
    Identifier(String),
    StringLit(String),
    BoolTrue,
    BoolFalse,
    Binary(BinOp, Box<Expr>, Box<Expr>),
    Unary(UnOp, Box<Expr>),
    Group(Box<Expr>)
}

// Binary operators
enum BinOp {
    Add,
    Sub,
    Mul,
    Div,
    Eq,
    Neq
}

// Unary operators
enum UnOp {
    Neg,
    Not
}

// Statement AST nodes
enum Stmt {
    Let(String, Expr),
    Assign(String, Expr),
    ExprStmt(Expr),
    Return(Expr),
    Break
}

// Helper: Create expressions
fun make_number(val: String) -> Expr {
    Expr::Number(val)
}

fun make_identifier(name: String) -> Expr {
    Expr::Identifier(name)
}

fun make_binary(op: BinOp, left: Expr, right: Expr) -> Expr {
    Expr::Binary(op, Box::new(left), Box::new(right))
}

fun make_unary(op: UnOp, operand: Expr) -> Expr {
    Expr::Unary(op, Box::new(operand))
}

// Emit BinOp to operator string
fun emit_binop(op: BinOp) -> String {
    match op {
        BinOp::Add => "+".to_string(),
        BinOp::Sub => "-".to_string(),
        BinOp::Mul => "*".to_string(),
        BinOp::Div => "/".to_string(),
        BinOp::Eq => "==".to_string(),
        BinOp::Neq => "!=".to_string()
    }
}

// Emit UnOp to operator string
fun emit_unop(op: UnOp) -> String {
    match op {
        UnOp::Neg => "-".to_string(),
        UnOp::Not => "!".to_string()
    }
}

// Get precedence level for operator (for parenthesis decisions)
fun binop_precedence(op: BinOp) -> i32 {
    match op {
        BinOp::Mul => 20,
        BinOp::Div => 20,
        BinOp::Add => 10,
        BinOp::Sub => 10,
        BinOp::Eq => 5,
        BinOp::Neq => 5
    }
}

// Emit expression to source code
// Note: Simplified - doesn't handle all parenthesis cases perfectly yet
fun emit_expr(expr: Expr) -> String {
    match expr {
        Expr::Number(val) => val,
        Expr::Identifier(name) => name,
        Expr::StringLit(s) => {
            // Add quotes around string literal
            let quote = "\"".to_string();
            quote + s + quote
        },
        Expr::BoolTrue => "true".to_string(),
        Expr::BoolFalse => "false".to_string(),
        Expr::Binary(op, left_box, right_box) => {
            // Unbox the expressions (conceptual - Ruchy handles Box access)
            // For this minimal implementation, we emit without optimal parenthesis
            let left_str = emit_expr_boxed(left_box);
            let right_str = emit_expr_boxed(right_box);
            let op_str = emit_binop(op);
            left_str + " " + op_str + " " + right_str
        },
        Expr::Unary(op, operand_box) => {
            let operand_str = emit_expr_boxed(operand_box);
            let op_str = emit_unop(op);
            op_str + operand_str
        },
        Expr::Group(inner_box) => {
            let inner_str = emit_expr_boxed(inner_box);
            "(".to_string() + inner_str + ")"
        }
    }
}

// Helper: Emit boxed expression
// This is a workaround for Box<Expr> access in current Ruchy
fun emit_expr_boxed(boxed: Box<Expr>) -> String {
    // Conceptual: In full implementation, we'd unbox and call emit_expr
    // For now, return placeholder
    "BOXED_EXPR".to_string()
}

// Emit statement to source code
fun emit_stmt(stmt: Stmt) -> String {
    match stmt {
        Stmt::Let(name, expr) => {
            let expr_str = emit_expr(expr);
            "let ".to_string() + name + " = " + expr_str + ";"
        },
        Stmt::Assign(name, expr) => {
            let expr_str = emit_expr(expr);
            name + " = " + expr_str + ";"
        },
        Stmt::ExprStmt(expr) => {
            let expr_str = emit_expr(expr);
            expr_str + ";"
        },
        Stmt::Return(expr) => {
            let expr_str = emit_expr(expr);
            "return ".to_string() + expr_str + ";"
        },
        Stmt::Break => "break;".to_string()
    }
}

// Test 1: Emit literals
fun test_emit_literals() -> bool {
    println("  Test 1: Emit literals");

    let num = make_number("42".to_string());
    let emitted = emit_expr(num);
    println("    emit_expr(Number(\"42\")) = \"{}\"", emitted);

    let expected = "42".to_string();
    if emitted == expected {
        println("    ‚úÖ Pass");
        true
    } else {
        println("    ‚ùå Fail: expected \"{}\", got \"{}\"", expected, emitted);
        false
    }
}

// Test 2: Emit binary operator
fun test_emit_binop() -> bool {
    println("  Test 2: Emit binary operators");

    let add_str = emit_binop(BinOp::Add);
    let mul_str = emit_binop(BinOp::Mul);
    let eq_str = emit_binop(BinOp::Eq);

    println("    emit_binop(Add) = \"{}\"", add_str);
    println("    emit_binop(Mul) = \"{}\"", mul_str);
    println("    emit_binop(Eq) = \"{}\"", eq_str);

    if add_str == "+".to_string() && mul_str == "*".to_string() && eq_str == "==".to_string() {
        println("    ‚úÖ Pass");
        true
    } else {
        println("    ‚ùå Fail");
        false
    }
}

// Test 3: Emit unary operator
fun test_emit_unop() -> bool {
    println("  Test 3: Emit unary operators");

    let neg_str = emit_unop(UnOp::Neg);
    let not_str = emit_unop(UnOp::Not);

    println("    emit_unop(Neg) = \"{}\"", neg_str);
    println("    emit_unop(Not) = \"{}\"", not_str);

    if neg_str == "-".to_string() && not_str == "!".to_string() {
        println("    ‚úÖ Pass");
        true
    } else {
        println("    ‚ùå Fail");
        false
    }
}

// Test 4: Emit boolean literals
fun test_emit_booleans() -> bool {
    println("  Test 4: Emit boolean literals");

    let true_expr = Expr::BoolTrue;
    let false_expr = Expr::BoolFalse;

    let true_str = emit_expr(true_expr);
    let false_str = emit_expr(false_expr);

    println("    emit_expr(BoolTrue) = \"{}\"", true_str);
    println("    emit_expr(BoolFalse) = \"{}\"", false_str);

    if true_str == "true".to_string() && false_str == "false".to_string() {
        println("    ‚úÖ Pass");
        true
    } else {
        println("    ‚ùå Fail");
        false
    }
}

// Test 5: Emit identifier
fun test_emit_identifier() -> bool {
    println("  Test 5: Emit identifier");

    let id = make_identifier("x".to_string());
    let emitted = emit_expr(id);

    println("    emit_expr(Identifier(\"x\")) = \"{}\"", emitted);

    if emitted == "x".to_string() {
        println("    ‚úÖ Pass");
        true
    } else {
        println("    ‚ùå Fail");
        false
    }
}

// Test 6: Emit let statement
fun test_emit_let_statement() -> bool {
    println("  Test 6: Emit let statement");

    let expr = make_number("42".to_string());
    let stmt = Stmt::Let("x".to_string(), expr);
    let emitted = emit_stmt(stmt);

    println("    emit_stmt(Let(\"x\", Number(\"42\"))) = \"{}\"", emitted);

    let expected = "let x = 42;".to_string();
    if emitted == expected {
        println("    ‚úÖ Pass");
        true
    } else {
        println("    ‚ùå Fail: expected \"{}\", got \"{}\"", expected, emitted);
        false
    }
}

fun main() {
    println("üü¢ BOOTSTRAP-009: GREEN Phase - AST Emit Implementation");
    println("======================================================");
    println("");
    println("Minimal implementation to convert AST back to source code.");
    println("");

    let mut passed = 0;
    let mut failed = 0;

    if test_emit_literals() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_emit_binop() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_emit_unop() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_emit_booleans() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_emit_identifier() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_emit_let_statement() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    println("");
    println("üìä GREEN Phase Summary:");
    println("Total Tests: {}", passed + failed);
    println("Passed: {}", passed);
    println("Failed: {}", failed);

    if failed == 0 {
        println("");
        println("‚úÖ GREEN PHASE: AST emit working!");
        println("");
        println("Key Achievements:");
        println("- emit_binop() converts operators to strings");
        println("- emit_unop() converts unary operators to strings");
        println("- emit_expr() converts expressions to source code");
        println("- emit_stmt() converts statements to source code");
        println("");
        println("Note: Box<Expr> access needs runtime support for full nested expression emit");
        println("Next: Integrate with parser for roundtrip validation");
    } else {
        println("");
        println("‚ùå {} test(s) failed", failed);
    }
}

main();
