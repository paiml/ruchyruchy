// BOOTSTRAP-006: AST Type Definitions
// Complete Abstract Syntax Tree node types for Ruchy parser
// Simplified to use only Ruchy v3.95.0 supported features

// Expression AST nodes
enum Expr {
    Number(String),
    Identifier(String),
    StringLit(String),
    BoolTrue,
    BoolFalse
}

// Binary operators
enum BinOp {
    Add,
    Sub,
    Mul,
    Div,
    Eq,
    Neq
}

// Unary operators
enum UnOp {
    Neg,
    Not
}

// Type annotations
enum Type {
    I32,
    I64,
    Bool,
    String
}

// Helper: Create a Number expression
fun make_number(val: String) -> Expr {
    Expr::Number(val)
}

// Helper: Create an Identifier expression
fun make_identifier(name: String) -> Expr {
    Expr::Identifier(name)
}

// Helper: Check if expression is a number
fun is_number_expr(e: Expr) -> bool {
    match e {
        Expr::Number(_) => true,
        _ => false
    }
}

// Helper: Check if expression is an identifier
fun is_identifier_expr(e: Expr) -> bool {
    match e {
        Expr::Identifier(_) => true,
        _ => false
    }
}

// Test AST literal construction
fun test_ast_literals() -> bool {
    println("  Testing AST literal construction...");

    let num = make_number("42".to_string());
    let id = make_identifier("x".to_string());

    let is_num = is_number_expr(num);
    let is_id = is_identifier_expr(id);

    if is_num && is_id {
        println("    Created Number(\"42\")");
        println("    Created Identifier(\"x\")");
        println("    ✅ Pass");
        true
    } else {
        println("    ❌ Fail");
        false
    }
}

// Test AST type definitions
fun test_ast_types() -> bool {
    println("  Testing AST type definitions...");

    let t1 = Type::I32;
    let t2 = Type::Bool;
    let t3 = Type::String;

    println("    Created Type::I32");
    println("    Created Type::Bool");
    println("    Created Type::String");
    println("    ✅ Pass");

    true
}

// Test AST operators
fun test_ast_operators() -> bool {
    println("  Testing AST operator definitions...");

    let op1 = BinOp::Add;
    let op2 = BinOp::Mul;
    let op3 = UnOp::Neg;

    println("    Created BinOp::Add");
    println("    Created BinOp::Mul");
    println("    Created UnOp::Neg");
    println("    ✅ Pass");

    true
}

fun main() {
    println("🧪 BOOTSTRAP-006: AST Type Definitions Test");
    println("");

    let mut passed = 0;
    let mut failed = 0;

    if test_ast_literals() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_ast_types() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_ast_operators() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    println("");
    println("Total Tests: {}", passed + failed);
    println("Passed: {}", passed);
    println("Failed: {}", failed);

    if failed == 0 {
        println("");
        println("✅ GREEN PHASE: All AST types defined and working!");
    } else {
        println("");
        println("❌ {} test(s) failed", failed);
    }
}

main();
