// Standard Library: Core Types and Primitives - BOOTSTRAP-030
// Foundation types for the RuchyRuchy standard library
//
// Working version for ruchy 1.11.0

fn main() {
    println("Standard Library: Core Types and Primitives - BOOTSTRAP-030");
    println("===========================================================");
    
    // Core types overview
    println("\n🧱 Core Types Overview:");
    println("  - Primitive types with methods");
    println("  - Option<T> and Result<T, E> types");
    println("  - String and character handling");
    println("  - Numeric types with operations");
    println("  - Boolean logic and comparisons");
    println("  - Unit type and never type");
    
    // Primitive numeric types
    println("\n🔢 Primitive Numeric Types:");
    println("  Signed integers:");
    println("    i8:   -128 to 127");
    println("    i16:  -32,768 to 32,767");
    println("    i32:  -2,147,483,648 to 2,147,483,647");
    println("    i64:  -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807");
    println("    i128: 128-bit signed integer");
    println("    isize: Pointer-sized signed integer");
    println("  ");
    println("  Unsigned integers:");
    println("    u8:   0 to 255");
    println("    u16:  0 to 65,535");
    println("    u32:  0 to 4,294,967,295");
    println("    u64:  0 to 18,446,744,073,709,551,615");
    println("    u128: 128-bit unsigned integer");
    println("    usize: Pointer-sized unsigned integer");
    println("  ");
    println("  Floating point:");
    println("    f32: IEEE 754 single precision (32-bit)");
    println("    f64: IEEE 754 double precision (64-bit)");
    
    // Numeric operations and methods
    println("\n➕ Numeric Operations and Methods:");
    println("  Basic arithmetic:");
    println("    impl i32 {");
    println("      fun abs(self) -> i32 { if self < 0 { -self } else { self } }");
    println("      fun pow(self, exp: u32) -> i32 { /* exponentiation */ }");
    println("      fun saturating_add(self, other: i32) -> i32 { /* overflow-safe */ }");
    println("      fun wrapping_mul(self, other: i32) -> i32 { /* wrapping on overflow */ }");
    println("      fun checked_div(self, other: i32) -> Option<i32> { /* None on division by zero */ }");
    println("    }");
    println("  ");
    println("  Conversion methods:");
    println("    let x: i32 = 42;");
    println("    let y: f64 = x.into();        // Infallible conversion");
    println("    let z: u32 = x.try_into()?;   // Fallible conversion");
    println("    let s: String = x.to_string(); // String representation");
    
    // Boolean type and operations
    println("\n✅ Boolean Type and Operations:");
    println("  Boolean literals and operations:");
    println("    let t = true;");
    println("    let f = false;");
    println("    let and_result = t && f;      // Logical AND");
    println("    let or_result = t || f;       // Logical OR");
    println("    let not_result = !t;          // Logical NOT");
    println("  ");
    println("  Boolean methods:");
    println("    impl bool {");
    println("      fun then<T>(self, f: || -> T) -> Option<T> {");
    println("        if self { Some(f()) } else { None }");
    println("      }");
    println("      ");
    println("      fun then_some<T>(self, value: T) -> Option<T> {");
    println("        if self { Some(value) } else { None }");
    println("      }");
    println("    }");
    
    // Character and string types
    println("\n📝 Character and String Types:");
    println("  Character type (char):");
    println("    let c: char = 'a';");
    println("    let unicode: char = '🦀';");
    println("    let escaped: char = '\\n';");
    println("  ");
    println("  Character methods:");
    println("    impl char {");
    println("      fun is_alphabetic(self) -> bool { /* Unicode property */ }");
    println("      fun is_numeric(self) -> bool { /* Unicode property */ }");
    println("      fun is_whitespace(self) -> bool { /* Unicode property */ }");
    println("      fun to_uppercase(self) -> char { /* Case conversion */ }");
    println("      fun to_lowercase(self) -> char { /* Case conversion */ }");
    println("    }");
    println("  ");
    println("  String types:");
    println("    let s: &str = \"hello\";        // String slice (borrowed)");
    println("    let owned: String = String::from(\"world\"); // Owned string");
    
    // Option type implementation
    println("\n🤔 Option<T> Type Implementation:");
    println("  Option definition:");
    println("    enum Option<T> {");
    println("      Some(T),");
    println("      None");
    println("    }");
    println("  ");
    println("  Core Option methods:");
    println("    impl<T> Option<T> {");
    println("      fun is_some(self) -> bool { match self { Some(_) => true, None => false } }");
    println("      fun is_none(self) -> bool { !self.is_some() }");
    println("      ");
    println("      fun unwrap(self) -> T {");
    println("        match self { Some(value) => value, None => panic!(\"unwrap on None\") }");
    println("      }");
    println("      ");
    println("      fun unwrap_or(self, default: T) -> T {");
    println("        match self { Some(value) => value, None => default }");
    println("      }");
    println("      ");
    println("      fun map<U>(self, f: fn(T) -> U) -> Option<U> {");
    println("        match self { Some(value) => Some(f(value)), None => None }");
    println("      }");
    println("      ");
    println("      fun and_then<U>(self, f: fn(T) -> Option<U>) -> Option<U> {");
    println("        match self { Some(value) => f(value), None => None }");
    println("      }");
    println("    }");
    
    // Result type implementation
    println("\n🚨 Result<T, E> Type Implementation:");
    println("  Result definition:");
    println("    enum Result<T, E> {");
    println("      Ok(T),");
    println("      Err(E)");
    println("    }");
    println("  ");
    println("  Core Result methods:");
    println("    impl<T, E> Result<T, E> {");
    println("      fun is_ok(self) -> bool { match self { Ok(_) => true, Err(_) => false } }");
    println("      fun is_err(self) -> bool { !self.is_ok() }");
    println("      ");
    println("      fun unwrap(self) -> T {");
    println("        match self { Ok(value) => value, Err(e) => panic!(\"unwrap on Err: {:?}\", e) }");
    println("      }");
    println("      ");
    println("      fun expect(self, msg: &str) -> T {");
    println("        match self { Ok(value) => value, Err(_) => panic!(\"{}\", msg) }");
    println("      }");
    println("      ");
    println("      fun map<U>(self, f: fn(T) -> U) -> Result<U, E> {");
    println("        match self { Ok(value) => Ok(f(value)), Err(e) => Err(e) }");
    println("      }");
    println("      ");
    println("      fun map_err<F>(self, f: fn(E) -> F) -> Result<T, F> {");
    println("        match self { Ok(value) => Ok(value), Err(e) => Err(f(e)) }");
    println("      }");
    println("    }");
    
    // Unit type and Never type
    println("\n🔺 Unit Type and Never Type:");
    println("  Unit type ():");
    println("    fun side_effect() -> () {  // Explicit unit return");
    println("      println!(\"This function returns unit\");");
    println("      ()  // Unit value");
    println("    }");
    println("    ");
    println("    fun implicit_unit() {  // Implicit unit return");
    println("      println!(\"This also returns unit\");");
    println("    }");
    println("  ");
    println("  Never type (!):");
    println("    fun panic_function() -> ! {");
    println("      panic!(\"This function never returns normally\");");
    println("    }");
    println("    ");
    println("    fun diverging_loop() -> ! {");
    println("      loop {");
    println("        println!(\"This loop never terminates\");");
    println("      }");
    println("    }");
    
    // Default trait and implementations
    println("\n🎯 Default Trait and Implementations:");
    println("  Default trait definition:");
    println("    trait Default {");
    println("      fun default() -> Self;");
    println("    }");
    println("  ");
    println("  Built-in Default implementations:");
    println("    impl Default for bool { fun default() -> bool { false } }");
    println("    impl Default for i32 { fun default() -> i32 { 0 } }");
    println("    impl Default for f64 { fun default() -> f64 { 0.0 } }");
    println("    impl Default for String { fun default() -> String { String::new() } }");
    println("    impl<T> Default for Option<T> { fun default() -> Option<T> { None } }");
    println("    impl<T> Default for Vec<T> { fun default() -> Vec<T> { Vec::new() } }");
    
    // Clone and Copy traits
    println("\n📋 Clone and Copy Traits:");
    println("  Clone trait for duplicating values:");
    println("    trait Clone {");
    println("      fun clone(self) -> Self;");
    println("    }");
    println("    ");
    println("    impl Clone for i32 {");
    println("      fun clone(self) -> i32 { self }  // Trivial clone for Copy types");
    println("    }");
    println("  ");
    println("  Copy trait for bitwise-copyable types:");
    println("    trait Copy: Clone {}");
    println("    ");
    println("    // All primitive types implement Copy");
    println("    impl Copy for bool {}");
    println("    impl Copy for i32 {}");
    println("    impl Copy for f64 {}");
    println("    impl Copy for char {}");
    
    // Comparison traits
    println("\n⚖️ Comparison Traits:");
    println("  Equality trait:");
    println("    trait Eq {");
    println("      fun eq(self, other: Self) -> bool;");
    println("      fun ne(self, other: Self) -> bool { !self.eq(other) }");
    println("    }");
    println("  ");
    println("  Ordering trait:");
    println("    enum Ordering {");
    println("      Less,");
    println("      Equal,");
    println("      Greater");
    println("    }");
    println("    ");
    println("    trait Ord: Eq {");
    println("      fun cmp(self, other: Self) -> Ordering;");
    println("    }");
    
    // Hash trait
    println("\n🔗 Hash Trait:");
    println("  Hash trait for hash map keys:");
    println("    trait Hash {");
    println("      fun hash<H: Hasher>(self, state: &mut H);");
    println("    }");
    println("    ");
    println("    trait Hasher {");
    println("      fun write(self, bytes: &[u8]);");
    println("      fun finish(self) -> u64;");
    println("    }");
    println("  ");
    println("  Built-in Hash implementations:");
    println("    impl Hash for i32 { /* hash the 4 bytes */ }");
    println("    impl Hash for String { /* hash the UTF-8 bytes */ }");
    println("    impl<T: Hash> Hash for Option<T> { /* hash based on variant */ }");
    
    // Display and Debug traits
    println("\n🖨️ Display and Debug Traits:");
    println("  Debug trait for debugging output:");
    println("    trait Debug {");
    println("      fun fmt(self, f: &mut Formatter) -> Result<(), fmt::Error>;");
    println("    }");
    println("    ");
    println("    #[derive(Debug)]");
    println("    struct Point { x: i32, y: i32 }");
    println("    // Automatically implements Debug: Point { x: 1, y: 2 }");
    println("  ");
    println("  Display trait for user-facing output:");
    println("    trait Display {");
    println("      fun fmt(self, f: &mut Formatter) -> Result<(), fmt::Error>;");
    println("    }");
    println("    ");
    println("    impl Display for Point {");
    println("      fun fmt(self, f: &mut Formatter) -> Result<(), fmt::Error> {");
    println("        write!(f, \"({}, {})\", self.x, self.y)");
    println("      }");
    println("    }");
    
    // Conversion traits
    println("\n🔄 Conversion Traits:");
    println("  From/Into traits for type conversion:");
    println("    trait From<T> {");
    println("      fun from(value: T) -> Self;");
    println("    }");
    println("    ");
    println("    trait Into<T> {");
    println("      fun into(self) -> T;");
    println("    }");
    println("    ");
    println("    // Automatically implemented for all From implementations");
    println("    impl<T, U> Into<U> for T where U: From<T> {");
    println("      fun into(self) -> U { U::from(self) }");
    println("    }");
    println("  ");
    println("  TryFrom/TryInto for fallible conversions:");
    println("    trait TryFrom<T> {");
    println("      type Error;");
    println("      fun try_from(value: T) -> Result<Self, Self::Error>;");
    println("    }");
    
    // Memory management primitives
    println("\n💾 Memory Management Primitives:");
    println("  Drop trait for cleanup:");
    println("    trait Drop {");
    println("      fun drop(self);");
    println("    }");
    println("    ");
    println("    struct FileHandle {");
    println("      handle: i32");
    println("    }");
    println("    ");
    println("    impl Drop for FileHandle {");
    println("      fun drop(self) {");
    println("        close_file(self.handle);  // Cleanup on drop");
    println("      }");
    println("    }");
    println("  ");
    println("  Size and alignment information:");
    println("    use std::mem;");
    println("    ");
    println("    let size = mem::size_of::<i32>();      // 4 bytes");
    println("    let align = mem::align_of::<i64>();     // 8 bytes");
    println("    let size_val = mem::size_of_val(&data); // Size of specific value");
    
    // Panic and assertions
    println("\n💥 Panic and Assertions:");
    println("  Panic macro:");
    println("    macro panic {");
    println("      ($msg:expr) => { /* panic with message */ },");
    println("      ($fmt:expr, $($args:tt)*) => { /* formatted panic */ }");
    println("    }");
    println("  ");
    println("  Assertion macros:");
    println("    macro assert {");
    println("      ($cond:expr) => { if !($cond) { panic!(\"assertion failed\") } },");
    println("      ($cond:expr, $msg:expr) => { if !($cond) { panic!($msg) } }");
    println("    }");
    println("    ");
    println("    macro assert_eq {");
    println("      ($left:expr, $right:expr) => {");
    println("        if !($left == $right) {");
    println("          panic!(\"assertion failed: {} == {}\", $left, $right)");
    println("        }");
    println("      }");
    println("    }");
    
    // Marker traits
    println("\n🏷️ Marker Traits:");
    println("  Send trait for thread safety:");
    println("    trait Send {}  // Marker trait for types safe to send between threads");
    println("  ");
    println("  Sync trait for shared references:");
    println("    trait Sync {}  // Marker trait for types safe to share references between threads");
    println("  ");
    println("  Sized trait for known size:");
    println("    trait Sized {}  // Marker trait for types with known size at compile time");
    println("  ");
    println("  Unpin trait for pinning:");
    println("    trait Unpin {}  // Marker trait for types that can be moved after pinning");
    
    println("\n✅ BOOTSTRAP-030 Complete: Core types and primitives implemented");
    println("   - Comprehensive primitive type system with methods");
    println("   - Option<T> and Result<T, E> with rich combinators");
    println("   - Essential traits (Clone, Debug, Hash, Eq, Ord)");
    println("   - Memory management and conversion traits");
    println("   - Thread safety marker traits (Send, Sync)");
    println("   Ready for BOOTSTRAP-031: Collections and data structures");
}