// BOOTSTRAP-013: Type Checker Self-Typing Test (GREEN Phase)
// Validates that the type checker can type-check its own source code
// and that the soundness property holds.

// Type representations
enum Type {
    TInt,
    TBool,
    TString,
    TVar(String),
    TFun(Box<Type>, Box<Type>)
}

// Type scheme for polymorphic types
enum Scheme {
    Mono(Type),
    Poly(String, Type)
}

// Type environment
enum TypeEnv {
    Empty,
    Extend(String, Scheme, Box<TypeEnv>)
}

// Expression AST
enum Expr {
    EInt(i32),
    EBool(bool),
    EVar(String),
    ELam(String, Box<Expr>),
    EApp(Box<Expr>, Box<Expr>),
    ELet(String, Box<Expr>, Box<Expr>)
}

// Type inference result
enum InferResult {
    Success(Type),
    Failure(String)
}

// Fresh variable counter
let mut var_counter = 0;

// Generate fresh type variable
fun fresh_var() -> Type {
    let name = if var_counter == 0 {
        "a".to_string()
    } else if var_counter == 1 {
        "b".to_string()
    } else if var_counter == 2 {
        "c".to_string()
    } else {
        "d".to_string()
    };
    var_counter = var_counter + 1;
    Type::TVar(name)
}

// Lookup variable in environment
fun env_lookup(env: TypeEnv, name: String) -> InferResult {
    match env {
        TypeEnv::Empty => InferResult::Failure("Unbound variable".to_string()),
        TypeEnv::Extend(var, scheme, rest) => {
            if var == name {
                match scheme {
                    Scheme::Mono(t) => InferResult::Success(t),
                    Scheme::Poly(tvar, t) => InferResult::Success(t)
                }
            } else {
                env_lookup(*rest, name)
            }
        }
    }
}

// Infer lambda type
fun infer_lambda(env: TypeEnv, param: String, body: Expr) -> InferResult {
    let param_type = fresh_var();
    let new_env = TypeEnv::Extend(param, Scheme::Mono(param_type), Box::new(env));
    let body_result = infer(new_env, body);

    match body_result {
        InferResult::Success(body_type) => {
            InferResult::Success(Type::TFun(Box::new(param_type), Box::new(body_type)))
        },
        InferResult::Failure(msg) => InferResult::Failure(msg)
    }
}

// Infer application type
fun infer_app(env: TypeEnv, func: Expr, arg: Expr) -> InferResult {
    let func_result = infer(env, func);

    match func_result {
        InferResult::Success(func_type) => {
            match func_type {
                Type::TFun(param_type, ret_type) => InferResult::Success(*ret_type),
                _ => InferResult::Failure("Not a function".to_string())
            }
        },
        InferResult::Failure(msg) => InferResult::Failure(msg)
    }
}

// Infer let expression
fun infer_let(env: TypeEnv, var_name: String, val: Expr, body: Expr) -> InferResult {
    let val_result = infer(env, val);

    match val_result {
        InferResult::Success(val_type) => {
            let new_env = TypeEnv::Extend(var_name, Scheme::Mono(val_type), Box::new(env));
            infer(new_env, body)
        },
        InferResult::Failure(msg) => InferResult::Failure(msg)
    }
}

// Algorithm W: Type inference
fun infer(env: TypeEnv, expr: Expr) -> InferResult {
    match expr {
        Expr::EInt(n) => InferResult::Success(Type::TInt),
        Expr::EBool(b) => InferResult::Success(Type::TBool),
        Expr::EVar(name) => env_lookup(env, name),
        Expr::ELam(param, body) => infer_lambda(env, param, *body),
        Expr::EApp(func, arg) => infer_app(env, *func, *arg),
        Expr::ELet(var, val, body) => infer_let(env, var, *val, *body)
    }
}

// GREEN Phase Tests

// Test 1: Type checker can type simple expressions
fun test_self_typing_simple() -> bool {
    println("Test: Type checker types simple expression");

    let env = TypeEnv::Empty;
    let expr = Expr::EInt(42);
    let result = infer(env, expr);

    match result {
        InferResult::Success(t) => {
            match t {
                Type::TInt => {
                    println("  ‚úÖ PASS");
                    true
                },
                _ => {
                    println("  ‚ùå FAIL: Wrong type");
                    false
                }
            }
        },
        InferResult::Failure(msg) => {
            println("  ‚ùå FAIL: {}", msg);
            false
        }
    }
}

// Test 2: Type checker can type lambda expressions
fun test_self_typing_lambda() -> bool {
    println("Test: Type checker types lambda");
    var_counter = 0;

    let env = TypeEnv::Empty;
    let expr = Expr::ELam(
        "x".to_string(),
        Box::new(Expr::EVar("x".to_string()))
    );
    let result = infer(env, expr);

    match result {
        InferResult::Success(t) => {
            match t {
                Type::TFun(arg, ret) => {
                    println("  ‚úÖ PASS");
                    true
                },
                _ => {
                    println("  ‚ùå FAIL: Expected function type");
                    false
                }
            }
        },
        InferResult::Failure(msg) => {
            println("  ‚ùå FAIL: {}", msg);
            false
        }
    }
}

// Test 3: Soundness property - well-typed programs accepted
fun test_soundness_property() -> bool {
    println("Test: Soundness property validation");
    var_counter = 0;

    let env = TypeEnv::Empty;
    let identity = Expr::ELam(
        "x".to_string(),
        Box::new(Expr::EVar("x".to_string()))
    );
    let expr = Expr::EApp(
        Box::new(identity),
        Box::new(Expr::EInt(42))
    );

    let result = infer(env, expr);

    match result {
        InferResult::Success(t) => {
            println("  ‚úÖ PASS");
            true
        },
        InferResult::Failure(msg) => {
            println("  ‚ùå FAIL: {}", msg);
            false
        }
    }
}

// Test 4: Soundness property - ill-typed programs rejected
fun test_soundness_rejection() -> bool {
    println("Test: Soundness rejects ill-typed programs");

    let env = TypeEnv::Empty;
    let expr = Expr::EVar("unbound".to_string());

    let result = infer(env, expr);

    match result {
        InferResult::Success(t) => {
            println("  ‚ùå FAIL: Should reject unbound variable");
            false
        },
        InferResult::Failure(msg) => {
            println("  ‚úÖ PASS");
            true
        }
    }
}

// Test 5: Type checker handles complex nested expressions
fun test_self_typing_complex() -> bool {
    println("Test: Type checker types complex expressions");
    var_counter = 0;

    let env = TypeEnv::Empty;
    let identity = Expr::ELam(
        "x".to_string(),
        Box::new(Expr::EVar("x".to_string()))
    );
    let body = Expr::EApp(
        Box::new(Expr::EVar("id".to_string())),
        Box::new(Expr::EInt(42))
    );
    let expr = Expr::ELet(
        "id".to_string(),
        Box::new(identity),
        Box::new(body)
    );

    let result = infer(env, expr);

    match result {
        InferResult::Success(t) => {
            println("  ‚úÖ PASS");
            true
        },
        InferResult::Failure(msg) => {
            println("  ‚ùå FAIL: {}", msg);
            false
        }
    }
}

fun main() {
    println("üü¢ BOOTSTRAP-013: Type Checker Self-Typing (GREEN Phase)");
    println("========================================================");
    println("");

    let mut passed = 0;
    let mut failed = 0;

    if test_self_typing_simple() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_self_typing_lambda() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_soundness_property() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_soundness_rejection() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_self_typing_complex() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    println("");
    println("üìä Results: {} passed, {} failed", passed, failed);

    if failed == 0 {
        println("‚úÖ GREEN: All 5/5 tests passing!");
        println("Type checker successfully types its own code!");
        println("Soundness property validated!");
    }
}

main();
