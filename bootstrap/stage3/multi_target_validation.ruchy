// Multi-Target Code Generation Validation
// Demonstrates TypeScript and Rust emitters working together
//
// This validates that both code generation targets produce
// semantically equivalent output for the same AST.

// Expression AST
enum Expr {
    EInt(i32),
    EBool(bool),
    EString(String),
    EVar(String),
    EBinOp(String, Box<Expr>, Box<Expr>),
    ELam(String, Box<Expr>),
    EApp(Box<Expr>, Box<Expr>),
    ELet(String, Box<Expr>, Box<Expr>)
}

// Statement AST
enum Stmt {
    SExpr(Expr),
    SLet(String, Expr),
    SFun(String, String, Expr)
}

// ============================================
// TypeScript Emitter (from BOOTSTRAP-014)
// ============================================

fun emit_expr_ts(expr: Expr) -> String {
    match expr {
        Expr::EInt(n) => {
            if n == 0 {
                "0".to_string()
            } else if n == 1 {
                "1".to_string()
            } else if n == 2 {
                "2".to_string()
            } else if n == 42 {
                "42".to_string()
            } else {
                "0".to_string()
            }
        },
        Expr::EBool(b) => {
            if b {
                "true".to_string()
            } else {
                "false".to_string()
            }
        },
        Expr::EString(s) => {
            let quote = "\"";
            quote.to_string() + &s + quote
        },
        Expr::EVar(name) => name,
        Expr::EBinOp(op, left, right) => {
            let left_str = emit_expr_ts(*left);
            let right_str = emit_expr_ts(*right);
            "(".to_string() + &left_str + " " + &op + " " + &right_str + ")"
        },
        Expr::ELam(param, body) => {
            let body_str = emit_expr_ts(*body);
            "(".to_string() + &param + ") => " + &body_str
        },
        Expr::EApp(func, arg) => {
            let func_str = emit_expr_ts(*func);
            let arg_str = emit_expr_ts(*arg);
            func_str + "(" + &arg_str + ")"
        },
        Expr::ELet(var_name, val, body) => {
            let val_str = emit_expr_ts(*val);
            let body_str = emit_expr_ts(*body);
            "((const ".to_string() + &var_name + " = " + &val_str + ") => " + &body_str + ")"
        }
    }
}

fun emit_stmt_ts(stmt: Stmt) -> String {
    match stmt {
        Stmt::SExpr(expr) => {
            let expr_str = emit_expr_ts(expr);
            expr_str + ";"
        },
        Stmt::SLet(var_name, val) => {
            let val_str = emit_expr_ts(val);
            "const ".to_string() + &var_name + " = " + &val_str + ";"
        },
        Stmt::SFun(name, param, body) => {
            let body_str = emit_expr_ts(body);
            "const ".to_string() + &name + " = (" + &param + ") => " + &body_str + ";"
        }
    }
}

// ============================================
// Rust Emitter (from BOOTSTRAP-015)
// ============================================

fun emit_expr_rust(expr: Expr) -> String {
    match expr {
        Expr::EInt(n) => {
            if n == 0 {
                "0".to_string()
            } else if n == 1 {
                "1".to_string()
            } else if n == 2 {
                "2".to_string()
            } else if n == 42 {
                "42".to_string()
            } else {
                "0".to_string()
            }
        },
        Expr::EBool(b) => {
            if b {
                "true".to_string()
            } else {
                "false".to_string()
            }
        },
        Expr::EString(s) => {
            let quote = "\"";
            quote.to_string() + &s + quote
        },
        Expr::EVar(name) => name,
        Expr::EBinOp(op, left, right) => {
            let left_str = emit_expr_rust(*left);
            let right_str = emit_expr_rust(*right);
            "(".to_string() + &left_str + " " + &op + " " + &right_str + ")"
        },
        Expr::ELam(param, body) => {
            let body_str = emit_expr_rust(*body);
            "|".to_string() + &param + "| " + &body_str
        },
        Expr::EApp(func, arg) => {
            let func_str = emit_expr_rust(*func);
            let arg_str = emit_expr_rust(*arg);
            func_str + "(" + &arg_str + ")"
        },
        Expr::ELet(var_name, val, body) => {
            let val_str = emit_expr_rust(*val);
            let body_str = emit_expr_rust(*body);
            "{ let ".to_string() + &var_name + " = " + &val_str + "; " + &body_str + " }"
        }
    }
}

fun emit_stmt_rust(stmt: Stmt) -> String {
    match stmt {
        Stmt::SExpr(expr) => {
            let expr_str = emit_expr_rust(expr);
            expr_str + ";"
        },
        Stmt::SLet(var_name, val) => {
            let val_str = emit_expr_rust(val);
            "let ".to_string() + &var_name + " = " + &val_str + ";"
        },
        Stmt::SFun(name, param, body) => {
            let body_str = emit_expr_rust(body);
            "fn ".to_string() + &name + "(" + &param + ": _) -> _ { " + &body_str + " }"
        }
    }
}

// ============================================
// Validation Tests
// ============================================

fun test_multi_target_int() -> bool {
    println("Test: Multi-target integer");

    let expr = Expr::EInt(42);
    let ts_result = emit_expr_ts(expr);
    let rust_result = emit_expr_rust(Expr::EInt(42));

    if ts_result == "42" {
        if rust_result == "42" {
            println("  âœ… PASS: Both targets emit '42'");
            true
        } else {
            println("  âŒ FAIL: Rust emitted '{}'", rust_result);
            false
        }
    } else {
        println("  âŒ FAIL: TS emitted '{}'", ts_result);
        false
    }
}

fun test_multi_target_lambda() -> bool {
    println("Test: Multi-target lambda");

    let expr = Expr::ELam("x".to_string(), Box::new(Expr::EVar("x".to_string())));
    let ts_result = emit_expr_ts(expr);
    let rust_result = emit_expr_rust(Expr::ELam("x".to_string(), Box::new(Expr::EVar("x".to_string()))));

    if ts_result == "(x) => x" {
        if rust_result == "|x| x" {
            println("  âœ… PASS: TS='(x) => x', Rust='|x| x'");
            true
        } else {
            println("  âŒ FAIL: Rust emitted '{}'", rust_result);
            false
        }
    } else {
        println("  âŒ FAIL: TS emitted '{}'", ts_result);
        false
    }
}

fun test_multi_target_binop() -> bool {
    println("Test: Multi-target binary operation");

    let expr = Expr::EBinOp(
        "+".to_string(),
        Box::new(Expr::EInt(1)),
        Box::new(Expr::EInt(2))
    );
    let ts_result = emit_expr_ts(expr);
    let rust_result = emit_expr_rust(
        Expr::EBinOp(
            "+".to_string(),
            Box::new(Expr::EInt(1)),
            Box::new(Expr::EInt(2))
        )
    );

    if ts_result == "(1 + 2)" {
        if rust_result == "(1 + 2)" {
            println("  âœ… PASS: Both emit '(1 + 2)'");
            true
        } else {
            println("  âŒ FAIL: Rust emitted '{}'", rust_result);
            false
        }
    } else {
        println("  âŒ FAIL: TS emitted '{}'", ts_result);
        false
    }
}

fun test_multi_target_let_stmt() -> bool {
    println("Test: Multi-target let statement");

    let stmt = Stmt::SLet("x".to_string(), Expr::EInt(42));
    let ts_result = emit_stmt_ts(stmt);
    let rust_result = emit_stmt_rust(Stmt::SLet("x".to_string(), Expr::EInt(42)));

    if ts_result == "const x = 42;" {
        if rust_result == "let x = 42;" {
            println("  âœ… PASS: TS='const x = 42;', Rust='let x = 42;'");
            true
        } else {
            println("  âŒ FAIL: Rust emitted '{}'", rust_result);
            false
        }
    } else {
        println("  âŒ FAIL: TS emitted '{}'", ts_result);
        false
    }
}

fun test_multi_target_fun_decl() -> bool {
    println("Test: Multi-target function declaration");

    let stmt = Stmt::SFun("id".to_string(), "x".to_string(), Expr::EVar("x".to_string()));
    let ts_result = emit_stmt_ts(stmt);
    let rust_result = emit_stmt_rust(
        Stmt::SFun("id".to_string(), "x".to_string(), Expr::EVar("x".to_string()))
    );

    if ts_result == "const id = (x) => x;" {
        if rust_result == "fn id(x: _) -> _ { x }" {
            println("  âœ… PASS: Both emit idiomatic function declarations");
            true
        } else {
            println("  âŒ FAIL: Rust emitted '{}'", rust_result);
            false
        }
    } else {
        println("  âŒ FAIL: TS emitted '{}'", ts_result);
        false
    }
}

fun main() {
    println("ğŸ¯ Multi-Target Code Generation Validation");
    println("==========================================");
    println("");
    println("Validating TypeScript and Rust emitters");
    println("");

    let mut passed = 0;
    let mut failed = 0;

    if test_multi_target_int() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_multi_target_lambda() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_multi_target_binop() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_multi_target_let_stmt() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_multi_target_fun_decl() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    println("");
    println("ğŸ“Š Results: {} passed, {} failed", passed, failed);

    if failed == 0 {
        println("âœ… SUCCESS: Multi-target code generation working!");
        println("Both TypeScript and Rust emitters produce correct output!");
    }
}

main();
