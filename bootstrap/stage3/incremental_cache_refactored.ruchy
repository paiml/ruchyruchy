// WASM-006: Incremental Compilation - Module Cache (Refactored)
//
// Refactored version with LRU eviction, size limits, and optimized performance
// Improvements over GREEN phase:
// - LRU cache eviction for bounded memory
// - Configurable size limits
// - Optimized cache lookups
// - Better error handling

use std::fs;
use std::path::{Path, PathBuf};
use std::collections::HashMap;
use content_hasher::{ContentHasher, sha256};
use lru_cache::LRUCache;

// ============================================================================
// Cache Configuration
// ============================================================================

#[derive(Debug, Clone)]
pub struct CacheConfig {
    pub max_size_mb: u32,
    pub max_entries: usize,
    pub eviction_policy: EvictionPolicy,
}

impl CacheConfig {
    pub fun default() -> Self {
        CacheConfig {
            max_size_mb: 1024,  // 1GB default
            max_entries: 10000,
            eviction_policy: EvictionPolicy::LRU,
        }
    }

    pub fun with_size(max_size_mb: u32) -> Self {
        CacheConfig {
            max_size_mb,
            ..Self::default()
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum EvictionPolicy {
    LRU,   // Least Recently Used
    LFU,   // Least Frequently Used (future)
    FIFO,  // First In First Out (future)
}

// ============================================================================
// Cache Entry Types
// ============================================================================

/// Metadata for a cached module
#[derive(Debug, Clone)]
pub struct ModuleMetadata {
    pub exports: Vec<String>,
    pub imports: Vec<String>,
    pub source_path: String,
    pub source_hash: String,
    pub dependency_hashes: Vec<String>,
}

impl ModuleMetadata {
    pub fun new(
        exports: Vec<String>,
        imports: Vec<String>,
        source_path: String,
        source_hash: String,
        dependency_hashes: Vec<String>,
    ) -> Self {
        ModuleMetadata {
            exports,
            imports,
            source_path,
            source_hash,
            dependency_hashes,
        }
    }

    /// Serialize to JSON string
    pub fun to_json(&self) -> String {
        format!(
            r#"{{"exports":{},"imports":{},"source_path":"{}","source_hash":"{}","dependency_hashes":{}}}"#,
            vec_to_json(&self.exports),
            vec_to_json(&self.imports),
            self.source_path,
            self.source_hash,
            vec_to_json(&self.dependency_hashes)
        )
    }
}

/// A cache entry containing compiled module and metadata
#[derive(Debug, Clone)]
pub struct CacheEntry {
    pub source_hash: String,
    pub dependency_hashes: Vec<String>,
    pub compiled_path: PathBuf,
    pub metadata: ModuleMetadata,
    pub timestamp: u64,
    pub size_bytes: u64,  // Size of cached data
}

impl CacheEntry {
    pub fun new(
        source_hash: String,
        dependency_hashes: Vec<String>,
        compiled_path: PathBuf,
        metadata: ModuleMetadata,
        size_bytes: u64,
    ) -> Self {
        CacheEntry {
            source_hash,
            dependency_hashes,
            compiled_path,
            metadata,
            timestamp: current_timestamp(),
            size_bytes,
        }
    }

    /// Check if cache entry is valid for given hashes
    pub fun is_valid(&self, source_hash: &str, dep_hashes: &Vec<String>) -> bool {
        // Check source hash matches
        if self.source_hash != source_hash {
            return false;
        }

        // Check all dependency hashes match
        if self.dependency_hashes.len() != dep_hashes.len() {
            return false;
        }

        for (i, dep_hash) in dep_hashes.iter().enumerate() {
            if self.dependency_hashes[i] != *dep_hash {
                return false;
            }
        }

        // Check compiled file still exists
        if !self.compiled_path.exists() {
            return false;
        }

        true
    }
}

/// A cached module ready to use
#[derive(Debug, Clone)]
pub struct CachedModule {
    pub wasm_binary: Vec<u8>,
    pub metadata: ModuleMetadata,
}

impl CachedModule {
    pub fun new(wasm_binary: Vec<u8>, metadata: ModuleMetadata) -> Self {
        CachedModule {
            wasm_binary,
            metadata,
        }
    }
}

/// A compiled module to be cached
#[derive(Debug, Clone)]
pub struct CompiledModule {
    pub wasm_binary: Vec<u8>,
    pub metadata: ModuleMetadata,
}

impl CompiledModule {
    pub fun new(wasm_binary: Vec<u8>, metadata: ModuleMetadata) -> Self {
        CompiledModule {
            wasm_binary,
            metadata,
        }
    }
}

// ============================================================================
// Module Cache with LRU Eviction
// ============================================================================

pub struct ModuleCache {
    cache_dir: PathBuf,
    lru_index: LRUCache<String, CacheEntry>,
    hasher: ContentHasher,
    config: CacheConfig,
    current_size_bytes: u64,
    stats: CacheStatistics,
}

impl ModuleCache {
    /// Create new cache with default configuration
    pub fun new(cache_dir: PathBuf) -> Result<Self, String> {
        Self::new_with_config(cache_dir, CacheConfig::default())
    }

    /// Create new cache with specified configuration
    pub fun new_with_config(cache_dir: PathBuf, config: CacheConfig) -> Result<Self, String> {
        // Create cache directory if it doesn't exist
        fs::create_dir_all(&cache_dir)
            .map_err(|e| format!("Failed to create cache directory: {}", e))?;

        let lru_index = LRUCache::new(config.max_entries);

        let mut cache = ModuleCache {
            cache_dir,
            lru_index,
            hasher: ContentHasher::new(),
            config,
            current_size_bytes: 0,
            stats: CacheStatistics::new(),
        };

        // Load existing cache entries
        cache.load_cache_entries()?;

        Ok(cache)
    }

    /// Get cached module if available and valid
    pub fun get(&mut self, source_path: &str) -> Result<Option<CachedModule>, String> {
        self.stats.total_lookups += 1;

        // Hash the source file
        let source_hash = self.hasher.hash_file(source_path)?;

        // Compute dependency hashes (empty for now)
        let dep_hashes = vec![];

        // Look up in LRU cache (automatically updates LRU order)
        if let Some(entry) = self.lru_index.get(source_path) {
            // Check if entry is still valid
            if entry.is_valid(&source_hash, &dep_hashes) {
                // Load compiled module from disk
                let wasm_binary = fs::read(&entry.compiled_path)
                    .map_err(|e| format!("Failed to read cached module: {}", e))?;

                self.stats.cache_hits += 1;
                return Ok(Some(CachedModule::new(wasm_binary, entry.metadata.clone())));
            } else {
                // Cache entry is stale, remove it
                self.invalidate(source_path)?;
                self.stats.cache_misses += 1;
            }
        } else {
            self.stats.cache_misses += 1;
        }

        Ok(None)
    }

    /// Store compiled module in cache
    pub fun put(&mut self, source_path: &str, module: CompiledModule) -> Result<(), String> {
        // Hash the source file
        let source_hash = self.hasher.hash_file(source_path)?;

        // Compute cache key
        let cache_key = self.hasher.compute_cache_key(
            source_hash.clone(),
            module.metadata.dependency_hashes.clone()
        );

        // Paths for cache files
        let wasm_path = self.cache_dir.join(format!("{}.wasm", cache_key));
        let meta_path = self.cache_dir.join(format!("{}.meta.json", cache_key));

        // Calculate size
        let module_size = module.wasm_binary.len() as u64;
        let metadata_size = module.metadata.to_json().len() as u64;
        let total_size = module_size + metadata_size;

        // Evict entries if necessary to make room
        self.evict_if_needed(total_size)?;

        // Write WASM binary
        fs::write(&wasm_path, &module.wasm_binary)
            .map_err(|e| format!("Failed to write cached WASM: {}", e))?;

        // Write metadata
        fs::write(&meta_path, module.metadata.to_json())
            .map_err(|e| format!("Failed to write metadata: {}", e))?;

        // Create cache entry
        let entry = CacheEntry::new(
            source_hash,
            module.metadata.dependency_hashes.clone(),
            wasm_path,
            module.metadata,
            total_size,
        );

        // Add to LRU cache (automatically evicts if over capacity)
        self.lru_index.put(source_path.to_string(), entry);
        self.current_size_bytes += total_size;
        self.stats.total_entries_stored += 1;

        Ok(())
    }

    /// Invalidate cache entry for a source file
    pub fun invalidate(&mut self, source_path: &str) -> Result<(), String> {
        if let Some(entry) = self.lru_index.remove(source_path) {
            // Delete cache files
            let _ = fs::remove_file(&entry.compiled_path);

            // Delete metadata file
            let meta_path = entry.compiled_path.with_extension("meta.json");
            let _ = fs::remove_file(&meta_path);

            // Update size tracking
            self.current_size_bytes -= entry.size_bytes;
            self.stats.total_evictions += 1;
        }

        Ok(())
    }

    /// Clear entire cache
    pub fun clear(&mut self) -> Result<(), String> {
        // Remove all cache files
        for (_, entry) in self.lru_index.iter() {
            let _ = fs::remove_file(&entry.compiled_path);

            let meta_path = entry.compiled_path.with_extension("meta.json");
            let _ = fs::remove_file(&meta_path);
        }

        // Clear LRU cache
        self.lru_index.clear();
        self.current_size_bytes = 0;

        Ok(())
    }

    /// Get cache statistics
    pub fun stats(&self) -> CacheStats {
        CacheStats {
            total_entries: self.lru_index.len(),
            total_size_bytes: self.current_size_bytes,
            cache_hits: self.stats.cache_hits,
            cache_misses: self.stats.cache_misses,
            total_evictions: self.stats.total_evictions,
        }
    }

    // ========================================================================
    // Internal Helper Methods
    // ========================================================================

    /// Evict entries if needed to make room for new entry
    fun evict_if_needed(&mut self, needed_size: u64) -> Result<(), String> {
        let max_size = (self.config.max_size_mb as u64) * 1024 * 1024;

        while self.current_size_bytes + needed_size > max_size && !self.lru_index.is_empty() {
            // Evict LRU entry
            if let Some((path, entry)) = self.lru_index.evict_lru() {
                // Delete cache files
                let _ = fs::remove_file(&entry.compiled_path);

                let meta_path = entry.compiled_path.with_extension("meta.json");
                let _ = fs::remove_file(&meta_path);

                // Update size tracking
                self.current_size_bytes -= entry.size_bytes;
                self.stats.total_evictions += 1;
            } else {
                break;
            }
        }

        Ok(())
    }

    /// Load existing cache entries from disk
    fun load_cache_entries(&mut self) -> Result<(), String> {
        // Scan cache directory for .wasm files
        let entries = fs::read_dir(&self.cache_dir)
            .map_err(|e| format!("Failed to read cache directory: {}", e))?;

        for entry in entries {
            let entry = entry.map_err(|e| format!("Failed to read entry: {}", e))?;
            let path = entry.path();

            if path.extension() == Some("wasm".as_ref()) {
                // Try to load this cache entry
                if let Ok(cache_entry) = self.load_cache_entry(&path) {
                    let source_path = cache_entry.metadata.source_path.clone();
                    self.current_size_bytes += cache_entry.size_bytes;
                    self.lru_index.put(source_path, cache_entry);
                }
            }
        }

        Ok(())
    }

    /// Load a single cache entry from disk
    fun load_cache_entry(&self, wasm_path: &Path) -> Result<CacheEntry, String> {
        let meta_path = wasm_path.with_extension("meta.json");

        // Read metadata
        let metadata_json = fs::read_to_string(&meta_path)
            .map_err(|e| format!("Failed to read metadata: {}", e))?;

        // Parse metadata (simplified)
        let metadata = parse_metadata_json(&metadata_json)?;

        // Get file size
        let wasm_size = fs::metadata(wasm_path)
            .map(|m| m.len())
            .unwrap_or(0);

        let meta_size = fs::metadata(&meta_path)
            .map(|m| m.len())
            .unwrap_or(0);

        Ok(CacheEntry::new(
            metadata.source_hash.clone(),
            metadata.dependency_hashes.clone(),
            wasm_path.to_path_buf(),
            metadata,
            wasm_size + meta_size,
        ))
    }
}

// ============================================================================
// Cache Statistics
// ============================================================================

#[derive(Debug, Clone, Copy)]
struct CacheStatistics {
    total_lookups: u64,
    cache_hits: u64,
    cache_misses: u64,
    total_entries_stored: u64,
    total_evictions: u64,
}

impl CacheStatistics {
    fun new() -> Self {
        CacheStatistics {
            total_lookups: 0,
            cache_hits: 0,
            cache_misses: 0,
            total_entries_stored: 0,
            total_evictions: 0,
        }
    }
}

pub struct CacheStats {
    pub total_entries: usize,
    pub total_size_bytes: u64,
    pub cache_hits: u64,
    pub cache_misses: u64,
    pub total_evictions: u64,
}

impl CacheStats {
    pub fun total_size_mb(&self) -> f64 {
        self.total_size_bytes as f64 / (1024.0 * 1024.0)
    }

    pub fun hit_rate(&self) -> f64 {
        let total = self.cache_hits + self.cache_misses;
        if total == 0 {
            return 0.0;
        }
        self.cache_hits as f64 / total as f64
    }
}

// ============================================================================
// Utility Functions
// ============================================================================

/// Get current Unix timestamp
fun current_timestamp() -> u64 {
    std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap()
        .as_secs()
}

/// Convert Vec<String> to JSON array
fun vec_to_json(vec: &Vec<String>) -> String {
    let items: Vec<String> = vec.iter()
        .map(|s| format!("\"{}\"", s))
        .collect();
    format!("[{}]", items.join(","))
}

/// Parse metadata from JSON (simplified)
fun parse_metadata_json(json: &str) -> Result<ModuleMetadata, String> {
    // In production, use proper JSON parser
    Ok(ModuleMetadata::new(
        vec![],
        vec![],
        String::new(),
        String::new(),
        vec![],
    ))
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    test test_cache_with_size_limit() {
        let cache_dir = PathBuf::from("/tmp/ruchy-cache-size-test");
        let config = CacheConfig::with_size(1);  // 1MB limit

        let mut cache = ModuleCache::new_with_config(cache_dir.clone(), config).unwrap();

        // Add entries until eviction occurs
        // (Test would need actual file operations)

        // Cleanup
        let _ = fs::remove_dir_all(&cache_dir);
    }

    test test_lru_eviction_policy() {
        let cache_dir = PathBuf::from("/tmp/ruchy-cache-lru-test");
        let config = CacheConfig {
            max_size_mb: 100,
            max_entries: 2,  // Only 2 entries
            eviction_policy: EvictionPolicy::LRU,
        };

        let mut cache = ModuleCache::new_with_config(cache_dir.clone(), config).unwrap();

        // Test would verify LRU eviction order

        // Cleanup
        let _ = fs::remove_dir_all(&cache_dir);
    }

    test test_cache_stats() {
        let cache_dir = PathBuf::from("/tmp/ruchy-cache-stats-test");
        let mut cache = ModuleCache::new(cache_dir.clone()).unwrap();

        let stats = cache.stats();

        assert(stats.total_entries == 0, "Should start with 0 entries");
        assert(stats.cache_hits == 0, "Should have 0 hits initially");

        // Cleanup
        let _ = fs::remove_dir_all(&cache_dir);
    }
}
