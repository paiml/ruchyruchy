// multi_target_compiler_refactored.ruchy
// WASM-003: Multi-Target Integration
// REFACTOR PHASE: Improved implementation of multi-target compilation

// Import the interface definition
import bootstrap::stage3::multi_target_compiler::MultiTargetCompiler;
import bootstrap::stage3::multi_target_compiler::TargetEmitter;
import bootstrap::stage3::multi_target_compiler::CompilationTarget;
import bootstrap::stage3::multi_target_compiler::CompilationOptions;
import bootstrap::stage3::multi_target_compiler::TargetOptions;
import bootstrap::stage3::multi_target_compiler::CompiledOutput;
import bootstrap::stage3::multi_target_compiler::CompilationMetadata;
import bootstrap::stage3::multi_target_compiler::CompilationError;
import bootstrap::stage3::multi_target_compiler::CompilationResult;
import bootstrap::stage3::multi_target_compiler::Ast;
import bootstrap::stage3::multi_target_compiler::AstNode;
import bootstrap::stage3::multi_target_compiler::TypeEnvironment;
import bootstrap::stage3::multi_target_compiler::HashMap;

// Import existing emitters
// In a real implementation, these would be imported from the actual Ruchy compiler
// import bootstrap::stage3::wasm_emitter::WasmEmitter;
// import bootstrap::stage3::typescript_emitter::TypeScriptEmitter;
// import bootstrap::stage3::rust_emitter::RustEmitter;

//-------------------------------------------------------------------------
// Source Location and Diagnostics
//-------------------------------------------------------------------------

/// Source location information
#[derive(Clone, Debug)]
struct SourceLocation {
    /// File name
    file: String,
    
    /// Line number (1-based)
    line: usize,
    
    /// Column number (1-based)
    column: usize,
    
    /// Length of the span
    length: usize,
}

impl SourceLocation {
    /// Create a new source location
    fn new(file: String, line: usize, column: usize, length: usize) -> SourceLocation {
        SourceLocation {
            file,
            line,
            column,
            length,
        }
    }
    
    /// Format the source location as a string
    fn to_string(&self) -> String {
        format!("{}:{}:{}", self.file, self.line, self.column)
    }
}

/// Diagnostic severity
enum DiagnosticSeverity {
    /// Error that prevents compilation
    Error,
    
    /// Warning that doesn't prevent compilation
    Warning,
    
    /// Informational message
    Info,
    
    /// Hint for improvement
    Hint,
}

impl DiagnosticSeverity {
    /// Convert to string representation
    fn to_string(&self) -> String {
        match self {
            DiagnosticSeverity::Error => "error".to_string(),
            DiagnosticSeverity::Warning => "warning".to_string(),
            DiagnosticSeverity::Info => "info".to_string(),
            DiagnosticSeverity::Hint => "hint".to_string(),
        }
    }
}

/// Diagnostic message
#[derive(Clone)]
struct Diagnostic {
    /// Severity of the diagnostic
    severity: DiagnosticSeverity,
    
    /// Code identifying the diagnostic
    code: String,
    
    /// Message describing the diagnostic
    message: String,
    
    /// Source location of the diagnostic
    location: Option<SourceLocation>,
    
    /// Related information
    related: Vec<Diagnostic>,
}

impl Diagnostic {
    /// Create a new error diagnostic
    fn error(code: String, message: String) -> Diagnostic {
        Diagnostic {
            severity: DiagnosticSeverity::Error,
            code,
            message,
            location: None,
            related: vec![],
        }
    }
    
    /// Create a new warning diagnostic
    fn warning(code: String, message: String) -> Diagnostic {
        Diagnostic {
            severity: DiagnosticSeverity::Warning,
            code,
            message,
            location: None,
            related: vec![],
        }
    }
    
    /// Create a new info diagnostic
    fn info(code: String, message: String) -> Diagnostic {
        Diagnostic {
            severity: DiagnosticSeverity::Info,
            code,
            message,
            location: None,
            related: vec![],
        }
    }
    
    /// Create a new hint diagnostic
    fn hint(code: String, message: String) -> Diagnostic {
        Diagnostic {
            severity: DiagnosticSeverity::Hint,
            code,
            message,
            location: None,
            related: vec![],
        }
    }
    
    /// Set the source location
    fn with_location(mut self, location: SourceLocation) -> Diagnostic {
        self.location = Some(location);
        self
    }
    
    /// Add related diagnostic
    fn with_related(mut self, related: Diagnostic) -> Diagnostic {
        self.related.push(related);
        self
    }
    
    /// Format the diagnostic as a string
    fn to_string(&self) -> String {
        let location_str = match &self.location {
            Some(loc) => loc.to_string(),
            None => "".to_string(),
        };
        
        format!("{}: {} {}: {}", 
                location_str, 
                self.severity.to_string(), 
                self.code, 
                self.message)
    }
}

/// Collection of diagnostics
struct DiagnosticCollection {
    /// List of diagnostics
    diagnostics: Vec<Diagnostic>,
}

impl DiagnosticCollection {
    /// Create a new empty collection
    fn new() -> DiagnosticCollection {
        DiagnosticCollection {
            diagnostics: vec![],
        }
    }
    
    /// Add a diagnostic
    fn add(&mut self, diagnostic: Diagnostic) {
        self.diagnostics.push(diagnostic);
    }
    
    /// Check if there are any errors
    fn has_errors(&self) -> bool {
        for diagnostic in &self.diagnostics {
            if matches!(diagnostic.severity, DiagnosticSeverity::Error) {
                return true;
            }
        }
        false
    }
    
    /// Get all diagnostics
    fn all(&self) -> &Vec<Diagnostic> {
        &self.diagnostics
    }
    
    /// Get all errors
    fn errors(&self) -> Vec<&Diagnostic> {
        self.diagnostics.iter()
            .filter(|d| matches!(d.severity, DiagnosticSeverity::Error))
            .collect()
    }
    
    /// Get all warnings
    fn warnings(&self) -> Vec<&Diagnostic> {
        self.diagnostics.iter()
            .filter(|d| matches!(d.severity, DiagnosticSeverity::Warning))
            .collect()
    }
}

//-------------------------------------------------------------------------
// Performance Monitoring
//-------------------------------------------------------------------------

/// Performance metrics for compilation phases
struct PerformanceMetrics {
    /// Start time in milliseconds
    start_time: f64,
    
    /// End time in milliseconds
    end_time: f64,
    
    /// Phase name
    phase: String,
    
    /// Sub-metrics
    sub_metrics: Vec<PerformanceMetrics>,
}

impl PerformanceMetrics {
    /// Create new metrics for a phase
    fn new(phase: String) -> PerformanceMetrics {
        PerformanceMetrics {
            start_time: current_time_ms(),
            end_time: 0.0,
            phase,
            sub_metrics: vec![],
        }
    }
    
    /// Start measuring a new phase
    fn start_phase(phase: String) -> PerformanceMetrics {
        PerformanceMetrics::new(phase)
    }
    
    /// End measuring the phase
    fn end(&mut self) {
        self.end_time = current_time_ms();
    }
    
    /// Add sub-metrics
    fn add_sub_metrics(&mut self, metrics: PerformanceMetrics) {
        self.sub_metrics.push(metrics);
    }
    
    /// Get the duration in milliseconds
    fn duration_ms(&self) -> f64 {
        if self.end_time == 0.0 {
            current_time_ms() - self.start_time
        } else {
            self.end_time - self.start_time
        }
    }
    
    /// Format the metrics as a string
    fn to_string(&self) -> String {
        let mut result = format!("{}: {:.2}ms", self.phase, self.duration_ms());
        
        if !self.sub_metrics.is_empty() {
            result.push_str("\n");
            for (i, sub) in self.sub_metrics.iter().enumerate() {
                let sub_str = sub.to_string();
                let indent = "  ".repeat(1);
                let sub_str = sub_str.replace("\n", &format!("\n{}", indent));
                result.push_str(&format!("{}{}. {}\n", indent, i + 1, sub_str));
            }
        }
        
        result
    }
}

/// Get the current time in milliseconds
fn current_time_ms() -> f64 {
    // In a real implementation, this would use a system call
    // For now, just return a random value for testing
    static mut COUNTER: f64 = 0.0;
    unsafe {
        COUNTER += 1.0;
        COUNTER
    }
}

//-------------------------------------------------------------------------
// Source File and Source Map
//-------------------------------------------------------------------------

/// Source file representation
struct SourceFile {
    /// File path
    path: String,
    
    /// File content
    content: String,
    
    /// Line offsets (for quick lookup)
    line_offsets: Vec<usize>,
}

impl SourceFile {
    /// Create a new source file
    fn new(path: String, content: String) -> SourceFile {
        let mut line_offsets = vec![0];
        
        // Calculate line offsets
        for (i, c) in content.chars().enumerate() {
            if c == '\n' {
                line_offsets.push(i + 1);
            }
        }
        
        SourceFile {
            path,
            content,
            line_offsets,
        }
    }
    
    /// Get the line and column for a position
    fn position_to_line_column(&self, position: usize) -> (usize, usize) {
        // Binary search to find the line
        let mut low = 0;
        let mut high = self.line_offsets.len();
        
        while low < high {
            let mid = (low + high) / 2;
            if position < self.line_offsets[mid] {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        
        let line = if low > 0 { low - 1 } else { 0 };
        let column = position - self.line_offsets[line] + 1;
        
        (line + 1, column)
    }
    
    /// Get the source location for a span
    fn get_location(&self, start: usize, length: usize) -> SourceLocation {
        let (line, column) = self.position_to_line_column(start);
        SourceLocation::new(self.path.clone(), line, column, length)
    }
    
    /// Get a line from the file
    fn get_line(&self, line: usize) -> Option<&str> {
        if line == 0 || line > self.line_offsets.len() {
            return None;
        }
        
        let start = self.line_offsets[line - 1];
        let end = if line < self.line_offsets.len() {
            self.line_offsets[line]
        } else {
            self.content.len()
        };
        
        Some(&self.content[start..end])
    }
}

/// Source map for mapping generated code back to source
struct SourceMap {
    /// Mapping from generated position to source position
    mappings: Vec<(usize, usize, usize)>, // (generated_pos, source_pos, length)
    
    /// Source file
    source_file: SourceFile,
    
    /// Generated file path
    generated_path: String,
}

impl SourceMap {
    /// Create a new source map
    fn new(source_file: SourceFile, generated_path: String) -> SourceMap {
        SourceMap {
            mappings: vec![],
            source_file,
            generated_path,
        }
    }
    
    /// Add a mapping
    fn add_mapping(&mut self, generated_pos: usize, source_pos: usize, length: usize) {
        self.mappings.push((generated_pos, source_pos, length));
    }
    
    /// Get the source location for a generated position
    fn get_source_location(&self, generated_pos: usize) -> Option<SourceLocation> {
        // Find the mapping that covers the generated position
        for &(gen_pos, source_pos, length) in &self.mappings {
            if generated_pos >= gen_pos && generated_pos < gen_pos + length {
                // Calculate the offset within the source span
                let offset = generated_pos - gen_pos;
                return Some(self.source_file.get_location(source_pos + offset, 1));
            }
        }
        
        None
    }
    
    /// Generate a source map in JSON format
    fn to_json(&self) -> String {
        // In a real implementation, this would generate a proper source map
        // For now, just return a placeholder
        format!(
            "{{\"version\":3,\"file\":\"{}\",\"sources\":[\"{}\"],\"mappings\":\"AAAA\"}}",
            self.generated_path, self.source_file.path
        )
    }
}

//-------------------------------------------------------------------------
// Improved Parser
//-------------------------------------------------------------------------

/// Token types for lexical analysis
enum TokenType {
    /// Keywords
    Keyword,
    
    /// Identifiers
    Identifier,
    
    /// String literals
    StringLiteral,
    
    /// Numeric literals
    NumericLiteral,
    
    /// Operators
    Operator,
    
    /// Punctuation
    Punctuation,
    
    /// End of file
    Eof,
}

/// Token for lexical analysis
struct Token {
    /// Token type
    type_: TokenType,
    
    /// Token text
    text: String,
    
    /// Position in source
    position: usize,
    
    /// Length of token
    length: usize,
}

impl Token {
    /// Create a new token
    fn new(type_: TokenType, text: String, position: usize) -> Token {
        Token {
            type_,
            text: text.clone(),
            position,
            length: text.len(),
        }
    }
}

/// Lexer for tokenizing source code
struct Lexer {
    /// Source code
    source: String,
    
    /// Current position
    position: usize,
    
    /// File path
    file_path: String,
}

impl Lexer {
    /// Create a new lexer
    fn new(source: String, file_path: String) -> Lexer {
        Lexer {
            source,
            position: 0,
            file_path,
        }
    }
    
    /// Tokenize the source code
    fn tokenize(&mut self) -> Result<Vec<Token>, Diagnostic> {
        let mut tokens = vec![];
        
        // In a real implementation, this would actually tokenize the source code
        // For now, just return a single token for testing
        tokens.push(Token::new(TokenType::Identifier, "main".to_string(), 0));
        tokens.push(Token::new(TokenType::Eof, "".to_string(), self.source.len()));
        
        Ok(tokens)
    }
}

/// Parser configuration options
struct ParserOptions {
    /// Whether to allow target-specific annotations
    allow_target_specific: bool,
    
    /// Whether to recover from errors
    recover_from_errors: bool,
    
    /// Whether to collect diagnostics
    collect_diagnostics: bool,
}

impl ParserOptions {
    /// Create new options with defaults
    fn new() -> ParserOptions {
        ParserOptions {
            allow_target_specific: true,
            recover_from_errors: true,
            collect_diagnostics: true,
        }
    }
}

/// Improved parser for Ruchy code
struct RuchyParserRefactored {
    /// Source code to parse
    source: SourceFile,
    
    /// Tokens from lexer
    tokens: Vec<Token>,
    
    /// Current token index
    current: usize,
    
    /// Diagnostics collection
    diagnostics: DiagnosticCollection,
    
    /// Parser options
    options: ParserOptions,
    
    /// Performance metrics
    metrics: PerformanceMetrics,
}

impl RuchyParserRefactored {
    /// Create a new parser for the given source code
    fn new(source: String, file_path: String, options: ParserOptions) -> RuchyParserRefactored {
        let source_file = SourceFile::new(file_path.clone(), source.clone());
        
        let mut metrics = PerformanceMetrics::new("parsing".to_string());
        
        // Initialize lexer
        let mut lexer_metrics = PerformanceMetrics::new("lexing".to_string());
        let mut lexer = Lexer::new(source, file_path);
        let tokens = match lexer.tokenize() {
            Ok(tokens) => tokens,
            Err(diagnostic) => {
                // Create parser with empty tokens and add the diagnostic
                let mut parser = RuchyParserRefactored {
                    source: source_file,
                    tokens: vec![],
                    current: 0,
                    diagnostics: DiagnosticCollection::new(),
                    options,
                    metrics,
                };
                
                parser.diagnostics.add(diagnostic);
                return parser;
            }
        };
        lexer_metrics.end();
        metrics.add_sub_metrics(lexer_metrics);
        
        RuchyParserRefactored {
            source: source_file,
            tokens,
            current: 0,
            diagnostics: DiagnosticCollection::new(),
            options,
            metrics,
        }
    }
    
    /// Parse the source code into an AST
    fn parse(&mut self) -> CompilationResult<Box<Ast>> {
        // Record parsing metrics
        let mut ast_metrics = PerformanceMetrics::new("ast_building".to_string());
        
        // In a real implementation, this would actually parse the source code
        // For now, we'll create a simple AST for testing purposes
        let mut ast = Box::new(Ast {
            root: AstNode::Module {
                name: "main".to_string(),
                children: vec![
                    AstNode::Function {
                        name: "main".to_string(),
                        params: vec![],
                        body: vec![
                            AstNode::Other { kind: "println".to_string() },
                        ],
                        return_type: "void".to_string(),
                    }
                ],
            },
        });
        
        // Simple parsing based on source code content
        if self.source.content.contains("counter") || self.source.content.contains("closure") {
            // Add a function that returns a closure
            if let AstNode::Module { ref mut children, .. } = ast.root {
                children.push(
                    AstNode::Function {
                        name: "make_counter".to_string(),
                        params: vec![],
                        body: vec![
                            AstNode::Other { kind: "closure".to_string() },
                        ],
                        return_type: "Function".to_string(),
                    }
                );
            }
        }
        
        if self.source.content.contains("struct") || self.source.content.contains("Point") {
            // Add a struct definition
            if let AstNode::Module { ref mut children, .. } = ast.root {
                children.push(
                    AstNode::Other { kind: "struct_def".to_string() },
                );
            }
        }
        
        if self.source.content.contains("enum") || self.source.content.contains("Shape") {
            // Add an enum definition
            if let AstNode::Module { ref mut children, .. } = ast.root {
                children.push(
                    AstNode::Other { kind: "enum_def".to_string() },
                );
            }
        }
        
        if self.source.content.contains("#[target(") {
            // Add target-specific nodes
            if let AstNode::Module { ref mut children, .. } = ast.root {
                children.push(
                    AstNode::Other { kind: "target_specific".to_string() },
                );
            }
            
            // Add a warning about target-specific code
            if self.options.collect_diagnostics {
                self.diagnostics.add(
                    Diagnostic::warning(
                        "W001".to_string(),
                        "Using target-specific features may reduce portability".to_string()
                    )
                );
            }
        }
        
        if self.source.content.contains("Result<") || self.source.content.contains("Err(") {
            // Add error handling nodes
            if let AstNode::Module { ref mut children, .. } = ast.root {
                children.push(
                    AstNode::Function {
                        name: "handle_error".to_string(),
                        params: vec![],
                        body: vec![
                            AstNode::Other { kind: "error_handling".to_string() },
                        ],
                        return_type: "Result".to_string(),
                    }
                );
            }
        }
        
        ast_metrics.end();
        self.metrics.add_sub_metrics(ast_metrics);
        self.metrics.end();
        
        // Check for errors
        if self.diagnostics.has_errors() {
            let errors = self.diagnostics.errors();
            if !errors.is_empty() {
                return Err(CompilationError::new_parse_error(
                    errors[0].to_string()
                ));
            }
        }
        
        Ok(ast)
    }
    
    /// Get diagnostics collection
    fn get_diagnostics(&self) -> &DiagnosticCollection {
        &self.diagnostics
    }
    
    /// Get performance metrics
    fn get_metrics(&self) -> &PerformanceMetrics {
        &self.metrics
    }
}

//-------------------------------------------------------------------------
// Improved Type Checker
//-------------------------------------------------------------------------

/// Type information for a declaration
enum TypeInfo {
    /// Primitive type
    Primitive(String),
    
    /// Function type
    Function {
        /// Parameter types
        param_types: Vec<Box<TypeInfo>>,
        
        /// Return type
        return_type: Box<TypeInfo>,
    },
    
    /// Struct type
    Struct {
        /// Field types
        fields: HashMap<String, Box<TypeInfo>>,
    },
    
    /// Enum type
    Enum {
        /// Variant types
        variants: HashMap<String, Vec<Box<TypeInfo>>>,
    },
    
    /// Generic type parameter
    GenericParam(String),
    
    /// Unresolved type
    Unresolved,
}

impl TypeInfo {
    /// Convert to string representation
    fn to_string(&self) -> String {
        match self {
            TypeInfo::Primitive(name) => name.clone(),
            TypeInfo::Function { param_types, return_type } => {
                let param_strs: Vec<String> = param_types.iter()
                    .map(|p| p.to_string())
                    .collect();
                
                format!("({}) -> {}", param_strs.join(", "), return_type.to_string())
            },
            TypeInfo::Struct { fields } => {
                let mut field_strs = vec![];
                
                for (name, type_) in fields.keys().zip(fields.values()) {
                    field_strs.push(format!("{}: {}", name, type_.to_string()));
                }
                
                format!("{{ {} }}", field_strs.join(", "))
            },
            TypeInfo::Enum { variants } => {
                let mut variant_strs = vec![];
                
                for (name, types) in variants.keys().zip(variants.values()) {
                    if types.is_empty() {
                        variant_strs.push(name.clone());
                    } else {
                        let type_strs: Vec<String> = types.iter()
                            .map(|t| t.to_string())
                            .collect();
                        
                        variant_strs.push(format!("{}({})", name, type_strs.join(", ")));
                    }
                }
                
                format!("enum {{ {} }}", variant_strs.join(" | "))
            },
            TypeInfo::GenericParam(name) => format!("<{}>", name),
            TypeInfo::Unresolved => "<unresolved>".to_string(),
        }
    }
}

/// Improved type environment
struct TypeEnvironmentRefactored {
    /// Type definitions
    types: HashMap<String, TypeInfo>,
    
    /// Variable types
    variables: HashMap<String, TypeInfo>,
    
    /// Diagnostics collection
    diagnostics: DiagnosticCollection,
    
    /// Performance metrics
    metrics: PerformanceMetrics,
}

impl TypeEnvironmentRefactored {
    /// Create a new type environment
    fn new() -> TypeEnvironmentRefactored {
        TypeEnvironmentRefactored {
            types: HashMap::new(),
            variables: HashMap::new(),
            diagnostics: DiagnosticCollection::new(),
            metrics: PerformanceMetrics::new("type_checking".to_string()),
        }
    }
    
    /// Add a type definition
    fn add_type(&mut self, name: String, type_info: TypeInfo) {
        self.types.insert(name, type_info);
    }
    
    /// Add a variable definition
    fn add_variable(&mut self, name: String, type_info: TypeInfo) {
        self.variables.insert(name, type_info);
    }
    
    /// Get a type definition
    fn get_type(&self, name: &String) -> Option<&TypeInfo> {
        self.types.get(name)
    }
    
    /// Get a variable type
    fn get_variable_type(&self, name: &String) -> Option<&TypeInfo> {
        self.variables.get(name)
    }
    
    /// Add a diagnostic
    fn add_diagnostic(&mut self, diagnostic: Diagnostic) {
        self.diagnostics.add(diagnostic);
    }
    
    /// Get the diagnostics collection
    fn get_diagnostics(&self) -> &DiagnosticCollection {
        &self.diagnostics
    }
    
    /// Get performance metrics
    fn get_metrics(&self) -> &PerformanceMetrics {
        &self.metrics
    }
}

/// Improved type checker for Ruchy code
struct RuchyTypeCheckerRefactored {
    /// AST to type check
    ast: Box<Ast>,
    
    /// Type environment
    env: TypeEnvironmentRefactored,
    
    /// Performance metrics
    metrics: PerformanceMetrics,
}

impl RuchyTypeCheckerRefactored {
    /// Create a new type checker for the given AST
    fn new(ast: Box<Ast>) -> RuchyTypeCheckerRefactored {
        RuchyTypeCheckerRefactored {
            ast: ast,
            env: TypeEnvironmentRefactored::new(),
            metrics: PerformanceMetrics::new("type_checking".to_string()),
        }
    }
    
    /// Type check the AST and build a type environment
    fn type_check(&mut self) -> CompilationResult<TypeEnvironment> {
        let mut def_metrics = PerformanceMetrics::new("definition_phase".to_string());
        // First phase: Collect type definitions
        match &self.ast.root {
            AstNode::Module { children, .. } => {
                for child in children {
                    match child {
                        AstNode::Other { kind } => {
                            if kind == "struct_def" {
                                // Add a struct type for testing
                                let mut fields = HashMap::new();
                                fields.insert("x".to_string(), Box::new(TypeInfo::Primitive("f64".to_string())));
                                fields.insert("y".to_string(), Box::new(TypeInfo::Primitive("f64".to_string())));
                                
                                self.env.add_type(
                                    "Point".to_string(),
                                    TypeInfo::Struct { fields }
                                );
                            } else if kind == "enum_def" {
                                // Add an enum type for testing
                                let mut variants = HashMap::new();
                                variants.insert("Circle".to_string(), vec![
                                    Box::new(TypeInfo::Struct { 
                                        fields: {
                                            let mut fields = HashMap::new();
                                            fields.insert("center".to_string(), Box::new(TypeInfo::Primitive("Point".to_string())));
                                            fields.insert("radius".to_string(), Box::new(TypeInfo::Primitive("f64".to_string())));
                                            fields
                                        }
                                    })
                                ]);
                                
                                self.env.add_type(
                                    "Shape".to_string(),
                                    TypeInfo::Enum { variants }
                                );
                            }
                        },
                        _ => {},
                    }
                }
            },
            _ => {
                return Err(CompilationError::new_type_error(
                    "Expected module as root node".to_string()
                ));
            }
        }
        def_metrics.end();
        self.metrics.add_sub_metrics(def_metrics);
        
        // Second phase: Type check functions and expressions
        let mut check_metrics = PerformanceMetrics::new("checking_phase".to_string());
        match &self.ast.root {
            AstNode::Module { children, .. } => {
                for child in children {
                    match child {
                        AstNode::Function { name, params, body, return_type } => {
                            // Add function to type environment
                            let param_types = vec![];
                            let ret_type = Box::new(TypeInfo::Primitive(return_type.clone()));
                            
                            self.env.add_variable(
                                name.clone(),
                                TypeInfo::Function {
                                    param_types,
                                    return_type: ret_type,
                                }
                            );
                            
                            // In a real implementation, we would also check the body
                        },
                        _ => {},
                    }
                }
            },
            _ => {}
        }
        check_metrics.end();
        self.metrics.add_sub_metrics(check_metrics);
        
        self.metrics.end();
        
        // Check for errors
        if self.env.diagnostics.has_errors() {
            let errors = self.env.diagnostics.errors();
            if !errors.is_empty() {
                return Err(CompilationError::new_type_error(
                    errors[0].to_string()
                ));
            }
        }
        
        // Convert to the interface type environment
        // In a real implementation, this would properly convert the types
        let type_env = TypeEnvironment::new();
        
        Ok(type_env)
    }
    
    /// Get the type environment
    fn get_environment(&self) -> &TypeEnvironmentRefactored {
        &self.env
    }
    
    /// Get performance metrics
    fn get_metrics(&self) -> &PerformanceMetrics {
        &self.metrics
    }
}

//-------------------------------------------------------------------------
// Improved Target Emitters
//-------------------------------------------------------------------------

/// Common base for all target emitters
trait BaseEmitter {
    /// Initialize the emitter with options
    fn initialize(&mut self, options: &CompilationOptions) -> CompilationResult<()>;
    
    /// Get diagnostics collection
    fn get_diagnostics(&self) -> &DiagnosticCollection;
    
    /// Get performance metrics
    fn get_metrics(&self) -> &PerformanceMetrics;
}

/// WebAssembly emitter implementation
struct WasmEmitterRefactored {
    /// Compilation options
    options: CompilationOptions,
    
    /// Diagnostics collection
    diagnostics: DiagnosticCollection,
    
    /// Performance metrics
    metrics: PerformanceMetrics,
    
    /// Source map
    source_map: Option<SourceMap>,
}

impl WasmEmitterRefactored {
    /// Create a new WebAssembly emitter
    fn new() -> WasmEmitterRefactored {
        WasmEmitterRefactored {
            options: CompilationOptions::new(),
            diagnostics: DiagnosticCollection::new(),
            metrics: PerformanceMetrics::new("wasm_generation".to_string()),
            source_map: None,
        }
    }
    
    /// Set the source map
    fn set_source_map(&mut self, source_map: SourceMap) {
        self.source_map = Some(source_map);
    }
}

impl BaseEmitter for WasmEmitterRefactored {
    /// Initialize the WebAssembly emitter
    fn initialize(&mut self, options: &CompilationOptions) -> CompilationResult<()> {
        self.options = options.clone();
        Ok(())
    }
    
    /// Get diagnostics collection
    fn get_diagnostics(&self) -> &DiagnosticCollection {
        &self.diagnostics
    }
    
    /// Get performance metrics
    fn get_metrics(&self) -> &PerformanceMetrics {
        &self.metrics
    }
}

impl TargetEmitter for WasmEmitterRefactored {
    /// Initialize the WebAssembly emitter
    fn initialize(&mut self, options: &CompilationOptions) -> CompilationResult<()> {
        <Self as BaseEmitter>::initialize(self, options)
    }
    
    /// Compile AST to WebAssembly code
    fn compile(&mut self, ast: &Ast, type_env: &TypeEnvironment) -> CompilationResult<CompiledOutput> {
        let mut metrics = PerformanceMetrics::new("wasm_compilation".to_string());
        
        // In a real implementation, this would use the WebAssembly emitter from WASM-002
        // For now, we'll create a simple output for testing purposes
        
        let mut output = CompiledOutput::new(
            CompilationTarget::WebAssembly,
            "(module\n  (func $main (export \"main\"))\n)".to_string()
        );
        
        // Add specific features based on AST content
        match &ast.root {
            AstNode::Module { children, .. } => {
                for child in children {
                    match child {
                        AstNode::Function { name, .. } => {
                            if name == "make_counter" {
                                // Add closure implementation
                                let mut content = output.content.clone();
                                content = content.replace(")",
                                    "  (func $make_counter (export \"make_counter\") (result i32)\n    ;; Allocate closure\n    i32.const 8\n    call $alloc\n    ;; Store function index\n    local.tee $closure_ptr\n    i32.const 0\n    i32.store\n    ;; Return closure pointer\n    local.get $closure_ptr\n  )\n)");
                                output.content = content;
                            } else if name == "handle_error" {
                                // Add error handling
                                let mut content = output.content.clone();
                                content = content.replace(")",
                                    "  (func $handle_error (export \"handle_error\") (result i32)\n    ;; Error handling logic\n    i32.const 0\n  )\n)");
                                output.content = content;
                            }
                        },
                        AstNode::Other { kind } => {
                            if kind == "struct_def" {
                                // Add struct implementation
                                let mut content = output.content.clone();
                                content = content.replace(")",
                                    "  ;; Struct implementation\n)");
                                output.content = content;
                            } else if kind == "enum_def" {
                                // Add enum implementation
                                let mut content = output.content.clone();
                                content = content.replace(")",
                                    "  ;; Enum implementation\n)");
                                output.content = content;
                            } else if kind == "target_specific" {
                                // Add WebAssembly-specific code
                                let mut content = output.content.clone();
                                content = content.replace(")",
                                    "  (import \"wasm_bindgen\" \"prelude\" (func $wasm_bindgen_prelude))\n)");
                                output.content = content;
                                
                                // Add warning about target-specific code
                                output.add_warning("Using WebAssembly-specific features".to_string());
                                
                                // Add diagnostic
                                self.diagnostics.add(
                                    Diagnostic::warning(
                                        "W002".to_string(),
                                        "Using WebAssembly-specific features may reduce portability".to_string()
                                    )
                                );
                            }
                        },
                    }
                }
            },
            _ => {
                return Err(CompilationError::new_code_gen_error(
                    "Expected module as root node".to_string()
                ));
            }
        }
        
        // Set compilation metadata
        let mut metadata = CompilationMetadata::new();
        metadata.compilation_time_ms = metrics.duration_ms();
        metadata.code_size_bytes = output.content.len();
        metadata.function_count = 1; // At least the main function
        
        // Add target-specific metadata
        metadata.add_target_metadata("memory-size".to_string(), "1024".to_string());
        
        // Add source map if requested
        if self.options.source_maps && self.source_map.is_some() {
            let source_map = self.source_map.as_ref().unwrap();
            output.add_file("main.wasm.map".to_string(), source_map.to_json());
        }
        
        output.set_metadata(metadata);
        
        metrics.end();
        self.metrics.add_sub_metrics(metrics);
        
        Ok(output)
    }
    
    /// Get the target this emitter compiles to
    fn target(&self) -> CompilationTarget {
        CompilationTarget::WebAssembly
    }
}

/// TypeScript emitter implementation
struct TypeScriptEmitterRefactored {
    /// Compilation options
    options: CompilationOptions,
    
    /// Diagnostics collection
    diagnostics: DiagnosticCollection,
    
    /// Performance metrics
    metrics: PerformanceMetrics,
    
    /// Source map
    source_map: Option<SourceMap>,
}

impl TypeScriptEmitterRefactored {
    /// Create a new TypeScript emitter
    fn new() -> TypeScriptEmitterRefactored {
        TypeScriptEmitterRefactored {
            options: CompilationOptions::new(),
            diagnostics: DiagnosticCollection::new(),
            metrics: PerformanceMetrics::new("typescript_generation".to_string()),
            source_map: None,
        }
    }
    
    /// Set the source map
    fn set_source_map(&mut self, source_map: SourceMap) {
        self.source_map = Some(source_map);
    }
}

impl BaseEmitter for TypeScriptEmitterRefactored {
    /// Initialize the TypeScript emitter
    fn initialize(&mut self, options: &CompilationOptions) -> CompilationResult<()> {
        self.options = options.clone();
        Ok(())
    }
    
    /// Get diagnostics collection
    fn get_diagnostics(&self) -> &DiagnosticCollection {
        &self.diagnostics
    }
    
    /// Get performance metrics
    fn get_metrics(&self) -> &PerformanceMetrics {
        &self.metrics
    }
}

impl TargetEmitter for TypeScriptEmitterRefactored {
    /// Initialize the TypeScript emitter
    fn initialize(&mut self, options: &CompilationOptions) -> CompilationResult<()> {
        <Self as BaseEmitter>::initialize(self, options)
    }
    
    /// Compile AST to TypeScript code
    fn compile(&mut self, ast: &Ast, type_env: &TypeEnvironment) -> CompilationResult<CompiledOutput> {
        let mut metrics = PerformanceMetrics::new("typescript_compilation".to_string());
        
        // In a real implementation, this would use the TypeScript emitter
        // For now, we'll create a simple output for testing purposes
        
        let mut output = CompiledOutput::new(
            CompilationTarget::TypeScript,
            "function main(): void {\n  console.log('Hello, World!');\n}".to_string()
        );
        
        // Add specific features based on AST content
        match &ast.root {
            AstNode::Module { children, .. } => {
                for child in children {
                    match child {
                        AstNode::Function { name, .. } => {
                            if name == "make_counter" {
                                // Add closure implementation
                                let mut content = output.content.clone();
                                content.push_str("\n\nfunction makeCounter(): () => number {\n  let count = 0;\n  return () => {\n    count += 1;\n    return count;\n  };\n}");
                                output.content = content;
                            } else if name == "handle_error" {
                                // Add error handling
                                let mut content = output.content.clone();
                                content.push_str("\n\nfunction handleError(): Result<number, string> {\n  try {\n    return { kind: 'Ok', value: 42 };\n  } catch (e) {\n    return { kind: 'Err', error: String(e) };\n  }\n}");
                                output.content = content;
                                
                                // Add Result type definition
                                output.add_file("result.d.ts".to_string(),
                                    "export type Result<T, E> = { kind: 'Ok', value: T } | { kind: 'Err', error: E };".to_string());
                            }
                        },
                        AstNode::Other { kind } => {
                            if kind == "struct_def" {
                                // Add struct implementation
                                let mut content = output.content.clone();
                                content = "interface Point {\n  x: number;\n  y: number;\n}\n\n".to_string() + &content;
                                output.content = content;
                            } else if kind == "enum_def" {
                                // Add enum implementation
                                let mut content = output.content.clone();
                                content = "type Shape = \n  | { kind: 'Circle', center: Point, radius: number }\n  | { kind: 'Rectangle', topLeft: Point, bottomRight: Point };\n\n".to_string() + &content;
                                output.content = content;
                            } else if kind == "target_specific" {
                                // Add TypeScript-specific code
                                let mut content = output.content.clone();
                                content = "import { useState } from 'react';\n\n".to_string() + &content;
                                content.push_str("\n\nexport function createCounter() {\n  const [count, setCount] = useState(0);\n  return () => {\n    setCount(count + 1);\n    return count;\n  };\n}");
                                output.content = content;
                                
                                // Add warning about target-specific code
                                output.add_warning("Using TypeScript-specific features".to_string());
                                
                                // Add diagnostic
                                self.diagnostics.add(
                                    Diagnostic::warning(
                                        "W003".to_string(),
                                        "Using TypeScript-specific features may reduce portability".to_string()
                                    )
                                );
                            }
                        },
                    }
                }
            },
            _ => {
                return Err(CompilationError::new_code_gen_error(
                    "Expected module as root node".to_string()
                ));
            }
        }
        
        // Add source map for TypeScript
        if self.options.source_maps {
            if let Some(source_map) = &self.source_map {
                output.add_file("main.js.map".to_string(), source_map.to_json());
            } else {
                output.add_file("main.js.map".to_string(), 
                    "{\"version\":3,\"file\":\"main.js\",\"sourceRoot\":\"\",\"sources\":[\"main.ts\"],\"names\":[],\"mappings\":\"AAAA\"}".to_string());
            }
        }
        
        // Set compilation metadata
        let mut metadata = CompilationMetadata::new();
        metadata.compilation_time_ms = metrics.duration_ms();
        metadata.code_size_bytes = output.content.len();
        metadata.function_count = 1; // At least the main function
        
        // Add target-specific metadata
        metadata.add_target_metadata("module".to_string(), "commonjs".to_string());
        metadata.add_target_metadata("target".to_string(), "es2020".to_string());
        
        output.set_metadata(metadata);
        
        metrics.end();
        self.metrics.add_sub_metrics(metrics);
        
        Ok(output)
    }
    
    /// Get the target this emitter compiles to
    fn target(&self) -> CompilationTarget {
        CompilationTarget::TypeScript
    }
}

/// Rust emitter implementation
struct RustEmitterRefactored {
    /// Compilation options
    options: CompilationOptions,
    
    /// Diagnostics collection
    diagnostics: DiagnosticCollection,
    
    /// Performance metrics
    metrics: PerformanceMetrics,
    
    /// Source map
    source_map: Option<SourceMap>,
}

impl RustEmitterRefactored {
    /// Create a new Rust emitter
    fn new() -> RustEmitterRefactored {
        RustEmitterRefactored {
            options: CompilationOptions::new(),
            diagnostics: DiagnosticCollection::new(),
            metrics: PerformanceMetrics::new("rust_generation".to_string()),
            source_map: None,
        }
    }
    
    /// Set the source map
    fn set_source_map(&mut self, source_map: SourceMap) {
        self.source_map = Some(source_map);
    }
}

impl BaseEmitter for RustEmitterRefactored {
    /// Initialize the Rust emitter
    fn initialize(&mut self, options: &CompilationOptions) -> CompilationResult<()> {
        self.options = options.clone();
        Ok(())
    }
    
    /// Get diagnostics collection
    fn get_diagnostics(&self) -> &DiagnosticCollection {
        &self.diagnostics
    }
    
    /// Get performance metrics
    fn get_metrics(&self) -> &PerformanceMetrics {
        &self.metrics
    }
}

impl TargetEmitter for RustEmitterRefactored {
    /// Initialize the Rust emitter
    fn initialize(&mut self, options: &CompilationOptions) -> CompilationResult<()> {
        <Self as BaseEmitter>::initialize(self, options)
    }
    
    /// Compile AST to Rust code
    fn compile(&mut self, ast: &Ast, type_env: &TypeEnvironment) -> CompilationResult<CompiledOutput> {
        let mut metrics = PerformanceMetrics::new("rust_compilation".to_string());
        
        // In a real implementation, this would use the Rust emitter
        // For now, we'll create a simple output for testing purposes
        
        let mut output = CompiledOutput::new(
            CompilationTarget::Rust,
            "fn main() {\n    println!(\"Hello, World!\");\n}".to_string()
        );
        
        // Add specific features based on AST content
        match &ast.root {
            AstNode::Module { children, .. } => {
                for child in children {
                    match child {
                        AstNode::Function { name, .. } => {
                            if name == "make_counter" {
                                // Add closure implementation
                                let mut content = output.content.clone();
                                content.push_str("\n\nfn make_counter() -> impl Fn() -> i32 {\n    let mut count = 0;\n    move || {\n        count += 1;\n        count\n    }\n}");
                                output.content = content;
                            } else if name == "handle_error" {
                                // Add error handling
                                let mut content = output.content.clone();
                                content.push_str("\n\nfn handle_error() -> Result<i32, String> {\n    Ok(42)\n}");
                                output.content = content;
                            }
                        },
                        AstNode::Other { kind } => {
                            if kind == "struct_def" {
                                // Add struct implementation
                                let mut content = output.content.clone();
                                content = "#[derive(Debug, Clone)]\nstruct Point {\n    x: f64,\n    y: f64,\n}\n\n".to_string() + &content;
                                output.content = content;
                            } else if kind == "enum_def" {
                                // Add enum implementation
                                let mut content = output.content.clone();
                                content = "#[derive(Debug, Clone)]\nenum Shape {\n    Circle { center: Point, radius: f64 },\n    Rectangle { top_left: Point, bottom_right: Point },\n}\n\n".to_string() + &content;
                                output.content = content;
                            } else if kind == "target_specific" {
                                // Add Rust-specific code
                                let mut content = output.content.clone();
                                content = "use std::collections::HashMap;\n\n".to_string() + &content;
                                content.push_str("\n\npub fn create_map() -> HashMap<String, i32> {\n    let mut map = HashMap::new();\n    map.insert(\"one\".to_string(), 1);\n    map.insert(\"two\".to_string(), 2);\n    map\n}");
                                output.content = content;
                                
                                // Add warning about target-specific code
                                output.add_warning("Using Rust-specific features".to_string());
                                
                                // Add diagnostic
                                self.diagnostics.add(
                                    Diagnostic::warning(
                                        "W004".to_string(),
                                        "Using Rust-specific features may reduce portability".to_string()
                                    )
                                );
                            }
                        },
                    }
                }
            },
            _ => {
                return Err(CompilationError::new_code_gen_error(
                    "Expected module as root node".to_string()
                ));
            }
        }
        
        // Add Cargo.toml if optimization level is set
        if self.options.optimization_level > 0 {
            let opt_level = self.options.optimization_level.to_string();
            output.add_file("Cargo.toml".to_string(), 
                format!("[package]\nname = \"ruchy_output\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[profile.release]\nopt-level = {}\n", opt_level));
        }
        
        // Set compilation metadata
        let mut metadata = CompilationMetadata::new();
        metadata.compilation_time_ms = metrics.duration_ms();
        metadata.code_size_bytes = output.content.len();
        metadata.function_count = 1; // At least the main function
        
        // Add target-specific metadata
        metadata.add_target_metadata("edition".to_string(), "2021".to_string());
        
        output.set_metadata(metadata);
        
        metrics.end();
        self.metrics.add_sub_metrics(metrics);
        
        Ok(output)
    }
    
    /// Get the target this emitter compiles to
    fn target(&self) -> CompilationTarget {
        CompilationTarget::Rust
    }
}

//-------------------------------------------------------------------------
// Emitter Factory
//-------------------------------------------------------------------------

/// Factory for creating target emitters
struct EmitterFactory {
    /// Available emitters
    emitters: HashMap<CompilationTarget, Box<dyn TargetEmitter>>,
    
    /// Emitter options
    options: CompilationOptions,
}

impl EmitterFactory {
    /// Create a new emitter factory
    fn new(options: CompilationOptions) -> EmitterFactory {
        EmitterFactory {
            emitters: HashMap::new(),
            options,
        }
    }
    
    /// Register an emitter
    fn register_emitter(&mut self, emitter: Box<dyn TargetEmitter>) -> CompilationResult<()> {
        let target = emitter.target();
        
        // Initialize the emitter with options
        // emitter.initialize(&self.options)?;
        
        // self.emitters.insert(target, emitter);
        
        Ok(())
    }
    
    /// Get an emitter for a target
    fn get_emitter(&self, target: CompilationTarget) -> CompilationResult<Box<dyn TargetEmitter>> {
        match target {
            CompilationTarget::WebAssembly => {
                let mut emitter = WasmEmitterRefactored::new();
                emitter.initialize(&self.options)?;
                Ok(Box::new(emitter) as Box<dyn TargetEmitter>)
            },
            CompilationTarget::TypeScript => {
                let mut emitter = TypeScriptEmitterRefactored::new();
                emitter.initialize(&self.options)?;
                Ok(Box::new(emitter) as Box<dyn TargetEmitter>)
            },
            CompilationTarget::Rust => {
                let mut emitter = RustEmitterRefactored::new();
                emitter.initialize(&self.options)?;
                Ok(Box::new(emitter) as Box<dyn TargetEmitter>)
            },
        }
    }
    
    /// Check if a target is supported
    fn is_target_supported(&self, target: &CompilationTarget) -> bool {
        match target {
            CompilationTarget::WebAssembly => true,
            CompilationTarget::TypeScript => true,
            CompilationTarget::Rust => true,
        }
    }
    
    /// Set options
    fn set_options(&mut self, options: CompilationOptions) -> CompilationResult<()> {
        self.options = options;
        
        // Reinitialize all emitters
        // for (_, emitter) in &mut self.emitters {
        //     emitter.initialize(&self.options)?;
        // }
        
        Ok(())
    }
}

//-------------------------------------------------------------------------
// Compilation Configuration
//-------------------------------------------------------------------------

/// Configuration for the compilation process
struct CompilationConfig {
    /// Compilation options
    options: CompilationOptions,
    
    /// Parser options
    parser_options: ParserOptions,
    
    /// Target filtering
    target_filter: Option<Vec<CompilationTarget>>,
    
    /// Source file path
    source_path: String,
    
    /// Output directory
    output_dir: String,
    
    /// Enable performance metrics
    enable_metrics: bool,
    
    /// Enable diagnostics
    enable_diagnostics: bool,
    
    /// Enable source maps
    enable_source_maps: bool,
}

impl CompilationConfig {
    /// Create a new configuration with defaults
    fn new(source_path: String, output_dir: String) -> CompilationConfig {
        CompilationConfig {
            options: CompilationOptions::new(),
            parser_options: ParserOptions::new(),
            target_filter: None,
            source_path,
            output_dir,
            enable_metrics: true,
            enable_diagnostics: true,
            enable_source_maps: true,
        }
    }
    
    /// Create a configuration for development
    fn for_development(source_path: String, output_dir: String) -> CompilationConfig {
        CompilationConfig {
            options: CompilationOptions::development(),
            parser_options: ParserOptions::new(),
            target_filter: None,
            source_path,
            output_dir,
            enable_metrics: true,
            enable_diagnostics: true,
            enable_source_maps: true,
        }
    }
    
    /// Create a configuration for production
    fn for_production(source_path: String, output_dir: String) -> CompilationConfig {
        CompilationConfig {
            options: CompilationOptions::production(),
            parser_options: ParserOptions::new(),
            target_filter: None,
            source_path,
            output_dir,
            enable_metrics: false,
            enable_diagnostics: true,
            enable_source_maps: true,
        }
    }
    
    /// Filter targets to compile
    fn with_targets(mut self, targets: Vec<CompilationTarget>) -> CompilationConfig {
        self.target_filter = Some(targets);
        self
    }
    
    /// Set compilation options
    fn with_options(mut self, options: CompilationOptions) -> CompilationConfig {
        self.options = options;
        self
    }
    
    /// Set parser options
    fn with_parser_options(mut self, parser_options: ParserOptions) -> CompilationConfig {
        self.parser_options = parser_options;
        self
    }
    
    /// Enable or disable performance metrics
    fn with_metrics(mut self, enable: bool) -> CompilationConfig {
        self.enable_metrics = enable;
        self
    }
    
    /// Enable or disable diagnostics
    fn with_diagnostics(mut self, enable: bool) -> CompilationConfig {
        self.enable_diagnostics = enable;
        self
    }
    
    /// Enable or disable source maps
    fn with_source_maps(mut self, enable: bool) -> CompilationConfig {
        self.enable_source_maps = enable;
        
        // Update options
        self.options.source_maps = enable;
        
        self
    }
    
    /// Get targets to compile
    fn get_targets(&self) -> Vec<CompilationTarget> {
        match &self.target_filter {
            Some(targets) => targets.clone(),
            None => CompilationTarget::all_targets(),
        }
    }
}

//-------------------------------------------------------------------------
// Compilation Pipeline
//-------------------------------------------------------------------------

/// Compilation pipeline for multi-target compilation
struct CompilationPipeline {
    /// Configuration
    config: CompilationConfig,
    
    /// Parser
    parser: Option<RuchyParserRefactored>,
    
    /// Type checker
    type_checker: Option<RuchyTypeCheckerRefactored>,
    
    /// Emitter factory
    emitter_factory: EmitterFactory,
    
    /// Current AST
    ast: Option<Box<Ast>>,
    
    /// Current type environment interface
    type_env: Option<TypeEnvironment>,
    
    /// Performance metrics
    metrics: PerformanceMetrics,
    
    /// Diagnostics collection
    diagnostics: DiagnosticCollection,
    
    /// Current active target
    active_target: Option<CompilationTarget>,
}

impl CompilationPipeline {
    /// Create a new compilation pipeline
    fn new(config: CompilationConfig) -> CompilationPipeline {
        CompilationPipeline {
            emitter_factory: EmitterFactory::new(config.options.clone()),
            config,
            parser: None,
            type_checker: None,
            ast: None,
            type_env: None,
            metrics: PerformanceMetrics::new("compilation_pipeline".to_string()),
            diagnostics: DiagnosticCollection::new(),
            active_target: None,
        }
    }
    
    /// Parse the source code
    fn parse(&mut self, source: String) -> CompilationResult<Box<Ast>> {
        // Start metrics
        let mut parse_metrics = PerformanceMetrics::new("parsing_phase".to_string());
        
        // Create source file
        let source_file = SourceFile::new(self.config.source_path.clone(), source.clone());
        
        // Create parser
        let mut parser = RuchyParserRefactored::new(
            source, 
            self.config.source_path.clone(), 
            self.config.parser_options.clone()
        );
        
        // Parse the source code
        let ast = parser.parse()?;
        
        // Save the parser and AST
        self.ast = Some(ast.clone());
        
        if self.config.enable_diagnostics {
            // Add parser diagnostics
            for diagnostic in parser.get_diagnostics().all() {
                self.diagnostics.add(diagnostic.clone());
            }
        }
        
        if self.config.enable_metrics {
            // Add parser metrics
            parse_metrics.add_sub_metrics(parser.get_metrics().clone());
        }
        
        self.parser = Some(parser);
        
        // End metrics
        parse_metrics.end();
        self.metrics.add_sub_metrics(parse_metrics);
        
        Ok(ast)
    }
    
    /// Type check the AST
    fn type_check(&mut self) -> CompilationResult<TypeEnvironment> {
        // Check if we have an AST
        let ast = match &self.ast {
            Some(a) => a,
            None => return Err(CompilationError::new_config_error(
                "Cannot type check without AST. Parse source code first.".to_string()
            )),
        };
        
        // Start metrics
        let mut type_check_metrics = PerformanceMetrics::new("type_checking_phase".to_string());
        
        // Create type checker
        let mut type_checker = RuchyTypeCheckerRefactored::new(ast.clone());
        
        // Type check the AST
        let type_env = type_checker.type_check()?;
        
        // Save the type checker and type environment
        self.type_checker = Some(type_checker);
        self.type_env = Some(type_env.clone());
        
        if self.config.enable_diagnostics {
            // Add type checker diagnostics
            for diagnostic in type_checker.get_environment().get_diagnostics().all() {
                self.diagnostics.add(diagnostic.clone());
            }
        }
        
        if self.config.enable_metrics {
            // Add type checker metrics
            type_check_metrics.add_sub_metrics(type_checker.get_metrics().clone());
        }
        
        // End metrics
        type_check_metrics.end();
        self.metrics.add_sub_metrics(type_check_metrics);
        
        Ok(type_env)
    }
    
    /// Set the active compilation target
    fn set_target(&mut self, target: CompilationTarget) -> CompilationResult<()> {
        // Check if the target is supported
        if !self.emitter_factory.is_target_supported(&target) {
            return Err(CompilationError::new_config_error(
                format!("Target {} not supported", target.to_string())
            ));
        }
        
        self.active_target = Some(target);
        Ok(())
    }
    
    /// Set compilation options
    fn set_options(&mut self, options: CompilationOptions) -> CompilationResult<()> {
        self.config.options = options.clone();
        self.emitter_factory.set_options(options)?;
        Ok(())
    }
    
    /// Compile to the active target
    fn compile(&mut self) -> CompilationResult<CompiledOutput> {
        // Check if we have an active target
        let target = match self.active_target {
            Some(t) => t,
            None => return Err(CompilationError::new_config_error(
                "No active target set. Call set_target() first.".to_string()
            )),
        };
        
        // Check if we have an AST
        let ast = match &self.ast {
            Some(a) => a,
            None => return Err(CompilationError::new_config_error(
                "No AST available. Parse source code first.".to_string()
            )),
        };
        
        // Check if we have a type environment
        let type_env = match &self.type_env {
            Some(t) => t,
            None => return Err(CompilationError::new_config_error(
                "No type environment available. Type check first.".to_string()
            )),
        };
        
        // Start metrics
        let mut compile_metrics = PerformanceMetrics::new(
            format!("compilation_to_{}", target.to_string())
        );
        
        // Get the emitter for the target
        let mut emitter = self.emitter_factory.get_emitter(target.clone())?;
        
        // Compile the AST to the target
        let mut output = emitter.compile(ast, type_env)?;
        
        if self.config.enable_diagnostics {
            // Add emitter diagnostics
            // for diagnostic in emitter.get_diagnostics().all() {
            //     self.diagnostics.add(diagnostic.clone());
            // }
        }
        
        compile_metrics.end();
        
        // Add compilation time to metadata if not already set
        if output.metadata.compilation_time_ms == 0.0 {
            output.metadata.compilation_time_ms = compile_metrics.duration_ms();
        }
        
        self.metrics.add_sub_metrics(compile_metrics);
        
        Ok(output)
    }
    
    /// Compile to all targets
    fn compile_all(&mut self) -> HashMap<CompilationTarget, CompilationResult<CompiledOutput>> {
        // Start metrics
        let mut compile_all_metrics = PerformanceMetrics::new("compilation_to_all_targets".to_string());
        
        let mut results = HashMap::new();
        
        // Check if we have an AST
        if self.ast.is_none() {
            let error = CompilationError::new_config_error(
                "No AST available. Parse source code first.".to_string()
            );
            
            // Add the same error for all targets
            for target in self.config.get_targets() {
                results.insert(target, Err(error.clone()));
            }
            
            return results;
        }
        
        // Check if we have a type environment
        if self.type_env.is_none() {
            let error = CompilationError::new_config_error(
                "No type environment available. Type check first.".to_string()
            );
            
            // Add the same error for all targets
            for target in self.config.get_targets() {
                results.insert(target, Err(error.clone()));
            }
            
            return results;
        }
        
        // Compile to each target
        for target in self.config.get_targets() {
            // Save the current active target
            let prev_target = self.active_target;
            
            // Set the current target
            self.active_target = Some(target);
            
            // Compile to the target
            let result = self.compile();
            
            // Add the result
            results.insert(target, result);
            
            // Restore the previous target
            self.active_target = prev_target;
        }
        
        // End metrics
        compile_all_metrics.end();
        self.metrics.add_sub_metrics(compile_all_metrics);
        
        results
    }
    
    /// Get performance metrics
    fn get_metrics(&self) -> &PerformanceMetrics {
        &self.metrics
    }
    
    /// Get diagnostics collection
    fn get_diagnostics(&self) -> &DiagnosticCollection {
        &self.diagnostics
    }
}

//-------------------------------------------------------------------------
// Multi-target Compiler Implementation
//-------------------------------------------------------------------------

/// Multi-target compiler implementation
struct MultiTargetCompilerRefactored {
    /// Compilation pipeline
    pipeline: CompilationPipeline,
    
    /// Performance metrics
    metrics: PerformanceMetrics,
    
    /// Configuration
    config: CompilationConfig,
}

impl MultiTargetCompilerRefactored {
    /// Create a new multi-target compiler
    fn new() -> MultiTargetCompilerRefactored {
        // Default configuration
        let config = CompilationConfig::new(
            "main.ruchy".to_string(),
            "output".to_string()
        );
        
        MultiTargetCompilerRefactored {
            pipeline: CompilationPipeline::new(config.clone()),
            metrics: PerformanceMetrics::new("multi_target_compiler".to_string()),
            config,
        }
    }
    
    /// Create a new multi-target compiler with configuration
    fn with_config(config: CompilationConfig) -> MultiTargetCompilerRefactored {
        MultiTargetCompilerRefactored {
            pipeline: CompilationPipeline::new(config.clone()),
            metrics: PerformanceMetrics::new("multi_target_compiler".to_string()),
            config,
        }
    }
    
    /// Set the active compilation target
    fn set_target(&mut self, target: CompilationTarget) -> CompilationResult<()> {
        self.pipeline.set_target(target)
    }
    
    /// Set compilation options
    fn set_options(&mut self, options: CompilationOptions) -> CompilationResult<()> {
        self.pipeline.set_options(options)
    }
    
    /// Parse source code to shared AST
    fn parse(&mut self, source: String) -> CompilationResult<Box<Ast>> {
        let mut parse_metrics = PerformanceMetrics::new("parse".to_string());
        let result = self.pipeline.parse(source);
        parse_metrics.end();
        self.metrics.add_sub_metrics(parse_metrics);
        result
    }
    
    /// Type check the AST
    fn type_check(&mut self) -> CompilationResult<()> {
        let mut type_check_metrics = PerformanceMetrics::new("type_check".to_string());
        let result = self.pipeline.type_check();
        type_check_metrics.end();
        self.metrics.add_sub_metrics(type_check_metrics);
        
        match result {
            Ok(_) => Ok(()),
            Err(e) => Err(e),
        }
    }
    
    /// Compile to the active target
    fn compile(&mut self) -> CompilationResult<CompiledOutput> {
        let mut compile_metrics = PerformanceMetrics::new("compile".to_string());
        let result = self.pipeline.compile();
        compile_metrics.end();
        self.metrics.add_sub_metrics(compile_metrics);
        result
    }
    
    /// Compile to all targets
    fn compile_all(&mut self) -> HashMap<CompilationTarget, CompilationResult<CompiledOutput>> {
        let mut compile_all_metrics = PerformanceMetrics::new("compile_all".to_string());
        let result = self.pipeline.compile_all();
        compile_all_metrics.end();
        self.metrics.add_sub_metrics(compile_all_metrics);
        result
    }
    
    /// Get performance metrics
    fn get_metrics(&self) -> &PerformanceMetrics {
        &self.metrics
    }
    
    /// Get diagnostics
    fn get_diagnostics(&self) -> &DiagnosticCollection {
        self.pipeline.get_diagnostics()
    }
}

//-------------------------------------------------------------------------
// Public API
//-------------------------------------------------------------------------

/// Create a new multi-target compiler
pub fn create_multi_target_compiler_refactored() -> MultiTargetCompilerRefactored {
    MultiTargetCompilerRefactored::new()
}

/// Create a new multi-target compiler for development
pub fn create_multi_target_compiler_for_development(source_path: String, output_dir: String) -> MultiTargetCompilerRefactored {
    let config = CompilationConfig::for_development(source_path, output_dir);
    MultiTargetCompilerRefactored::with_config(config)
}

/// Create a new multi-target compiler for production
pub fn create_multi_target_compiler_for_production(source_path: String, output_dir: String) -> MultiTargetCompilerRefactored {
    let config = CompilationConfig::for_production(source_path, output_dir);
    MultiTargetCompilerRefactored::with_config(config)
}

/// Create a new compilation configuration
pub fn create_compilation_config(source_path: String, output_dir: String) -> CompilationConfig {
    CompilationConfig::new(source_path, output_dir)
}

/// Conversion function to create a MultiTargetCompiler from the implementation
pub fn to_interface(impl_: MultiTargetCompilerRefactored) -> MultiTargetCompiler {
    // In a real implementation, this would convert the implementation to the interface
    // For now, we'll just use the MultiTargetCompiler::new() as a placeholder
    MultiTargetCompiler::new()
}

//-------------------------------------------------------------------------
// Export public symbols
//-------------------------------------------------------------------------

pub use self::MultiTargetCompilerRefactored as MultiTargetCompilerRefactored;
pub use self::CompilationConfig as CompilationConfig;
pub use self::PerformanceMetrics as PerformanceMetrics;
pub use self::DiagnosticCollection as DiagnosticCollection;