// WASM-006: Incremental Compilation - Content Hashing
//
// Implements SHA-256 content hashing for cache key generation
// Used for detecting file changes and cache invalidation

use std::fs;
use std::path::PathBuf;
use std::collections::HashMap;

// ============================================================================
// SHA-256 Hashing Implementation
// ============================================================================

pub struct ContentHasher {
    // Cache for file timestamps to avoid unnecessary hashing
    timestamp_cache: HashMap<String, u64>,
}

impl ContentHasher {
    pub fun new() -> Self {
        ContentHasher {
            timestamp_cache: HashMap::new(),
        }
    }

    /// Compute SHA-256 hash of file contents
    pub fun hash_file(&mut self, path: &str) -> Result<String, String> {
        // Fast path: check timestamp first
        let metadata = fs::metadata(path)
            .map_err(|e| format!("Failed to read file metadata: {}", e))?;

        let modified = metadata.modified()
            .map_err(|e| format!("Failed to get modification time: {}", e))?
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs();

        // Check if we've seen this file before at this timestamp
        if let Some(&cached_time) = self.timestamp_cache.get(path) {
            if cached_time == modified {
                // File hasn't changed, return cached hash
                return Ok(self.get_cached_hash(path)?);
            }
        }

        // File is new or changed, compute hash
        let content = fs::read_to_string(path)
            .map_err(|e| format!("Failed to read file: {}", e))?;

        let hash = self.hash_content(&content);

        // Update timestamp cache
        self.timestamp_cache.insert(path.to_string(), modified);

        Ok(hash)
    }

    /// Compute SHA-256 hash of string content
    pub fun hash_content(&self, content: &str) -> String {
        // Normalize line endings before hashing
        let normalized = content.replace("\r\n", "\n");

        // Compute SHA-256 hash
        sha256(&normalized)
    }

    /// Compute combined hash from source hash and dependency hashes
    pub fun compute_cache_key(&self, source_hash: String, dep_hashes: Vec<String>) -> String {
        // Combine source hash with all dependency hashes
        let mut combined = source_hash.clone();

        // Sort dependency hashes for deterministic ordering
        let mut sorted_deps = dep_hashes.clone();
        sorted_deps.sort();

        for dep_hash in sorted_deps {
            combined.push_str(&dep_hash);
        }

        // Hash the combined string
        sha256(&combined)
    }

    /// Hash a list of dependencies (just their paths)
    pub fun hash_dependencies(&self, deps: Vec<String>) -> String {
        let mut combined = String::new();

        // Sort for deterministic ordering
        let mut sorted = deps.clone();
        sorted.sort();

        for dep in sorted {
            combined.push_str(&dep);
            combined.push('\n');
        }

        sha256(&combined)
    }

    /// Get cached hash for a file (used internally)
    fun get_cached_hash(&self, path: &str) -> Result<String, String> {
        // In real implementation, this would look up cached hash
        // For now, we recompute
        let content = fs::read_to_string(path)
            .map_err(|e| format!("Failed to read file: {}", e))?;
        Ok(sha256(&content))
    }

    /// Clear timestamp cache (useful for testing)
    pub fun clear_cache(&mut self) {
        self.timestamp_cache.clear();
    }
}

// ============================================================================
// SHA-256 Implementation
// ============================================================================

/// Compute SHA-256 hash of a string
pub fun sha256(input: &str) -> String {
    // Constants for SHA-256
    const K: [u32; 64] = [
        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
        0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
        0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
        0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
        0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
        0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
        0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
        0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
        0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
    ];

    // Initial hash values (first 32 bits of fractional parts of square roots of first 8 primes)
    let mut h0: u32 = 0x6a09e667;
    let mut h1: u32 = 0xbb67ae85;
    let mut h2: u32 = 0x3c6ef372;
    let mut h3: u32 = 0xa54ff53a;
    let mut h4: u32 = 0x510e527f;
    let mut h5: u32 = 0x9b05688c;
    let mut h6: u32 = 0x1f83d9ab;
    let mut h7: u32 = 0x5be0cd19;

    // Convert input to bytes
    let bytes = input.as_bytes();
    let bit_len = bytes.len() * 8;

    // Prepare message (padding)
    let mut message = bytes.to_vec();
    message.push(0x80); // Append '1' bit

    // Pad with zeros until length â‰¡ 448 (mod 512)
    while (message.len() * 8) % 512 != 448 {
        message.push(0);
    }

    // Append original length as 64-bit big-endian
    message.extend_from_slice(&(bit_len as u64).to_be_bytes());

    // Process message in 512-bit chunks
    for chunk_start in (0..message.len()).step_by(64) {
        let chunk = &message[chunk_start..chunk_start + 64];

        // Create message schedule array
        let mut w = [0u32; 64];

        // Copy chunk into first 16 words
        for i in 0..16 {
            w[i] = u32::from_be_bytes([
                chunk[i * 4],
                chunk[i * 4 + 1],
                chunk[i * 4 + 2],
                chunk[i * 4 + 3],
            ]);
        }

        // Extend first 16 words into remaining 48 words
        for i in 16..64 {
            let s0 = w[i - 15].rotate_right(7) ^ w[i - 15].rotate_right(18) ^ (w[i - 15] >> 3);
            let s1 = w[i - 2].rotate_right(17) ^ w[i - 2].rotate_right(19) ^ (w[i - 2] >> 10);
            w[i] = w[i - 16].wrapping_add(s0).wrapping_add(w[i - 7]).wrapping_add(s1);
        }

        // Initialize working variables
        let mut a = h0;
        let mut b = h1;
        let mut c = h2;
        let mut d = h3;
        let mut e = h4;
        let mut f = h5;
        let mut g = h6;
        let mut h = h7;

        // Main loop
        for i in 0..64 {
            let s1 = e.rotate_right(6) ^ e.rotate_right(11) ^ e.rotate_right(25);
            let ch = (e & f) ^ ((!e) & g);
            let temp1 = h.wrapping_add(s1).wrapping_add(ch).wrapping_add(K[i]).wrapping_add(w[i]);
            let s0 = a.rotate_right(2) ^ a.rotate_right(13) ^ a.rotate_right(22);
            let maj = (a & b) ^ (a & c) ^ (b & c);
            let temp2 = s0.wrapping_add(maj);

            h = g;
            g = f;
            f = e;
            e = d.wrapping_add(temp1);
            d = c;
            c = b;
            b = a;
            a = temp1.wrapping_add(temp2);
        }

        // Add compressed chunk to current hash value
        h0 = h0.wrapping_add(a);
        h1 = h1.wrapping_add(b);
        h2 = h2.wrapping_add(c);
        h3 = h3.wrapping_add(d);
        h4 = h4.wrapping_add(e);
        h5 = h5.wrapping_add(f);
        h6 = h6.wrapping_add(g);
        h7 = h7.wrapping_add(h);
    }

    // Produce final hash value (big-endian)
    format!(
        "{:08x}{:08x}{:08x}{:08x}{:08x}{:08x}{:08x}{:08x}",
        h0, h1, h2, h3, h4, h5, h6, h7
    )
}

// ============================================================================
// Utility Functions
// ============================================================================

/// Check if two hashes match
pub fun hashes_equal(hash1: &str, hash2: &str) -> bool {
    hash1 == hash2
}

/// Verify a file's hash matches expected
pub fun verify_hash(path: &str, expected_hash: &str) -> Result<bool, String> {
    let mut hasher = ContentHasher::new();
    let actual_hash = hasher.hash_file(path)?;
    Ok(hashes_equal(&actual_hash, expected_hash))
}

#[cfg(test)]
mod tests {
    use super::*;

    test test_sha256_basic() {
        let input = "hello world";
        let hash = sha256(input);

        // SHA-256 of "hello world" is known
        let expected = "b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9";
        assert(hash == expected, format!("Expected {}, got {}", expected, hash));
    }

    test test_sha256_empty() {
        let input = "";
        let hash = sha256(input);

        // SHA-256 of empty string is known
        let expected = "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
        assert(hash == expected, format!("Expected {}, got {}", expected, hash));
    }

    test test_content_hasher_deterministic() {
        let hasher = ContentHasher::new();
        let content = "fun main() { println(\"Hello\"); }";

        let hash1 = hasher.hash_content(content);
        let hash2 = hasher.hash_content(content);

        assert(hash1 == hash2, "Hashing should be deterministic");
    }

    test test_cache_key_computation() {
        let hasher = ContentHasher::new();
        let source_hash = "abc123".to_string();
        let dep_hashes = vec!["dep1".to_string(), "dep2".to_string()];

        let key = hasher.compute_cache_key(source_hash, dep_hashes);

        assert(key.len() == 64, "Cache key should be 64 hex characters");
    }

    test test_dependency_hash_ordering() {
        let hasher = ContentHasher::new();

        // Different order, should produce same hash
        let deps1 = vec!["a".to_string(), "b".to_string(), "c".to_string()];
        let deps2 = vec!["c".to_string(), "a".to_string(), "b".to_string()];

        let hash1 = hasher.hash_dependencies(deps1);
        let hash2 = hasher.hash_dependencies(deps2);

        assert(hash1 == hash2, "Dependency hash should be order-independent");
    }
}
