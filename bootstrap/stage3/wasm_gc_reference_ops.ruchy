// WASM-005: WebAssembly GC Reference Type Operations - GREEN Phase Implementation
//
// This file implements operations for WebAssembly GC reference types in the Ruchy compiler,
// enabling proper compilation of reference-based code to WebAssembly with garbage collection.
// It implements type checking operations, type casting, reference equality, reference passing,
// virtual method dispatch, interface method invocation, reference lifecycle, binding/rebinding,
// null handling, and reference subtyping.

// Import reference types implementation
import { 
    WasmRefType, Nullability, WasmRefTypeDescriptor,
    RuchyRefType, RuchyRefTypeField, RuchyRefTypeMethod,
    TypeDescriptor, TypeKind, RefTypeRegistry,
    global_ref_type_registry, field_type_to_wasm,
    compile_ref_type_to_wasm, generate_field_access,
    generate_field_assignment, generate_method_call
} from "./wasm_gc_references.ruchy";

// Import struct and array types implementation
import {
    WasmGCStructType, WasmGCArrayType, generate_struct_type_definition,
    generate_struct_instantiation, generate_struct_field_access,
    generate_struct_field_mutation, generate_struct_method_call
} from "./wasm_gc_structs_arrays.ruchy";

//------------------------------------------------------------------------------
// Type Checking Operations (is, instanceof)
//------------------------------------------------------------------------------

// Compile time context for reference type operations
struct RefOpContext {
    // Current function name
    function_name: string,
    
    // Local variable mapping (name -> local index)
    locals: Map<string, i32>,
    
    // Type information for variables
    variable_types: Map<string, string>,
    
    // Current module context
    module_context: ModuleContext,
    
    // Register a local variable
    fun register_local(name: string, type_name: string) -> i32 {
        let index = this.locals.size();
        this.locals.set(name, index);
        this.variable_types.set(name, type_name);
        return index;
    },
    
    // Get type name for a variable
    fun get_type_for_variable(name: string) -> string {
        return this.variable_types.get(name) || "unknown";
    }
}

// Module context for WebAssembly generation
struct ModuleContext {
    // Current module name
    module_name: string,
    
    // Type registry for the module
    type_registry: RefTypeRegistry,
    
    // Type mapping for expressions
    expr_type_map: Map<string, string>,
    
    // Interface method tables
    interface_methods: Map<string, Map<string, i32>>,
    
    // Set type for an expression
    fun set_expr_type(expr: string, type_name: string) -> void {
        this.expr_type_map.set(expr, type_name);
    },
    
    // Get type for an expression
    fun get_expr_type(expr: string) -> string {
        return this.expr_type_map.get(expr) || "unknown";
    },
    
    // Register an interface method
    fun register_interface_method(interface_name: string, method_name: string, method_index: i32) -> void {
        let methods = this.interface_methods.get(interface_name) || new Map<string, i32>();
        methods.set(method_name, method_index);
        this.interface_methods.set(interface_name, methods);
    },
    
    // Get interface method index
    fun get_interface_method_index(interface_name: string, method_name: string) -> i32 {
        let methods = this.interface_methods.get(interface_name);
        if (methods) {
            return methods.get(method_name) || -1;
        }
        return -1;
    }
}

// Generate WebAssembly code for instanceof operator
fun generate_instanceof_check(ref_expr: string, type_name: string, context: RefOpContext) -> string {
    // Get the source type
    let source_type_name = context.module_context.get_expr_type(ref_expr);
    if (source_type_name == "unknown") {
        // Try to get type from variable
        source_type_name = context.get_type_for_variable(ref_expr);
    }
    
    // If checking against an interface
    let ref_type = global_ref_type_registry.get_type(type_name);
    if (ref_type && ref_type.interface_methods.length > 0) {
        return generate_interface_check(ref_expr, type_name, source_type_name);
    }
    
    // Use ref.test for type test
    return "(ref.test $" + type_name + " " + ref_expr + ")";
}

// Generate WebAssembly code for is operator
fun generate_is_check(ref_expr: string, type_name: string, context: RefOpContext) -> string {
    // 'is' operator is similar to instanceof but used in type predicates
    return generate_instanceof_check(ref_expr, type_name, context);
}

// Generate WebAssembly code for interface check
fun generate_interface_check(ref_expr: string, interface_name: string, source_type_name: string) -> string {
    // Check if the source type implements the interface
    let implements = global_ref_type_registry.implements_interface(source_type_name, interface_name);
    
    // If we know at compile time, return constant
    if (implements) {
        return "(i32.const 1)"; // true
    } else if (source_type_name != "unknown") {
        return "(i32.const 0)"; // false
    }
    
    // Runtime check using dynamic type checking
    // For simplicity, we'll call a helper function
    return "(call $implements_interface " + ref_expr + " (i32.const " + 
           get_type_index(interface_name) + "))";
}

// Get type index from registry
fun get_type_index(type_name: string) -> string {
    let ref_type = global_ref_type_registry.get_type(type_name);
    if (ref_type) {
        return ref_type.wasm_descriptor.type_index.toString();
    }
    return "-1";
}

//------------------------------------------------------------------------------
// Type Casting Operations (as, explicit casts)
//------------------------------------------------------------------------------

// Generate WebAssembly code for as operator
fun generate_as_cast(ref_expr: string, type_name: string, context: RefOpContext) -> string {
    // Get the source type
    let source_type_name = context.module_context.get_expr_type(ref_expr);
    if (source_type_name == "unknown") {
        // Try to get type from variable
        source_type_name = context.get_type_for_variable(ref_expr);
    }
    
    // For interface casts
    let ref_type = global_ref_type_registry.get_type(type_name);
    if (ref_type && ref_type.interface_methods.length > 0) {
        return generate_interface_cast(ref_expr, type_name, source_type_name);
    }
    
    // If upcasting (casting to supertype), no runtime check needed
    if (global_ref_type_registry.is_subtype_of(source_type_name, type_name)) {
        return ref_expr; // No cast needed for upcasts in WebAssembly
    }
    
    // Downcasting - use ref.cast for runtime check
    return "(ref.cast $" + type_name + " " + ref_expr + ")";
}

// Generate WebAssembly code for explicit cast notation (<Type>expr)
fun generate_explicit_cast(type_name: string, ref_expr: string, context: RefOpContext) -> string {
    // Explicit cast notation is the same as 'as' operator
    return generate_as_cast(ref_expr, type_name, context);
}

// Generate WebAssembly code for interface cast
fun generate_interface_cast(ref_expr: string, interface_name: string, source_type_name: string) -> string {
    // Check if the source type implements the interface
    let implements = global_ref_type_registry.implements_interface(source_type_name, interface_name);
    
    // If we know at compile time that it implements
    if (implements) {
        // No actual cast needed, just wrap in interface
        return "(ref.cast_interface $" + interface_name + " " + ref_expr + ")";
    }
    
    // Runtime check with trap on failure
    return "(call $cast_to_interface " + ref_expr + " (i32.const " + 
           get_type_index(interface_name) + "))";
}

//------------------------------------------------------------------------------
// Reference Equality and Comparison
//------------------------------------------------------------------------------

// Generate WebAssembly code for reference equality (===)
fun generate_ref_identity_check(left_expr: string, right_expr: string) -> string {
    // Use ref.eq for identity comparison
    return "(ref.eq " + left_expr + " " + right_expr + ")";
}

// Generate WebAssembly code for reference value equality (==)
fun generate_ref_equality_check(left_expr: string, right_expr: string, context: RefOpContext) -> string {
    // Get types for both expressions
    let left_type = context.module_context.get_expr_type(left_expr);
    let right_type = context.module_context.get_expr_type(right_expr);
    
    // If one side is null
    if (left_expr == "null" || right_expr == "null") {
        // Null equality is identity check
        return generate_ref_identity_check(left_expr, right_expr);
    }
    
    // If both types are the same and have equals method, use it
    if (left_type == right_type) {
        let ref_type = global_ref_type_registry.get_type(left_type);
        
        if (ref_type) {
            // Check if type has equals method
            for (let method of ref_type.methods) {
                if (method.name == "equals") {
                    // Call equals method
                    return generate_method_call(left_expr, left_type, "equals", [right_expr]);
                }
            }
        }
    }
    
    // Default to reference identity
    return generate_ref_identity_check(left_expr, right_expr);
}

// Generate WebAssembly code for null check
fun generate_null_check(ref_expr: string) -> string {
    // Check if reference is null
    return "(ref.is_null " + ref_expr + ")";
}

// Generate WebAssembly code for not-null check
fun generate_not_null_check(ref_expr: string) -> string {
    // Check if reference is not null
    return "(i32.eqz (ref.is_null " + ref_expr + "))";
}

//------------------------------------------------------------------------------
// Reference Passing Semantics
//------------------------------------------------------------------------------

// Generate WebAssembly code for passing reference to function
fun generate_ref_function_arg(ref_expr: string, param_type: string, context: RefOpContext) -> string {
    // Get the source type
    let source_type = context.module_context.get_expr_type(ref_expr);
    
    // For references, just pass the reference directly
    // No special handling needed for WebAssembly GC
    
    // If needed, add a cast for safety
    if (source_type != param_type && source_type != "unknown") {
        // Check if cast is needed (subtype to supertype is safe)
        if (!global_ref_type_registry.is_subtype_of(source_type, param_type)) {
            return "(ref.cast $" + param_type + " " + ref_expr + ")";
        }
    }
    
    return ref_expr;
}

// Generate WebAssembly code for returning reference from function
fun generate_ref_function_return(ref_expr: string, return_type: string, context: RefOpContext) -> string {
    // Get the source type
    let source_type = context.module_context.get_expr_type(ref_expr);
    
    // For references, just return the reference directly
    // No special handling needed for WebAssembly GC
    
    // If needed, add a cast for safety
    if (source_type != return_type && source_type != "unknown") {
        // Check if cast is needed (subtype to supertype is safe)
        if (!global_ref_type_registry.is_subtype_of(source_type, return_type)) {
            return "(ref.cast $" + return_type + " " + ref_expr + ")";
        }
    }
    
    return ref_expr;
}

//------------------------------------------------------------------------------
// Virtual Method Dispatch
//------------------------------------------------------------------------------

// Generate WebAssembly code for virtual method dispatch
fun generate_virtual_method_dispatch(ref_expr: string, method_name: string, args: string[], context: RefOpContext) -> string {
    // Get the reference type
    let type_name = context.module_context.get_expr_type(ref_expr);
    if (type_name == "unknown") {
        // Try to get type from variable
        type_name = context.get_type_for_variable(ref_expr);
    }
    
    let ref_type = global_ref_type_registry.get_type(type_name);
    if (!ref_type) {
        return "(;Unknown type for virtual method dispatch;)";
    }
    
    // Find method
    let method_index = -1;
    let method = null;
    for (let i = 0; i < ref_type.methods.length; i++) {
        if (ref_type.methods[i].name == method_name) {
            method_index = i;
            method = ref_type.methods[i];
            break;
        }
    }
    
    if (method_index == -1 || !method) {
        return "(;Unknown method: " + method_name + ";)";
    }
    
    if (method.virtual) {
        // Generate virtual method call using vtable
        return generate_vtable_method_call(ref_expr, type_name, method, method_index, args);
    } else {
        // Generate direct method call
        return generate_method_call(ref_expr, type_name, method_name, args);
    }
}

// Generate WebAssembly code for vtable method call
fun generate_vtable_method_call(ref_expr: string, type_name: string, method: RuchyRefTypeMethod, method_index: i32, args: string[]) -> string {
    // WebAssembly doesn't have direct vtable support, so we implement it manually
    // In real implementation, this would be more sophisticated
    
    // Get virtual method index
    let virtual_index = method.override_index;
    if (virtual_index < 0) {
        // Not a virtual method or not overridden
        return generate_method_call(ref_expr, type_name, method.name, args);
    }
    
    // For WebAssembly, we use call_indirect with type check
    let result = "(call_indirect (type $" + type_name + "_" + method.name + ") ";
    
    // Add self parameter
    result += ref_expr + " ";
    
    // Add other arguments
    for (let arg of args) {
        result += arg + " ";
    }
    
    // Add function table index
    // This would use a table of function references in real implementation
    result += "(call $get_virtual_method " + ref_expr + " (i32.const " + virtual_index.toString() + "))";
    
    result += ")";
    return result;
}

//------------------------------------------------------------------------------
// Interface Method Invocation
//------------------------------------------------------------------------------

// Generate WebAssembly code for interface method call
fun generate_interface_method_call(ref_expr: string, interface_name: string, method_name: string, args: string[], context: RefOpContext) -> string {
    // Get interface method index
    let method_index = context.module_context.get_interface_method_index(interface_name, method_name);
    if (method_index < 0) {
        // Try to find method in interface definition
        let interface_type = global_ref_type_registry.get_type(interface_name);
        if (interface_type) {
            for (let i = 0; i < interface_type.interface_methods.length; i++) {
                if (interface_type.interface_methods[i].name == method_name) {
                    method_index = i;
                    break;
                }
            }
        }
    }
    
    if (method_index < 0) {
        return "(;Unknown interface method: " + method_name + ";)";
    }
    
    // For WebAssembly, we use call_indirect with interface type check
    let result = "(call_indirect (type $" + interface_name + "_" + method_name + ") ";
    
    // Add self parameter
    result += ref_expr + " ";
    
    // Add other arguments
    for (let arg of args) {
        result += arg + " ";
    }
    
    // Add function table index
    // This would use interface method table in real implementation
    result += "(call $get_interface_method " + ref_expr + " (i32.const " + 
              get_type_index(interface_name) + ") (i32.const " + method_index.toString() + "))";
    
    result += ")";
    return result;
}

//------------------------------------------------------------------------------
// Reference Lifecycle Events
//------------------------------------------------------------------------------

// Generate WebAssembly code for constructor call
fun generate_constructor_call(type_name: string, args: string[], context: RefOpContext) -> string {
    let ref_type = global_ref_type_registry.get_type(type_name);
    if (!ref_type) {
        return "(;Unknown type for constructor;)";
    }
    
    // In WebAssembly GC, we need to:
    // 1. Create the struct
    // 2. Call constructor method
    
    // First, create an instance with default values
    let default_values: string[] = [];
    
    // Create default values for all fields
    for (let field of ref_type.fields) {
        default_values.push(generate_default_value(field.type_descriptor));
    }
    
    // Generate struct instantiation
    let instance_expr = "(struct.new $" + type_name;
    for (let value of default_values) {
        instance_expr += " " + value;
    }
    instance_expr += ")";
    
    // If there are constructor args, call constructor method
    if (args.length > 0) {
        // Register a local to store the instance
        let local_index = context.register_local("__tmp_instance", type_name);
        
        // Call constructor on the instance
        let constructor_call = "(local.set " + local_index.toString() + " " + instance_expr + ") ";
        constructor_call += generate_method_call("(local.get " + local_index.toString() + ")", 
                                               type_name, "constructor", args);
        constructor_call += " (local.get " + local_index.toString() + ")";
        
        return constructor_call;
    }
    
    return instance_expr;
}

// Generate WebAssembly code for finalizer support
fun generate_finalizer_support(type_name: string, context: RefOpContext) -> string {
    // WebAssembly GC doesn't directly support finalizers
    // In a real implementation, this would register the object for cleanup
    
    // For now, we'll assume that finalizers are implemented as methods
    // that are called manually before object destruction
    
    // Check if type has a finalizer method
    let ref_type = global_ref_type_registry.get_type(type_name);
    if (ref_type) {
        for (let method of ref_type.methods) {
            if (method.name == "finalize") {
                // Generate method to call the finalizer
                let wasm_code = `
                    (func $${type_name}_register_finalizer (param $obj (ref $${type_name}))
                        ;; In a real implementation, we would register this object
                        ;; for cleanup when it becomes unreachable
                        (nop)
                    )
                `;
                
                return wasm_code;
            }
        }
    }
    
    return ""; // No finalizer found
}

// Generate default value for a type descriptor
fun generate_default_value(type_desc: TypeDescriptor) -> string {
    switch (type_desc.kind) {
        case TypeKind.Primitive:
            // Default values for primitive types
            return "(i32.const 0)"; // Most primitives default to 0
            
        case TypeKind.Reference:
            // Default value for reference types is null
            if (type_desc.ref_type) {
                return "(ref.null $" + type_desc.ref_type.name + ")";
            }
            return "(ref.null extern)"; // Generic external reference
            
        case TypeKind.Array:
            // Default value for array types is null
            return "(ref.null array)";
            
        case TypeKind.Function:
            // Default value for function types is null
            return "(ref.null func)";
            
        default:
            // Default for other types
            return "(i32.const 0)";
    }
}

//------------------------------------------------------------------------------
// Reference Binding and Rebinding
//------------------------------------------------------------------------------

// Generate WebAssembly code for reference binding (assignment)
fun generate_ref_binding(var_name: string, ref_expr: string, context: RefOpContext) -> string {
    // Get local index for variable
    let local_index = context.locals.get(var_name);
    if (local_index === undefined) {
        // Register new local if not found
        let type_name = context.module_context.get_expr_type(ref_expr);
        local_index = context.register_local(var_name, type_name);
    }
    
    // Set local variable to reference
    return "(local.set " + local_index.toString() + " " + ref_expr + ")";
}

// Generate WebAssembly code for reference rebinding (reassignment)
fun generate_ref_rebinding(var_name: string, ref_expr: string, context: RefOpContext) -> string {
    // For references, binding and rebinding are the same in WebAssembly
    return generate_ref_binding(var_name, ref_expr, context);
}

// Generate WebAssembly code for reference field rebinding
fun generate_ref_field_rebinding(ref_expr: string, field_name: string, value_expr: string, context: RefOpContext) -> string {
    // Get the reference type
    let type_name = context.module_context.get_expr_type(ref_expr);
    if (type_name == "unknown") {
        // Try to get type from variable
        type_name = context.get_type_for_variable(ref_expr);
    }
    
    // Generate field assignment
    return generate_field_assignment(ref_expr, type_name, field_name, value_expr);
}

// Generate WebAssembly code for generic parameter binding
fun generate_generic_binding(type_param: string, actual_type: string, context: RefOpContext) -> string {
    // In WebAssembly, generics are handled at compile time with monomorphization
    // No runtime code needed for this
    return "";
}

//------------------------------------------------------------------------------
// Null Handling and Optional References
//------------------------------------------------------------------------------

// Generate WebAssembly code for null check with early return
fun generate_null_guard(ref_expr: string, return_expr: string) -> string {
    return `
        (if (ref.is_null ${ref_expr})
            (then
                ${return_expr}
            )
        )
    `;
}

// Generate WebAssembly code for optional unwrapping (getting value from optional)
fun generate_optional_unwrap(opt_expr: string, context: RefOpContext) -> string {
    // Get the optional type
    let type_name = context.module_context.get_expr_type(opt_expr);
    if (type_name == "unknown") {
        // Try to get type from variable
        type_name = context.get_type_for_variable(opt_expr);
    }
    
    // In a real implementation, we'd need to know if this is an Optional<T> type
    // and extract the T value with proper null checking
    
    // Check for null
    let result = `
        (if (ref.is_null ${opt_expr})
            (then
                (call $throw_null_error)
                (ref.null extern) ;; Default return value after trap
            )
            (else
                ;; For Optional<T>, we'd access the value field
                ${opt_expr}
            )
        )
    `;
    
    return result;
}

// Generate WebAssembly code for conditional unwrapping (value ?? default)
fun generate_null_coalesce(opt_expr: string, default_expr: string, context: RefOpContext) -> string {
    // Get the optional type
    let type_name = context.module_context.get_expr_type(opt_expr);
    if (type_name == "unknown") {
        // Try to get type from variable
        type_name = context.get_type_for_variable(opt_expr);
    }
    
    // Ternary check for null
    let result = `
        (if (ref.is_null ${opt_expr})
            (then
                ${default_expr}
            )
            (else
                ${opt_expr}
            )
        )
    `;
    
    return result;
}

// Generate WebAssembly code for optional chaining (obj?.field)
fun generate_optional_chaining(ref_expr: string, field_access: string, context: RefOpContext) -> string {
    // Get the reference type
    let type_name = context.module_context.get_expr_type(ref_expr);
    if (type_name == "unknown") {
        // Try to get type from variable
        type_name = context.get_type_for_variable(ref_expr);
    }
    
    // Parse field access - could be a field, method call, etc.
    // For simplicity, we'll assume it's a field access
    
    // Get expected result type
    let result_type = ""; // This would need proper type inference
    
    // Ternary check for null
    let result = `
        (if (ref.is_null ${ref_expr})
            (then
                (ref.null extern) ;; Return null
            )
            (else
                ${generate_field_access(ref_expr, type_name, field_access)}
            )
        )
    `;
    
    return result;
}

//------------------------------------------------------------------------------
// Reference Subtyping and Covariance
//------------------------------------------------------------------------------

// Generate WebAssembly code for array covariance
fun generate_array_covariance(array_expr: string, target_type: string, context: RefOpContext) -> string {
    // Get the array type
    let source_type = context.module_context.get_expr_type(array_expr);
    if (source_type == "unknown") {
        // Try to get type from variable
        source_type = context.get_type_for_variable(array_expr);
    }
    
    // In WebAssembly, we need a runtime cast for array covariance
    // Since WebAssembly doesn't directly support covariance
    
    // For now, we'll generate a helper function call
    return "(call $cast_array " + array_expr + " (i32.const " + 
           get_type_index(target_type) + "))";
}

// Generate WebAssembly code for covariant return types
fun generate_covariant_return(method_call: string, source_type: string, target_type: string, context: RefOpContext) -> string {
    // Check if target type is a supertype of source type
    if (global_ref_type_registry.is_subtype_of(source_type, target_type)) {
        // No cast needed for covariant return
        return method_call;
    }
    
    // Otherwise, we need a cast
    return "(ref.cast $" + target_type + " " + method_call + ")";
}

//------------------------------------------------------------------------------
// Complex Operations Integration
//------------------------------------------------------------------------------

// Generate WebAssembly code for visitor pattern dispatch
fun generate_visitor_pattern_dispatch(ref_expr: string, visitor_expr: string, context: RefOpContext) -> string {
    // Get types
    let ref_type_name = context.module_context.get_expr_type(ref_expr);
    let visitor_type_name = context.module_context.get_expr_type(visitor_expr);
    
    // In a real implementation, we'd need to know the visitor interface
    // and generate appropriate method call
    
    // For now, assume "accept" method that takes visitor
    return generate_method_call(ref_expr, ref_type_name, "accept", [visitor_expr]);
}

// Generate WebAssembly code for double dispatch
fun generate_double_dispatch(left_expr: string, right_expr: string, operation: string, context: RefOpContext) -> string {
    // Get types
    let left_type = context.module_context.get_expr_type(left_expr);
    let right_type = context.module_context.get_expr_type(right_expr);
    
    // In double dispatch, left object's method is called with right object
    // For example: left.operation(right)
    
    return generate_method_call(left_expr, left_type, operation, [right_expr]);
}

// Generate WebAssembly code for abstract factory pattern
fun generate_abstract_factory(factory_expr: string, product_type: string, args: string[], context: RefOpContext) -> string {
    // Get factory type
    let factory_type = context.module_context.get_expr_type(factory_expr);
    
    // Factory pattern typically calls a create method
    return generate_method_call(factory_expr, factory_type, "create" + product_type, args);
}

//------------------------------------------------------------------------------
// External Interface Integration
//------------------------------------------------------------------------------

// Generate WebAssembly code for exporting reference types to JavaScript
fun generate_js_ref_export(type_name: string) -> string {
    let ref_type = global_ref_type_registry.get_type(type_name);
    if (!ref_type) {
        return "(;Unknown type for export;)";
    }
    
    // Export type
    let result = `
        (export "${type_name}" (type $${type_name}))
    `;
    
    // Export constructor
    result += `
        (export "${type_name}_new" (func $${type_name}_new))
    `;
    
    // Export methods
    for (let method of ref_type.methods) {
        result += `
            (export "${type_name}_${method.name}" (func $${type_name}_${method.name}))
        `;
    }
    
    return result;
}

// Generate WebAssembly code for importing reference types from JavaScript
fun generate_js_ref_import(type_name: string) -> string {
    // Import type
    let result = `
        (import "js" "${type_name}" (type $${type_name}))
    `;
    
    // Import constructor
    result += `
        (import "js" "${type_name}_new" (func $${type_name}_new (result (ref $${type_name}))))
    `;
    
    // In a real implementation, we'd import methods as well
    
    return result;
}

//------------------------------------------------------------------------------
// Runtime Type Information
//------------------------------------------------------------------------------

// Generate WebAssembly code for runtime type information access
fun generate_type_info_access(type_name: string) -> string {
    let ref_type = global_ref_type_registry.get_type(type_name);
    if (!ref_type) {
        return "(;Unknown type for RTTI;)";
    }
    
    // In a real implementation, we'd generate a type info structure
    // with information about the type hierarchy, methods, etc.
    
    // For now, just return type index
    return "(i32.const " + ref_type.wasm_descriptor.type_index.toString() + ")";
}

// Generate WebAssembly code for dynamic type name access
fun generate_type_name_access(ref_expr: string, context: RefOpContext) -> string {
    // In a real implementation, we'd store type names in a table
    // and look them up based on runtime type
    
    // For now, call a helper function
    return "(call $get_type_name " + ref_expr + ")";
}

//------------------------------------------------------------------------------
// Support Functions for WebAssembly Module
//------------------------------------------------------------------------------

// Generate WebAssembly helper functions for reference operations
fun generate_reference_helper_functions() -> string {
    // In a real implementation, we'd generate a set of helper functions
    // to support reference operations at runtime
    
    // Here's a simplified version of some key helper functions
    let helpers = `
        ;; Helper function to check if a type implements an interface
        (func $implements_interface (param $obj anyref) (param $interface_id i32) (result i32)
            (local $type_id i32)
            (local.set $type_id (call $get_type_id $obj))
            (call $check_interface_implementation $type_id $interface_id)
        )
        
        ;; Helper function to cast to an interface
        (func $cast_to_interface (param $obj anyref) (param $interface_id i32) (result anyref)
            (local $implements i32)
            (local.set $implements (call $implements_interface $obj $interface_id))
            (if (i32.eqz $implements)
                (then
                    (call $throw_cast_error)
                    (ref.null extern)  ;; Default return after trap
                )
                (else
                    $obj  ;; No actual cast needed in WebAssembly
                )
            )
        )
        
        ;; Helper function to get virtual method
        (func $get_virtual_method (param $obj anyref) (param $method_idx i32) (result funcref)
            ;; In a real implementation, this would access the object's vtable
            ;; For now, just return a placeholder
            (ref.null func)
        )
        
        ;; Helper function to get interface method
        (func $get_interface_method (param $obj anyref) (param $interface_id i32) (param $method_idx i32) (result funcref)
            ;; In a real implementation, this would look up the method implementation
            ;; For now, just return a placeholder
            (ref.null func)
        )
        
        ;; Helper function to throw null error
        (func $throw_null_error
            ;; In a real implementation, this would trap with an error message
            (unreachable)
        )
        
        ;; Helper function to throw cast error
        (func $throw_cast_error
            ;; In a real implementation, this would trap with an error message
            (unreachable)
        )
        
        ;; Helper function to get type ID
        (func $get_type_id (param $obj anyref) (result i32)
            ;; In a real implementation, this would get the runtime type ID
            ;; For now, just return a placeholder
            (i32.const -1)
        )
        
        ;; Helper function to check interface implementation
        (func $check_interface_implementation (param $type_id i32) (param $interface_id i32) (result i32)
            ;; In a real implementation, this would check the type hierarchy
            ;; For now, just return a placeholder
            (i32.const 0)
        )
        
        ;; Helper function to cast array for covariance
        (func $cast_array (param $array anyref) (param $target_type_id i32) (result anyref)
            ;; In a real implementation, this would validate the cast
            ;; For now, just return the array
            $array
        )
        
        ;; Helper function to get type name
        (func $get_type_name (param $obj anyref) (result anyref)
            ;; In a real implementation, this would return the type name
            ;; For now, just return a placeholder
            (ref.null extern)
        )
    `;
    
    return helpers;
}

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

// Public interface for reference type operations
struct WasmGCReferenceOps {
    // Context for the current compilation
    context: RefOpContext,
    
    // Initialize with a module context
    fun initialize(module_name: string) -> void {
        this.context = RefOpContext {
            function_name: "main",
            locals: new Map<string, i32>(),
            variable_types: new Map<string, string>(),
            module_context: ModuleContext {
                module_name: module_name,
                type_registry: global_ref_type_registry,
                expr_type_map: new Map<string, string>(),
                interface_methods: new Map<string, Map<string, i32>>()
            }
        };
    },
    
    // Generate instance check
    fun generate_instance_check(ref_expr: string, type_name: string) -> string {
        return generate_instanceof_check(ref_expr, type_name, this.context);
    },
    
    // Generate type cast
    fun generate_cast(ref_expr: string, type_name: string) -> string {
        return generate_as_cast(ref_expr, type_name, this.context);
    },
    
    // Generate reference equality check
    fun generate_equality(left_expr: string, right_expr: string) -> string {
        return generate_ref_equality_check(left_expr, right_expr, this.context);
    },
    
    // Generate reference identity check
    fun generate_identity(left_expr: string, right_expr: string) -> string {
        return generate_ref_identity_check(left_expr, right_expr);
    },
    
    // Generate method call
    fun generate_method_call(ref_expr: string, type_name: string, method_name: string, args: string[]) -> string {
        if (is_virtual_method(type_name, method_name)) {
            return generate_virtual_method_dispatch(ref_expr, method_name, args, this.context);
        } else {
            return generate_method_call(ref_expr, type_name, method_name, args);
        }
    },
    
    // Generate constructor call
    fun generate_new(type_name: string, args: string[]) -> string {
        return generate_constructor_call(type_name, args, this.context);
    },
    
    // Generate field access
    fun generate_field_get(ref_expr: string, type_name: string, field_name: string) -> string {
        return generate_field_access(ref_expr, type_name, field_name);
    },
    
    // Generate field assignment
    fun generate_field_set(ref_expr: string, type_name: string, field_name: string, value_expr: string) -> string {
        return generate_field_assignment(ref_expr, type_name, field_name, value_expr);
    },
    
    // Generate null check
    fun generate_null_check(ref_expr: string) -> string {
        return generate_null_check(ref_expr);
    },
    
    // Generate helper functions
    fun generate_helpers() -> string {
        return generate_reference_helper_functions();
    },
    
    // Set type for expression
    fun set_expr_type(expr: string, type_name: string) -> void {
        this.context.module_context.set_expr_type(expr, type_name);
    },
    
    // Register local variable
    fun register_local(name: string, type_name: string) -> i32 {
        return this.context.register_local(name, type_name);
    }
};

// Check if a method is virtual
fun is_virtual_method(type_name: string, method_name: string) -> boolean {
    let ref_type = global_ref_type_registry.get_type(type_name);
    if (!ref_type) {
        return false;
    }
    
    for (let method of ref_type.methods) {
        if (method.name == method_name) {
            return method.virtual;
        }
    }
    
    return false;
}

// Global instance of reference operations
let gc_reference_ops = WasmGCReferenceOps {
    context: null
};

// Initialize the reference operations
fun init_reference_ops() -> void {
    gc_reference_ops.initialize("main");
}

// Call initialization
init_reference_ops();

// Export public interface
export {
    gc_reference_ops,
    generate_instanceof_check,
    generate_is_check,
    generate_as_cast,
    generate_explicit_cast,
    generate_ref_identity_check,
    generate_ref_equality_check,
    generate_null_check,
    generate_ref_function_arg,
    generate_ref_function_return,
    generate_virtual_method_dispatch,
    generate_interface_method_call,
    generate_constructor_call,
    generate_ref_binding,
    generate_ref_rebinding,
    generate_null_coalesce,
    generate_optional_chaining,
    generate_array_covariance
};

// Public exports
fun main() -> void {
    print("WebAssembly GC Reference Type Operations Support");
    print("This module implements comprehensive reference type operations for WebAssembly GC.");
}