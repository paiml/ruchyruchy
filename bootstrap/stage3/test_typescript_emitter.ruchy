// BOOTSTRAP-014: TypeScript Code Emitter (RED Phase)
// Test-driven development: Write failing tests first
//
// This ticket implements AST to TypeScript code generation.
// The emitter produces idiomatic TypeScript with proper type annotations.

// Expression AST (from previous stages)
enum Expr {
    EInt(i32),
    EBool(bool),
    EString(String),
    EVar(String),
    EBinOp(String, Box<Expr>, Box<Expr>),
    ELam(String, Box<Expr>),
    EApp(Box<Expr>, Box<Expr>),
    ELet(String, Box<Expr>, Box<Expr>)
}

// Statement AST
enum Stmt {
    SExpr(Expr),
    SLet(String, Expr),
    SFun(String, String, Expr)
}

// Placeholder for TypeScript emitter
fun emit_expr_ts(expr: Expr) -> String {
    "NOT_IMPLEMENTED".to_string()
}

fun emit_stmt_ts(stmt: Stmt) -> String {
    "NOT_IMPLEMENTED".to_string()
}

// RED Phase Tests

// Test 1: Emit integer literal
fun test_emit_int() -> bool {
    println("Test: Emit integer literal");

    let expr = Expr::EInt(42);
    let result = emit_expr_ts(expr);

    if result == "42" {
        println("  ‚úÖ PASS");
        true
    } else {
        println("  ‚ùå FAIL: Expected '42', got '{}'", result);
        false
    }
}

// Test 2: Emit boolean literal
fun test_emit_bool() -> bool {
    println("Test: Emit boolean literal");

    let expr = Expr::EBool(true);
    let result = emit_expr_ts(expr);

    if result == "true" {
        println("  ‚úÖ PASS");
        true
    } else {
        println("  ‚ùå FAIL: Expected 'true', got '{}'", result);
        false
    }
}

// Test 3: Emit string literal
fun test_emit_string() -> bool {
    println("Test: Emit string literal");

    let expr = Expr::EString("hello".to_string());
    let result = emit_expr_ts(expr);

    if result == "\"hello\"" {
        println("  ‚úÖ PASS");
        true
    } else {
        println("  ‚ùå FAIL: Expected '\"hello\"', got '{}'", result);
        false
    }
}

// Test 4: Emit variable
fun test_emit_var() -> bool {
    println("Test: Emit variable");

    let expr = Expr::EVar("x".to_string());
    let result = emit_expr_ts(expr);

    if result == "x" {
        println("  ‚úÖ PASS");
        true
    } else {
        println("  ‚ùå FAIL: Expected 'x', got '{}'", result);
        false
    }
}

// Test 5: Emit binary operation
fun test_emit_binop() -> bool {
    println("Test: Emit binary operation");

    // 1 + 2
    let expr = Expr::EBinOp(
        "+".to_string(),
        Box::new(Expr::EInt(1)),
        Box::new(Expr::EInt(2))
    );
    let result = emit_expr_ts(expr);

    if result == "(1 + 2)" {
        println("  ‚úÖ PASS");
        true
    } else {
        println("  ‚ùå FAIL: Expected '(1 + 2)', got '{}'", result);
        false
    }
}

// Test 6: Emit lambda (arrow function)
fun test_emit_lambda() -> bool {
    println("Test: Emit lambda (arrow function)");

    // Œªx. x => (x) => x
    let expr = Expr::ELam(
        "x".to_string(),
        Box::new(Expr::EVar("x".to_string()))
    );
    let result = emit_expr_ts(expr);

    if result == "(x) => x" {
        println("  ‚úÖ PASS");
        true
    } else {
        println("  ‚ùå FAIL: Expected '(x) => x', got '{}'", result);
        false
    }
}

// Test 7: Emit function application
fun test_emit_app() -> bool {
    println("Test: Emit function application");

    // f(x)
    let expr = Expr::EApp(
        Box::new(Expr::EVar("f".to_string())),
        Box::new(Expr::EVar("x".to_string()))
    );
    let result = emit_expr_ts(expr);

    if result == "f(x)" {
        println("  ‚úÖ PASS");
        true
    } else {
        println("  ‚ùå FAIL: Expected 'f(x)', got '{}'", result);
        false
    }
}

// Test 8: Emit let statement
fun test_emit_let_stmt() -> bool {
    println("Test: Emit let statement");

    let stmt = Stmt::SLet("x".to_string(), Expr::EInt(42));
    let result = emit_stmt_ts(stmt);

    if result == "const x = 42;" {
        println("  ‚úÖ PASS");
        true
    } else {
        println("  ‚ùå FAIL: Expected 'const x = 42;', got '{}'", result);
        false
    }
}

// Test 9: Emit function declaration
fun test_emit_fun_decl() -> bool {
    println("Test: Emit function declaration");

    // fun id(x) = x => const id = (x) => x;
    let stmt = Stmt::SFun(
        "id".to_string(),
        "x".to_string(),
        Expr::EVar("x".to_string())
    );
    let result = emit_stmt_ts(stmt);

    if result == "const id = (x) => x;" {
        println("  ‚úÖ PASS");
        true
    } else {
        println("  ‚ùå FAIL: Expected 'const id = (x) => x;', got '{}'", result);
        false
    }
}

// Test 10: Emit nested expression
fun test_emit_nested() -> bool {
    println("Test: Emit nested expression");

    // (1 + 2) + 3
    let inner = Expr::EBinOp(
        "+".to_string(),
        Box::new(Expr::EInt(1)),
        Box::new(Expr::EInt(2))
    );
    let expr = Expr::EBinOp(
        "+".to_string(),
        Box::new(inner),
        Box::new(Expr::EInt(3))
    );
    let result = emit_expr_ts(expr);

    if result == "((1 + 2) + 3)" {
        println("  ‚úÖ PASS");
        true
    } else {
        println("  ‚ùå FAIL: Expected '((1 + 2) + 3)', got '{}'", result);
        false
    }
}

fun main() {
    println("üî¥ BOOTSTRAP-014: TypeScript Code Emitter (RED Phase)");
    println("====================================================");
    println("");
    println("Writing failing tests for TypeScript emission");
    println("");

    let mut passed = 0;
    let mut failed = 0;

    if test_emit_int() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_emit_bool() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_emit_string() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_emit_var() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_emit_binop() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_emit_lambda() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_emit_app() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_emit_let_stmt() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_emit_fun_decl() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_emit_nested() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    println("");
    println("üìä RED Phase Test Results:");
    println("Total tests: {}", passed + failed);
    println("Passed: {}", passed);
    println("Failed: {}", failed);
    println("");

    if failed > 0 {
        println("üî¥ RED: Tests failing as expected (TDD)");
        println("Next: Implement TypeScript emitter in GREEN phase");
    } else {
        println("‚ö†Ô∏è  WARNING: Tests should fail in RED phase!");
    }
}

main();
