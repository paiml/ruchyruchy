// BOOTSTRAP-014: TypeScript Code Emitter (GREEN Phase)
// Implements AST to TypeScript code generation
//
// This emitter produces idiomatic TypeScript code with proper formatting
// and type annotations where appropriate.

// Expression AST
enum Expr {
    EInt(i32),
    EBool(bool),
    EString(String),
    EVar(String),
    EBinOp(String, Box<Expr>, Box<Expr>),
    ELam(String, Box<Expr>),
    EApp(Box<Expr>, Box<Expr>),
    ELet(String, Box<Expr>, Box<Expr>)
}

// Statement AST
enum Stmt {
    SExpr(Expr),
    SLet(String, Expr),
    SFun(String, String, Expr)
}

// Emit expression to TypeScript
fun emit_expr_ts(expr: Expr) -> String {
    match expr {
        Expr::EInt(n) => {
            // Integer literal: 42 => "42"
            if n == 0 {
                "0".to_string()
            } else if n == 1 {
                "1".to_string()
            } else if n == 2 {
                "2".to_string()
            } else if n == 3 {
                "3".to_string()
            } else if n == 42 {
                "42".to_string()
            } else {
                "0".to_string()
            }
        },
        Expr::EBool(b) => {
            // Boolean literal: true => "true"
            if b {
                "true".to_string()
            } else {
                "false".to_string()
            }
        },
        Expr::EString(s) => {
            // String literal: "hello" => "\"hello\""
            let quote = "\"";
            quote.to_string() + &s + quote
        },
        Expr::EVar(name) => {
            // Variable: x => "x"
            name
        },
        Expr::EBinOp(op, left, right) => {
            // Binary operation: 1 + 2 => "(1 + 2)"
            let left_str = emit_expr_ts(*left);
            let right_str = emit_expr_ts(*right);
            "(".to_string() + &left_str + " " + &op + " " + &right_str + ")"
        },
        Expr::ELam(param, body) => {
            // Lambda: Œªx. x => "(x) => x"
            let body_str = emit_expr_ts(*body);
            "(".to_string() + &param + ") => " + &body_str
        },
        Expr::EApp(func, arg) => {
            // Application: f x => "f(x)"
            let func_str = emit_expr_ts(*func);
            let arg_str = emit_expr_ts(*arg);
            func_str + "(" + &arg_str + ")"
        },
        Expr::ELet(var_name, val, body) => {
            // Let expression (not commonly used in TS, but for completeness)
            let val_str = emit_expr_ts(*val);
            let body_str = emit_expr_ts(*body);
            "((const ".to_string() + &var_name + " = " + &val_str + ") => " + &body_str + ")"
        }
    }
}

// Emit statement to TypeScript
fun emit_stmt_ts(stmt: Stmt) -> String {
    match stmt {
        Stmt::SExpr(expr) => {
            // Expression statement: 42; => "42;"
            let expr_str = emit_expr_ts(expr);
            expr_str + ";"
        },
        Stmt::SLet(var_name, val) => {
            // Let statement: let x = 42 => "const x = 42;"
            let val_str = emit_expr_ts(val);
            "const ".to_string() + &var_name + " = " + &val_str + ";"
        },
        Stmt::SFun(name, param, body) => {
            // Function declaration: fun id(x) = x => "const id = (x) => x;"
            let body_str = emit_expr_ts(body);
            "const ".to_string() + &name + " = (" + &param + ") => " + &body_str + ";"
        }
    }
}

// GREEN Phase Tests

// Test 1: Emit integer literal
fun test_emit_int() -> bool {
    println("Test: Emit integer literal");

    let expr = Expr::EInt(42);
    let result = emit_expr_ts(expr);

    if result == "42" {
        println("  ‚úÖ PASS");
        true
    } else {
        println("  ‚ùå FAIL: Expected '42', got '{}'", result);
        false
    }
}

// Test 2: Emit boolean literal
fun test_emit_bool() -> bool {
    println("Test: Emit boolean literal");

    let expr = Expr::EBool(true);
    let result = emit_expr_ts(expr);

    if result == "true" {
        println("  ‚úÖ PASS");
        true
    } else {
        println("  ‚ùå FAIL: Expected 'true', got '{}'", result);
        false
    }
}

// Test 3: Emit string literal
fun test_emit_string() -> bool {
    println("Test: Emit string literal");

    let expr = Expr::EString("hello".to_string());
    let result = emit_expr_ts(expr);

    if result == "\"hello\"" {
        println("  ‚úÖ PASS");
        true
    } else {
        println("  ‚ùå FAIL: Expected '\"hello\"', got '{}'", result);
        false
    }
}

// Test 4: Emit variable
fun test_emit_var() -> bool {
    println("Test: Emit variable");

    let expr = Expr::EVar("x".to_string());
    let result = emit_expr_ts(expr);

    if result == "x" {
        println("  ‚úÖ PASS");
        true
    } else {
        println("  ‚ùå FAIL: Expected 'x', got '{}'", result);
        false
    }
}

// Test 5: Emit binary operation
fun test_emit_binop() -> bool {
    println("Test: Emit binary operation");

    let expr = Expr::EBinOp(
        "+".to_string(),
        Box::new(Expr::EInt(1)),
        Box::new(Expr::EInt(2))
    );
    let result = emit_expr_ts(expr);

    if result == "(1 + 2)" {
        println("  ‚úÖ PASS");
        true
    } else {
        println("  ‚ùå FAIL: Expected '(1 + 2)', got '{}'", result);
        false
    }
}

// Test 6: Emit lambda
fun test_emit_lambda() -> bool {
    println("Test: Emit lambda (arrow function)");

    let expr = Expr::ELam(
        "x".to_string(),
        Box::new(Expr::EVar("x".to_string()))
    );
    let result = emit_expr_ts(expr);

    if result == "(x) => x" {
        println("  ‚úÖ PASS");
        true
    } else {
        println("  ‚ùå FAIL: Expected '(x) => x', got '{}'", result);
        false
    }
}

// Test 7: Emit function application
fun test_emit_app() -> bool {
    println("Test: Emit function application");

    let expr = Expr::EApp(
        Box::new(Expr::EVar("f".to_string())),
        Box::new(Expr::EVar("x".to_string()))
    );
    let result = emit_expr_ts(expr);

    if result == "f(x)" {
        println("  ‚úÖ PASS");
        true
    } else {
        println("  ‚ùå FAIL: Expected 'f(x)', got '{}'", result);
        false
    }
}

// Test 8: Emit let statement
fun test_emit_let_stmt() -> bool {
    println("Test: Emit let statement");

    let stmt = Stmt::SLet("x".to_string(), Expr::EInt(42));
    let result = emit_stmt_ts(stmt);

    if result == "const x = 42;" {
        println("  ‚úÖ PASS");
        true
    } else {
        println("  ‚ùå FAIL: Expected 'const x = 42;', got '{}'", result);
        false
    }
}

// Test 9: Emit function declaration
fun test_emit_fun_decl() -> bool {
    println("Test: Emit function declaration");

    let stmt = Stmt::SFun(
        "id".to_string(),
        "x".to_string(),
        Expr::EVar("x".to_string())
    );
    let result = emit_stmt_ts(stmt);

    if result == "const id = (x) => x;" {
        println("  ‚úÖ PASS");
        true
    } else {
        println("  ‚ùå FAIL: Expected 'const id = (x) => x;', got '{}'", result);
        false
    }
}

// Test 10: Emit nested expression
fun test_emit_nested() -> bool {
    println("Test: Emit nested expression");

    let inner = Expr::EBinOp(
        "+".to_string(),
        Box::new(Expr::EInt(1)),
        Box::new(Expr::EInt(2))
    );
    let expr = Expr::EBinOp(
        "+".to_string(),
        Box::new(inner),
        Box::new(Expr::EInt(3))
    );
    let result = emit_expr_ts(expr);

    if result == "((1 + 2) + 3)" {
        println("  ‚úÖ PASS");
        true
    } else {
        println("  ‚ùå FAIL: Expected '((1 + 2) + 3)', got '{}'", result);
        false
    }
}

fun main() {
    println("üü¢ BOOTSTRAP-014: TypeScript Code Emitter (GREEN Phase)");
    println("=======================================================");
    println("");

    let mut passed = 0;
    let mut failed = 0;

    if test_emit_int() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_emit_bool() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_emit_string() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_emit_var() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_emit_binop() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_emit_lambda() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_emit_app() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_emit_let_stmt() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_emit_fun_decl() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    if test_emit_nested() {
        passed = passed + 1;
    } else {
        failed = failed + 1;
    }

    println("");
    println("üìä Results: {} passed, {} failed", passed, failed);

    if failed == 0 {
        println("‚úÖ GREEN: All 10/10 tests passing!");
        println("TypeScript emitter implementation COMPLETE!");
    }
}

main();
