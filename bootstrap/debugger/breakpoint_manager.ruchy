// DEBUGGER-002: Breakpoint Management - REFACTOR Phase (Phase 3/8 EXTREME TDD)
//
// Purpose: Improve code quality while maintaining all tests passing
// Approach: Reduce duplication, extract helpers, simplify logic
//
// Refactor Phase Rule: Improve code without changing behavior

// Breakpoint structure
struct Breakpoint {
    file: String,
    line: i32,
    verified: bool,
    enabled: bool,
    id: i32
}

// BreakpointManager structure
struct BreakpointManager {
    count: i32,
    bp1_file: String,
    bp1_line: i32,
    bp1_enabled: bool,
    bp1_exists: bool,
    bp2_file: String,
    bp2_line: i32,
    bp2_enabled: bool,
    bp2_exists: bool,
    bp3_file: String,
    bp3_line: i32,
    bp3_enabled: bool,
    bp3_exists: bool,
    next_id: i32
}

// Helper: Check if breakpoint slot matches file and line
fun slot_matches(exists: bool, slot_file: String, slot_line: i32, file: String, line: i32) -> bool {
    if exists {
        if slot_file == file {
            slot_line == line
        } else {
            false
        }
    } else {
        false
    }
}

// Create new empty breakpoint manager
fun breakpoint_manager_new() -> BreakpointManager {
    BreakpointManager {
        count: 0,
        bp1_file: "",
        bp1_line: 0,
        bp1_enabled: false,
        bp1_exists: false,
        bp2_file: "",
        bp2_line: 0,
        bp2_enabled: false,
        bp2_exists: false,
        bp3_file: "",
        bp3_line: 0,
        bp3_enabled: false,
        bp3_exists: false,
        next_id: 1
    }
}

// Get count of breakpoints (inline accessor)
fun breakpoint_manager_count(manager: BreakpointManager) -> i32 {
    manager.count
}

// Create new breakpoint
fun breakpoint_new(file: String, line: i32) -> Breakpoint {
    Breakpoint {
        file: file,
        line: line,
        verified: false,
        enabled: true,
        id: 0
    }
}

// Set breakpoint verified status
fun breakpoint_set_verified(bp: Breakpoint, verified: bool) -> Breakpoint {
    Breakpoint {
        file: bp.file,
        line: bp.line,
        verified: verified,
        enabled: bp.enabled,
        id: bp.id
    }
}

// Check if breakpoint is verified (inline accessor)
fun breakpoint_is_verified(bp: Breakpoint) -> bool {
    bp.verified
}

// Disable breakpoint
fun breakpoint_disable(bp: Breakpoint) -> Breakpoint {
    Breakpoint {
        file: bp.file,
        line: bp.line,
        verified: bp.verified,
        enabled: false,
        id: bp.id
    }
}

// Check if breakpoint is enabled (inline accessor)
fun breakpoint_is_enabled(bp: Breakpoint) -> bool {
    bp.enabled
}

// Add breakpoint to manager
// REFACTOR: Inline count increment to reduce variables
fun breakpoint_manager_add(manager: BreakpointManager, bp: Breakpoint) -> BreakpointManager {
    if !manager.bp1_exists {
        BreakpointManager {
            count: manager.count + 1,
            bp1_file: bp.file,
            bp1_line: bp.line,
            bp1_enabled: bp.enabled,
            bp1_exists: true,
            bp2_file: manager.bp2_file,
            bp2_line: manager.bp2_line,
            bp2_enabled: manager.bp2_enabled,
            bp2_exists: manager.bp2_exists,
            bp3_file: manager.bp3_file,
            bp3_line: manager.bp3_line,
            bp3_enabled: manager.bp3_enabled,
            bp3_exists: manager.bp3_exists,
            next_id: manager.next_id + 1
        }
    } else {
        if !manager.bp2_exists {
            BreakpointManager {
                count: manager.count + 1,
                bp1_file: manager.bp1_file,
                bp1_line: manager.bp1_line,
                bp1_enabled: manager.bp1_enabled,
                bp1_exists: manager.bp1_exists,
                bp2_file: bp.file,
                bp2_line: bp.line,
                bp2_enabled: bp.enabled,
                bp2_exists: true,
                bp3_file: manager.bp3_file,
                bp3_line: manager.bp3_line,
                bp3_enabled: manager.bp3_enabled,
                bp3_exists: manager.bp3_exists,
                next_id: manager.next_id + 1
            }
        } else {
            if !manager.bp3_exists {
                BreakpointManager {
                    count: manager.count + 1,
                    bp1_file: manager.bp1_file,
                    bp1_line: manager.bp1_line,
                    bp1_enabled: manager.bp1_enabled,
                    bp1_exists: manager.bp1_exists,
                    bp2_file: manager.bp2_file,
                    bp2_line: manager.bp2_line,
                    bp2_enabled: manager.bp2_enabled,
                    bp2_exists: manager.bp2_exists,
                    bp3_file: bp.file,
                    bp3_line: bp.line,
                    bp3_enabled: bp.enabled,
                    bp3_exists: true,
                    next_id: manager.next_id + 1
                }
            } else {
                manager
            }
        }
    }
}

// Remove breakpoint from manager
// REFACTOR: Uses slot_matches helper to reduce duplication
fun breakpoint_manager_remove(manager: BreakpointManager, file: String, line: i32) -> BreakpointManager {
    let bp1_matches = slot_matches(manager.bp1_exists, manager.bp1_file, manager.bp1_line, file, line)

    if bp1_matches {
        BreakpointManager {
            count: manager.count - 1,
            bp1_file: "",
            bp1_line: 0,
            bp1_enabled: false,
            bp1_exists: false,
            bp2_file: manager.bp2_file,
            bp2_line: manager.bp2_line,
            bp2_enabled: manager.bp2_enabled,
            bp2_exists: manager.bp2_exists,
            bp3_file: manager.bp3_file,
            bp3_line: manager.bp3_line,
            bp3_enabled: manager.bp3_enabled,
            bp3_exists: manager.bp3_exists,
            next_id: manager.next_id
        }
    } else {
        let bp2_matches = slot_matches(manager.bp2_exists, manager.bp2_file, manager.bp2_line, file, line)

        if bp2_matches {
            BreakpointManager {
                count: manager.count - 1,
                bp1_file: manager.bp1_file,
                bp1_line: manager.bp1_line,
                bp1_enabled: manager.bp1_enabled,
                bp1_exists: manager.bp1_exists,
                bp2_file: "",
                bp2_line: 0,
                bp2_enabled: false,
                bp2_exists: false,
                bp3_file: manager.bp3_file,
                bp3_line: manager.bp3_line,
                bp3_enabled: manager.bp3_enabled,
                bp3_exists: manager.bp3_exists,
                next_id: manager.next_id
            }
        } else {
            let bp3_matches = slot_matches(manager.bp3_exists, manager.bp3_file, manager.bp3_line, file, line)

            if bp3_matches {
                BreakpointManager {
                    count: manager.count - 1,
                    bp1_file: manager.bp1_file,
                    bp1_line: manager.bp1_line,
                    bp1_enabled: manager.bp1_enabled,
                    bp1_exists: manager.bp1_exists,
                    bp2_file: manager.bp2_file,
                    bp2_line: manager.bp2_line,
                    bp2_enabled: manager.bp2_enabled,
                    bp2_exists: manager.bp2_exists,
                    bp3_file: "",
                    bp3_line: 0,
                    bp3_enabled: false,
                    bp3_exists: false,
                    next_id: manager.next_id
                }
            } else {
                manager
            }
        }
    }
}

// Get count of breakpoints for specific file
fun breakpoint_manager_get_file_count(manager: BreakpointManager, file: String) -> i32 {
    let mut count = 0
    let bp1_match = if manager.bp1_exists { manager.bp1_file == file } else { false }
    let bp2_match = if manager.bp2_exists { manager.bp2_file == file } else { false }
    let bp3_match = if manager.bp3_exists { manager.bp3_file == file } else { false }
    if bp1_match { count = count + 1 }
    if bp2_match { count = count + 1 }
    if bp3_match { count = count + 1 }
    count
}

// Clear all breakpoints - delegates to new()
fun breakpoint_manager_clear_all(_manager: BreakpointManager) -> BreakpointManager {
    breakpoint_manager_new()
}

// Main function
fun main() {
    println("DEBUGGER-002: Breakpoint Management - REFACTOR Phase")
    println("Refactored: reduced duplication, improved clarity")
    println("Run test_breakpoint_manager_green.ruchy to verify tests pass")
}
