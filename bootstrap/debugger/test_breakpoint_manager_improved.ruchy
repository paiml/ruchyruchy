// DEBUGGER-002: Breakpoint Management - MUTATION Phase Testing
//
// IMPROVED tests designed to kill surviving mutations
// Expected: ALL 14 tests should PASS (strengthened test suite)

// ============================================
// IMPLEMENTATION (same as refactored version)
// ============================================

// Breakpoint structure
struct Breakpoint {
    file: String,
    line: i32,
    verified: bool,
    enabled: bool,
    id: i32
}

// BreakpointManager structure
struct BreakpointManager {
    count: i32,
    bp1_file: String,
    bp1_line: i32,
    bp1_enabled: bool,
    bp1_exists: bool,
    bp2_file: String,
    bp2_line: i32,
    bp2_enabled: bool,
    bp2_exists: bool,
    bp3_file: String,
    bp3_line: i32,
    bp3_enabled: bool,
    bp3_exists: bool,
    next_id: i32
}

// Helper: Check if breakpoint slot matches file and line
fun slot_matches(exists: bool, slot_file: String, slot_line: i32, file: String, line: i32) -> bool {
    if exists {
        if slot_file == file {
            slot_line == line
        } else {
            false
        }
    } else {
        false
    }
}

// Create new empty breakpoint manager
fun breakpoint_manager_new() -> BreakpointManager {
    BreakpointManager {
        count: 0,
        bp1_file: "",
        bp1_line: 0,
        bp1_enabled: false,
        bp1_exists: false,
        bp2_file: "",
        bp2_line: 0,
        bp2_enabled: false,
        bp2_exists: false,
        bp3_file: "",
        bp3_line: 0,
        bp3_enabled: false,
        bp3_exists: false,
        next_id: 1
    }
}

// Get count of breakpoints (inline accessor)
fun breakpoint_manager_count(manager: BreakpointManager) -> i32 {
    manager.count
}

// Create new breakpoint
fun breakpoint_new(file: String, line: i32) -> Breakpoint {
    Breakpoint {
        file: file,
        line: line,
        verified: false,
        enabled: true,
        id: 0
    }
}

// Set breakpoint verified status
fun breakpoint_set_verified(bp: Breakpoint, verified: bool) -> Breakpoint {
    Breakpoint {
        file: bp.file,
        line: bp.line,
        verified: verified,
        enabled: bp.enabled,
        id: bp.id
    }
}

// Check if breakpoint is verified (inline accessor)
fun breakpoint_is_verified(bp: Breakpoint) -> bool {
    bp.verified
}

// Disable breakpoint
fun breakpoint_disable(bp: Breakpoint) -> Breakpoint {
    Breakpoint {
        file: bp.file,
        line: bp.line,
        verified: bp.verified,
        enabled: false,
        id: bp.id
    }
}

// Check if breakpoint is enabled (inline accessor)
fun breakpoint_is_enabled(bp: Breakpoint) -> bool {
    bp.enabled
}

// Add breakpoint to manager
fun breakpoint_manager_add(manager: BreakpointManager, bp: Breakpoint) -> BreakpointManager {
    if !manager.bp1_exists {
        BreakpointManager {
            count: manager.count + 1,
            bp1_file: bp.file,
            bp1_line: bp.line,
            bp1_enabled: bp.enabled,
            bp1_exists: true,
            bp2_file: manager.bp2_file,
            bp2_line: manager.bp2_line,
            bp2_enabled: manager.bp2_enabled,
            bp2_exists: manager.bp2_exists,
            bp3_file: manager.bp3_file,
            bp3_line: manager.bp3_line,
            bp3_enabled: manager.bp3_enabled,
            bp3_exists: manager.bp3_exists,
            next_id: manager.next_id + 1
        }
    } else {
        if !manager.bp2_exists {
            BreakpointManager {
                count: manager.count + 1,
                bp1_file: manager.bp1_file,
                bp1_line: manager.bp1_line,
                bp1_enabled: manager.bp1_enabled,
                bp1_exists: manager.bp1_exists,
                bp2_file: bp.file,
                bp2_line: bp.line,
                bp2_enabled: bp.enabled,
                bp2_exists: true,
                bp3_file: manager.bp3_file,
                bp3_line: manager.bp3_line,
                bp3_enabled: manager.bp3_enabled,
                bp3_exists: manager.bp3_exists,
                next_id: manager.next_id + 1
            }
        } else {
            if !manager.bp3_exists {
                BreakpointManager {
                    count: manager.count + 1,
                    bp1_file: manager.bp1_file,
                    bp1_line: manager.bp1_line,
                    bp1_enabled: manager.bp1_enabled,
                    bp1_exists: manager.bp1_exists,
                    bp2_file: manager.bp2_file,
                    bp2_line: manager.bp2_line,
                    bp2_enabled: manager.bp2_enabled,
                    bp2_exists: manager.bp2_exists,
                    bp3_file: bp.file,
                    bp3_line: bp.line,
                    bp3_enabled: bp.enabled,
                    bp3_exists: true,
                    next_id: manager.next_id + 1
                }
            } else {
                manager
            }
        }
    }
}

// Remove breakpoint from manager
fun breakpoint_manager_remove(manager: BreakpointManager, file: String, line: i32) -> BreakpointManager {
    let bp1_matches = slot_matches(manager.bp1_exists, manager.bp1_file, manager.bp1_line, file, line)

    if bp1_matches {
        BreakpointManager {
            count: manager.count - 1,
            bp1_file: "",
            bp1_line: 0,
            bp1_enabled: false,
            bp1_exists: false,
            bp2_file: manager.bp2_file,
            bp2_line: manager.bp2_line,
            bp2_enabled: manager.bp2_enabled,
            bp2_exists: manager.bp2_exists,
            bp3_file: manager.bp3_file,
            bp3_line: manager.bp3_line,
            bp3_enabled: manager.bp3_enabled,
            bp3_exists: manager.bp3_exists,
            next_id: manager.next_id
        }
    } else {
        let bp2_matches = slot_matches(manager.bp2_exists, manager.bp2_file, manager.bp2_line, file, line)

        if bp2_matches {
            BreakpointManager {
                count: manager.count - 1,
                bp1_file: manager.bp1_file,
                bp1_line: manager.bp1_line,
                bp1_enabled: manager.bp1_enabled,
                bp1_exists: manager.bp1_exists,
                bp2_file: "",
                bp2_line: 0,
                bp2_enabled: false,
                bp2_exists: false,
                bp3_file: manager.bp3_file,
                bp3_line: manager.bp3_line,
                bp3_enabled: manager.bp3_enabled,
                bp3_exists: manager.bp3_exists,
                next_id: manager.next_id
            }
        } else {
            let bp3_matches = slot_matches(manager.bp3_exists, manager.bp3_file, manager.bp3_line, file, line)

            if bp3_matches {
                BreakpointManager {
                    count: manager.count - 1,
                    bp1_file: manager.bp1_file,
                    bp1_line: manager.bp1_line,
                    bp1_enabled: manager.bp1_enabled,
                    bp1_exists: manager.bp1_exists,
                    bp2_file: manager.bp2_file,
                    bp2_line: manager.bp2_line,
                    bp2_enabled: manager.bp2_enabled,
                    bp2_exists: manager.bp2_exists,
                    bp3_file: "",
                    bp3_line: 0,
                    bp3_enabled: false,
                    bp3_exists: false,
                    next_id: manager.next_id
                }
            } else {
                manager
            }
        }
    }
}

// Get count of breakpoints for specific file
fun breakpoint_manager_get_file_count(manager: BreakpointManager, file: String) -> i32 {
    let mut count = 0
    let bp1_match = if manager.bp1_exists { manager.bp1_file == file } else { false }
    let bp2_match = if manager.bp2_exists { manager.bp2_file == file } else { false }
    let bp3_match = if manager.bp3_exists { manager.bp3_file == file } else { false }
    if bp1_match { count = count + 1 }
    if bp2_match { count = count + 1 }
    if bp3_match { count = count + 1 }
    count
}

// Clear all breakpoints
fun breakpoint_manager_clear_all(_manager: BreakpointManager) -> BreakpointManager {
    breakpoint_manager_new()
}


// ============================================
// ORIGINAL TESTS (10 tests)
// ============================================

fun test_create_breakpoint_manager() -> bool {
    println("TEST 1: Create empty breakpoint manager")

    let manager = breakpoint_manager_new()
    let count = breakpoint_manager_count(manager)

    if count == 0 {
        println("  ✅ PASS: Empty manager has count 0")
        true
    } else {
        println("  ❌ FAIL: Expected count 0, got {}", count)
        false
    }
}

fun test_add_breakpoint() -> bool {
    println("TEST 2: Add breakpoint")

    let manager = breakpoint_manager_new()
    let bp = breakpoint_new("lexer.ruchy", 42)
    let manager2 = breakpoint_manager_add(manager, bp)
    let count = breakpoint_manager_count(manager2)

    if count == 1 {
        println("  ✅ PASS: Adding breakpoint increases count to 1")
        true
    } else {
        println("  ❌ FAIL: Expected count 1, got {}", count)
        false
    }
}

fun test_verify_breakpoint() -> bool {
    println("TEST 3: Verify valid breakpoint")

    let bp = breakpoint_new("lexer.ruchy", 42)
    let verified = breakpoint_set_verified(bp, true)
    let is_valid = breakpoint_is_verified(verified)

    if is_valid {
        println("  ✅ PASS: Valid breakpoint is verified")
        true
    } else {
        println("  ❌ FAIL: Breakpoint should be verified")
        false
    }
}

fun test_reject_comment_breakpoint() -> bool {
    println("TEST 4: Reject comment breakpoint")

    let bp = breakpoint_new("lexer.ruchy", 5)
    let verified = breakpoint_set_verified(bp, false)
    let is_valid = breakpoint_is_verified(verified)

    if !is_valid {
        println("  ✅ PASS: Comment line breakpoint rejected")
        true
    } else {
        println("  ❌ FAIL: Comment breakpoint should be invalid")
        false
    }
}

fun test_multiple_breakpoints() -> bool {
    println("TEST 5: Multiple breakpoints in one file")

    let manager = breakpoint_manager_new()
    let bp1 = breakpoint_new("lexer.ruchy", 42)
    let bp2 = breakpoint_new("lexer.ruchy", 57)

    let manager2 = breakpoint_manager_add(manager, bp1)
    let manager3 = breakpoint_manager_add(manager2, bp2)
    let count = breakpoint_manager_count(manager3)

    if count == 2 {
        println("  ✅ PASS: Multiple breakpoints stored (count 2)")
        true
    } else {
        println("  ❌ FAIL: Expected count 2, got {}", count)
        false
    }
}

fun test_multiple_files() -> bool {
    println("TEST 6: Breakpoints in different files")

    let manager = breakpoint_manager_new()
    let bp1 = breakpoint_new("lexer.ruchy", 42)
    let bp2 = breakpoint_new("parser.ruchy", 100)

    let manager2 = breakpoint_manager_add(manager, bp1)
    let manager3 = breakpoint_manager_add(manager2, bp2)
    let count = breakpoint_manager_count(manager3)

    if count == 2 {
        println("  ✅ PASS: Breakpoints in different files (count 2)")
        true
    } else {
        println("  ❌ FAIL: Expected count 2, got {}", count)
        false
    }
}

fun test_remove_breakpoint() -> bool {
    println("TEST 7: Remove breakpoint")

    let manager = breakpoint_manager_new()
    let bp = breakpoint_new("lexer.ruchy", 42)
    let manager2 = breakpoint_manager_add(manager, bp)
    let manager3 = breakpoint_manager_remove(manager2, "lexer.ruchy", 42)
    let count = breakpoint_manager_count(manager3)

    if count == 0 {
        println("  ✅ PASS: Removing breakpoint decreases count to 0")
        true
    } else {
        println("  ❌ FAIL: Expected count 0, got {}", count)
        false
    }
}

fun test_toggle_breakpoint() -> bool {
    println("TEST 8: Enable/disable breakpoint")

    let bp = breakpoint_new("lexer.ruchy", 42)
    let bp_disabled = breakpoint_disable(bp)
    let is_enabled = breakpoint_is_enabled(bp_disabled)

    if !is_enabled {
        println("  ✅ PASS: Breakpoint disabled successfully")
        true
    } else {
        println("  ❌ FAIL: Breakpoint should be disabled")
        false
    }
}

fun test_get_file_breakpoints() -> bool {
    println("TEST 9: Get breakpoints for file")

    let manager = breakpoint_manager_new()
    let bp1 = breakpoint_new("lexer.ruchy", 42)
    let bp2 = breakpoint_new("lexer.ruchy", 57)
    let bp3 = breakpoint_new("parser.ruchy", 100)

    let manager2 = breakpoint_manager_add(manager, bp1)
    let manager3 = breakpoint_manager_add(manager2, bp2)
    let manager4 = breakpoint_manager_add(manager3, bp3)

    let lexer_count = breakpoint_manager_get_file_count(manager4, "lexer.ruchy")

    if lexer_count == 2 {
        println("  ✅ PASS: Got 2 breakpoints for lexer.ruchy")
        true
    } else {
        println("  ❌ FAIL: Expected 2 breakpoints, got {}", lexer_count)
        false
    }
}

fun test_clear_all() -> bool {
    println("TEST 10: Clear all breakpoints")

    let manager = breakpoint_manager_new()
    let bp1 = breakpoint_new("lexer.ruchy", 42)
    let bp2 = breakpoint_new("parser.ruchy", 100)

    let manager2 = breakpoint_manager_add(manager, bp1)
    let manager3 = breakpoint_manager_add(manager2, bp2)
    let manager4 = breakpoint_manager_clear_all(manager3)
    let count = breakpoint_manager_count(manager4)

    if count == 0 {
        println("  ✅ PASS: Clear all results in count 0")
        true
    } else {
        println("  ❌ FAIL: Expected count 0, got {}", count)
        false
    }
}

// ============================================
// NEW IMPROVED TESTS (4 tests to kill mutations)
// ============================================

fun test_remove_specific_breakpoint() -> bool {
    println("TEST 11: Remove specific breakpoint (verify correct one removed)")

    // Add 3 breakpoints
    let manager = breakpoint_manager_new()
    let bp1 = breakpoint_new("lexer.ruchy", 42)
    let bp2 = breakpoint_new("parser.ruchy", 100)
    let bp3 = breakpoint_new("codegen.ruchy", 200)

    let manager2 = breakpoint_manager_add(manager, bp1)
    let manager3 = breakpoint_manager_add(manager2, bp2)
    let manager4 = breakpoint_manager_add(manager3, bp3)

    // Remove middle one (parser.ruchy:100)
    let manager5 = breakpoint_manager_remove(manager4, "parser.ruchy", 100)

    // Verify lexer.ruchy still has 1 breakpoint (Mutation 1, 2 would break this)
    let lexer_count = breakpoint_manager_get_file_count(manager5, "lexer.ruchy")
    let parser_count = breakpoint_manager_get_file_count(manager5, "parser.ruchy")
    let codegen_count = breakpoint_manager_get_file_count(manager5, "codegen.ruchy")

    if lexer_count == 1 {
        if parser_count == 0 {
            if codegen_count == 1 {
                println("  ✅ PASS: Correct breakpoint removed (lexer:1, parser:0, codegen:1)")
                true
            } else {
                println("  ❌ FAIL: Expected codegen:1, got {}", codegen_count)
                false
            }
        } else {
            println("  ❌ FAIL: Expected parser:0, got {}", parser_count)
            false
        }
    } else {
        println("  ❌ FAIL: Expected lexer:1, got {}", lexer_count)
        false
    }
}

fun test_remove_wrong_location() -> bool {
    println("TEST 12: Remove non-existent breakpoint (negative test)")

    // Add breakpoint at lexer.ruchy:42
    let manager = breakpoint_manager_new()
    let bp = breakpoint_new("lexer.ruchy", 42)
    let manager2 = breakpoint_manager_add(manager, bp)

    // Try to remove parser.ruchy:42 (wrong file) - Mutation 2 would break this
    let manager3 = breakpoint_manager_remove(manager2, "parser.ruchy", 42)
    let count1 = breakpoint_manager_count(manager3)

    // Try to remove lexer.ruchy:99 (wrong line) - Mutation 1 would break this
    let manager4 = breakpoint_manager_remove(manager3, "lexer.ruchy", 99)
    let count2 = breakpoint_manager_count(manager4)

    // Count should still be 1 (nothing removed)
    if count1 == 1 {
        if count2 == 1 {
            println("  ✅ PASS: Wrong file/line did not remove breakpoint")
            true
        } else {
            println("  ❌ FAIL: Wrong line removed breakpoint (count {})", count2)
            false
        }
    } else {
        println("  ❌ FAIL: Wrong file removed breakpoint (count {})", count1)
        false
    }
}

fun test_count_increment_explicit() -> bool {
    println("TEST 13: Count increment on each add (explicit check)")

    let manager0 = breakpoint_manager_new()
    let count0 = breakpoint_manager_count(manager0)

    // Mutation 3 would break this - count would stay 0
    let bp1 = breakpoint_new("lexer.ruchy", 42)
    let manager1 = breakpoint_manager_add(manager0, bp1)
    let count1 = breakpoint_manager_count(manager1)

    // Add second breakpoint
    let bp2 = breakpoint_new("parser.ruchy", 100)
    let manager2 = breakpoint_manager_add(manager1, bp2)
    let count2 = breakpoint_manager_count(manager2)

    if count0 == 0 {
        if count1 == 1 {
            if count2 == 2 {
                println("  ✅ PASS: Count increments correctly (0→1→2)")
                true
            } else {
                println("  ❌ FAIL: Expected count 2 after second add, got {}", count2)
                false
            }
        } else {
            println("  ❌ FAIL: Expected count 1 after first add, got {}", count1)
            false
        }
    } else {
        println("  ❌ FAIL: Expected initial count 0, got {}", count0)
        false
    }
}

fun test_default_enabled_state() -> bool {
    println("TEST 14: Breakpoint default enabled state")

    // Create new breakpoint - Mutation 5 would set enabled: false
    let bp = breakpoint_new("lexer.ruchy", 42)
    let is_enabled = breakpoint_is_enabled(bp)

    if is_enabled {
        // Now disable it
        let bp_disabled = breakpoint_disable(bp)
        let is_disabled = !breakpoint_is_enabled(bp_disabled)

        if is_disabled {
            println("  ✅ PASS: Breakpoint starts enabled, can be disabled")
            true
        } else {
            println("  ❌ FAIL: Breakpoint should be disabled after disable()")
            false
        }
    } else {
        println("  ❌ FAIL: Breakpoint should start enabled by default")
        false
    }
}


// ============================================
// MAIN TEST RUNNER
// ============================================

fun main() {
    println("╔════════════════════════════════════════════════════════════╗")
    println("║  DEBUGGER-002: Breakpoint Management - MUTATION Phase        ║")
    println("║  EXTREME TDD Phase 5/8: Test Quality Validation              ║")
    println("╚════════════════════════════════════════════════════════════╝")
    println("")
    println("Expected: ALL 14 tests should PASS (original 10 + improved 4)")
    println("")

    let mut passed = 0
    let mut failed = 0

    // Original 10 tests
    if test_create_breakpoint_manager() { passed = passed + 1 } else { failed = failed + 1 }
    if test_add_breakpoint() { passed = passed + 1 } else { failed = failed + 1 }
    if test_verify_breakpoint() { passed = passed + 1 } else { failed = failed + 1 }
    if test_reject_comment_breakpoint() { passed = passed + 1 } else { failed = failed + 1 }
    if test_multiple_breakpoints() { passed = passed + 1 } else { failed = failed + 1 }
    if test_multiple_files() { passed = passed + 1 } else { failed = failed + 1 }
    if test_remove_breakpoint() { passed = passed + 1 } else { failed = failed + 1 }
    if test_toggle_breakpoint() { passed = passed + 1 } else { failed = failed + 1 }
    if test_get_file_breakpoints() { passed = passed + 1 } else { failed = failed + 1 }
    if test_clear_all() { passed = passed + 1 } else { failed = failed + 1 }

    println("")
    println("════════════════════════════════════════════════════════════")
    println("IMPROVED TESTS (to kill surviving mutations):")
    println("")

    // Improved 4 tests
    if test_remove_specific_breakpoint() { passed = passed + 1 } else { failed = failed + 1 }
    if test_remove_wrong_location() { passed = passed + 1 } else { failed = failed + 1 }
    if test_count_increment_explicit() { passed = passed + 1 } else { failed = failed + 1 }
    if test_default_enabled_state() { passed = passed + 1 } else { failed = failed + 1 }

    println("")
    println("════════════════════════════════════════════════════════════")
    println("MUTATION PHASE RESULTS:")
    println("  Total Tests: 14 (10 original + 4 improved)")
    println("  Passed: {}", passed)
    println("  Failed: {}", failed)
    println("")

    if passed == 14 {
        println("✅ IMPROVED TEST SUITE: All 14 tests passing!")
        println("   Ready to re-test mutations")
    } else {
        if failed == 14 {
            println("❌ ERROR: All tests failing!")
        } else {
            println("⚠️  PARTIAL: {} tests passing, {} failing", passed, failed)
        }
    }

    println("════════════════════════════════════════════════════════════")
}
