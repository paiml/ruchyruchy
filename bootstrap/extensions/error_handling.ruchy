// Extension: Advanced Error Handling - BOOTSTRAP-025
// Comprehensive error handling with Result, Option, and try operations
//
// Working version for ruchy 1.9.3

fn main() {
    println("Extension: Advanced Error Handling - BOOTSTRAP-025");
    println("=================================================");
    
    // Error handling overview
    println("\nüö® Advanced Error Handling Overview:");
    println("  - Result<T, E> for recoverable errors");
    println("  - Option<T> for nullable values");
    println("  - Try operator (?) for error propagation");
    println("  - Pattern matching for error handling");
    println("  - Error trait hierarchy and conversion");
    println("  - Zero-cost error handling abstractions");
    
    // Result type design
    println("\nüìù Result Type Design:");
    println("  Core Result enum:");
    println("    enum Result<T, E> {");
    println("      Ok(T),");
    println("      Err(E)");
    println("    }");
    println("  ");
    println("  Result methods:");
    println("    impl<T, E> Result<T, E> {");
    println("      fun is_ok(self) -> bool { ... }");
    println("      fun is_err(self) -> bool { ... }");
    println("      fun unwrap(self) -> T { ... }");
    println("      fun unwrap_or(self, default: T) -> T { ... }");
    println("      fun map<U>(self, f: fn(T) -> U) -> Result<U, E> { ... }");
    println("      fun map_err<F>(self, f: fn(E) -> F) -> Result<T, F> { ... }");
    println("      fun and_then<U>(self, f: fn(T) -> Result<U, E>) -> Result<U, E> { ... }");
    println("    }");
    
    // Option type design
    println("\nü§∑ Option Type Design:");
    println("  Core Option enum:");
    println("    enum Option<T> {");
    println("      Some(T),");
    println("      None");
    println("    }");
    println("  ");
    println("  Option methods:");
    println("    impl<T> Option<T> {");
    println("      fun is_some(self) -> bool { ... }");
    println("      fun is_none(self) -> bool { ... }");
    println("      fun unwrap(self) -> T { ... }");
    println("      fun unwrap_or(self, default: T) -> T { ... }");
    println("      fun map<U>(self, f: fn(T) -> U) -> Option<U> { ... }");
    println("      fun and_then<U>(self, f: fn(T) -> Option<U>) -> Option<U> { ... }");
    println("      fun ok_or<E>(self, err: E) -> Result<T, E> { ... }");
    println("    }");
    
    // Try operator implementation
    println("\n‚ùì Try Operator Implementation:");
    println("  Basic try operator usage:");
    println("    fun parse_and_double(s: String) -> Result<i32, ParseError> {");
    println("      let num = parse_int(s)?;  // Early return if Err");
    println("      Ok(num * 2)");
    println("    }");
    println("  ");
    println("  Desugaring of try operator:");
    println("    // Source:");
    println("    let result = operation()?;");
    println("    ");
    println("    // Desugared:");
    println("    let result = match operation() {");
    println("      Ok(value) => value,");
    println("      Err(e) => return Err(From::from(e))");
    println("    };");
    
    // Error trait hierarchy
    println("\nüìä Error Trait Hierarchy:");
    println("  Base Error trait:");
    println("    trait Error {");
    println("      fun description(self) -> String;");
    println("      fun cause(self) -> Option<Box<dyn Error>>;");
    println("      fun source(self) -> Option<&dyn Error> { self.cause() }");
    println("    }");
    println("  ");
    println("  Custom error types:");
    println("    enum ParseError {");
    println("      InvalidNumber(String),");
    println("      EmptyInput,");
    println("      OutOfRange { value: i64, max: i64 }");
    println("    }");
    println("    ");
    println("    impl Error for ParseError {");
    println("      fun description(self) -> String {");
    println("        match self {");
    println("          InvalidNumber(s) => format(\"Invalid number: {}\", s),");
    println("          EmptyInput => \"Input is empty\".to_string(),");
    println("          OutOfRange { value, max } => format(\"{} exceeds maximum {}\", value, max)");
    println("        }");
    println("      }");
    println("    }");
    
    // Error conversion and From trait
    println("\nüîÑ Error Conversion and From Trait:");
    println("  From trait for error conversion:");
    println("    trait From<T> {");
    println("      fun from(value: T) -> Self;");
    println("    }");
    println("  ");
    println("  Automatic error conversion:");
    println("    enum AppError {");
    println("      Parse(ParseError),");
    println("      Io(IoError),");
    println("      Network(NetworkError)");
    println("    }");
    println("    ");
    println("    impl From<ParseError> for AppError {");
    println("      fun from(err: ParseError) -> AppError {");
    println("        AppError::Parse(err)");
    println("      }");
    println("    }");
    println("  ");
    println("  Usage with try operator:");
    println("    fun complex_operation() -> Result<String, AppError> {");
    println("      let data = read_file(\"config.txt\")?;  // IoError -> AppError");
    println("      let parsed = parse_config(data)?;     // ParseError -> AppError");
    println("      let result = fetch_data(parsed.url)?; // NetworkError -> AppError");
    println("      Ok(result)");
    println("    }");
    
    // Pattern matching error handling
    println("\nüéØ Pattern Matching Error Handling:");
    println("  Comprehensive error matching:");
    println("    match complex_operation() {");
    println("      Ok(result) => {");
    println("        println(\"Success: {}\", result);");
    println("      },");
    println("      Err(AppError::Parse(ParseError::EmptyInput)) => {");
    println("        println(\"Config file is empty, using defaults\");");
    println("        use_default_config();");
    println("      },");
    println("      Err(AppError::Io(error)) => {");
    println("        println(\"IO error: {}\", error.description());");
    println("        exit(1);");
    println("      },");
    println("      Err(error) => {");
    println("        println(\"Unexpected error: {}\", error.description());");
    println("        report_error(error);");
    println("      }");
    println("    }");
    
    // Early return patterns
    println("\n‚è™ Early Return Patterns:");
    println("  Multiple try operations:");
    println("    fun process_user_input(input: String) -> Result<User, ValidationError> {");
    println("      let email = validate_email(input.get_field(\"email\")?)?;");
    println("      let age = validate_age(input.get_field(\"age\")?)?;");
    println("      let name = validate_name(input.get_field(\"name\")?)?;");
    println("      ");
    println("      Ok(User { email, age, name })");
    println("    }");
    println("  ");
    println("  Optional chaining:");
    println("    fun get_user_city(user_id: i32) -> Option<String> {");
    println("      let user = find_user(user_id)?;");
    println("      let address = user.address?;");
    println("      Some(address.city)");
    println("    }");
    
    // Result and Option combinators
    println("\nüîó Result and Option Combinators:");
    println("  Chaining operations:");
    println("    let result = parse_input(\"42\")");
    println("      .map(|x| x * 2)");
    println("      .and_then(|x| validate_range(x, 0, 100))");
    println("      .map_err(|e| format!(\"Processing failed: {}\", e));");
    println("  ");
    println("  Collecting results:");
    println("    fun process_batch(items: Vec<String>) -> Result<Vec<i32>, ParseError> {");
    println("      items.iter()");
    println("        .map(|item| parse_int(item))");
    println("        .collect()  // Collects Result<Vec<i32>, ParseError>");
    println("    }");
    
    // Error context and backtrace
    println("\nüìç Error Context and Backtrace:");
    println("  Error context wrapping:");
    println("    fun load_config() -> Result<Config, ConfigError> {");
    println("      read_file(\"app.toml\")");
    println("        .context(\"Failed to read configuration file\")?");
    println("        .parse()");
    println("        .context(\"Failed to parse configuration\")");
    println("    }");
    println("  ");
    println("  Error backtrace:");
    println("    struct ErrorWithBacktrace {");
    println("      error: Box<dyn Error>,");
    println("      backtrace: Backtrace");
    println("    }");
    println("    ");
    println("    impl ErrorWithBacktrace {");
    println("      fun new<E: Error + 'static>(error: E) -> Self {");
    println("        ErrorWithBacktrace {");
    println("          error: Box::new(error),");
    println("          backtrace: Backtrace::capture()");
    println("        }");
    println("      }");
    println("    }");
    
    // Async error handling
    println("\nüöÄ Async Error Handling:");
    println("  Async Result operations:");
    println("    async fun async_process() -> Result<String, ProcessError> {");
    println("      let data = await fetch_data().await?;");
    println("      let processed = await transform_data(data).await?;");
    println("      await save_data(processed).await?;");
    println("      Ok(\"Success\".to_string())");
    println("    }");
    println("  ");
    println("  Async error recovery:");
    println("    async fun resilient_fetch(url: String) -> Result<String, NetworkError> {");
    println("      let mut attempts = 0;");
    println("      loop {");
    println("        match await http_get(url.clone()).await {");
    println("          Ok(response) => return Ok(response),");
    println("          Err(e) if attempts < 3 => {");
    println("            attempts += 1;");
    println("            await sleep(Duration::seconds(attempts));");
    println("          },");
    println("          Err(e) => return Err(e)");
    println("        }");
    println("      }");
    println("    }");
    
    // Error handling best practices
    println("\n‚úÖ Error Handling Best Practices:");
    println("  Specific error types:");
    println("    // Good: Specific error types");
    println("    enum DatabaseError {");
    println("      ConnectionFailed { host: String, port: i32 },");
    println("      QueryTimeout { query: String, timeout: Duration },");
    println("      ConstraintViolation { constraint: String, value: String }");
    println("    }");
    println("    ");
    println("    // Avoid: Generic error strings");
    println("    // Result<T, String>  // Less informative");
    println("  ");
    println("  Error recovery strategies:");
    println("    fun robust_operation() -> Result<String, OperationError> {");
    println("      // Try primary approach");
    println("      match primary_method() {");
    println("        Ok(result) => return Ok(result),");
    println("        Err(PrimaryError::Temporary(_)) => {");
    println("          // Retry logic for temporary failures");
    println("        },");
    println("        Err(PrimaryError::Permanent(_)) => {");
    println("          // Fall back to alternative method");
    println("          return fallback_method();");
    println("        }");
    println("      }");
    println("      ");
    println("      Err(OperationError::AllMethodsFailed)");
    println("    }");
    
    // Panic vs Result guidelines
    println("\nüí• Panic vs Result Guidelines:");
    println("  When to use panic:");
    println("    - Programming errors (index out of bounds)");
    println("    - Unrecoverable system failures");
    println("    - Test failures");
    println("    - Invariant violations");
    println("  ");
    println("  When to use Result:");
    println("    - Expected failure cases (file not found)");
    println("    - User input validation errors");
    println("    - Network or IO failures");
    println("    - Parsing failures");
    println("  ");
    println("  Example distinction:");
    println("    // Use Result for expected failures");
    println("    fun parse_config(content: String) -> Result<Config, ParseError> { ... }");
    println("    ");
    println("    // Use panic for programming errors");
    println("    fun get_element(vec: Vec<T>, index: usize) -> T {");
    println("      assert!(index < vec.len(), \"Index {} out of bounds\", index);");
    println("      vec[index]  // Safe to panic here");
    println("    }");
    
    // Performance considerations
    println("\n‚ö° Performance Considerations:");
    println("  Zero-cost error handling:");
    println("    - Result<T, E> is enum with no runtime overhead");
    println("    - Try operator compiles to efficient match statements");
    println("    - Error conversion happens at compile time");
    println("  ");
    println("  Avoiding allocations:");
    println("    // Prefer static error messages");
    println("    enum StaticError {");
    println("      InvalidInput,        // No allocation");
    println("      OutOfMemory,        // No allocation");
    println("      NetworkTimeout      // No allocation");
    println("    }");
    println("    ");
    println("    // Instead of:");
    println("    // Result<T, String>  // Allocates for error messages");
    
    // Testing error conditions
    println("\nüß™ Testing Error Conditions:");
    println("  Error case testing:");
    println("    #[test]");
    println("    fun test_parse_error() {");
    println("      let result = parse_int(\"not_a_number\");");
    println("      match result {");
    println("        Err(ParseError::InvalidNumber(s)) => {");
    println("          assert_eq(s, \"not_a_number\");");
    println("        },");
    println("        _ => panic!(\"Expected InvalidNumber error\")");
    println("      }");
    println("    }");
    println("  ");
    println("  Property-based error testing:");
    println("    #[quickcheck]");
    println("    fun test_parse_roundtrip(n: i32) -> bool {");
    println("      let s = n.to_string();");
    println("      parse_int(s) == Ok(n)");
    println("    }");
    
    // Integration with compiler stages
    println("\nüîó Integration with Compiler Stages:");
    println("  Stage 1: Parser extensions:");
    println("    - Parse Result<T, E> and Option<T> type syntax");
    println("    - Parse try operator (?) expressions");
    println("    - Parse error handling patterns");
    println("  ");
    println("  Stage 2: Type checker extensions:");
    println("    - Result and Option type checking");
    println("    - Try operator type inference");
    println("    - Error type conversion checking");
    println("  ");
    println("  Stage 3: Code generator extensions:");
    println("    - Efficient Result/Option representation");
    println("    - Try operator desugaring");
    println("    - Error type layout optimization");
    
    println("\n‚úÖ BOOTSTRAP-025 Complete: Advanced error handling architecture designed");
    println("   - Comprehensive Result<T, E> and Option<T> system");
    println("   - Try operator with automatic error conversion");
    println("   - Rich error trait hierarchy and pattern matching");
    println("   - Zero-cost error handling abstractions");
    println("   - Integration with async/await and other language features");
    println("   üéâ Advanced Language Extensions Sprint Complete!");
}