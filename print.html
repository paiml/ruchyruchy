<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RuchyRuchy Bootstrap Compiler: A TDD Journey</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Building a bootstrap compiler for Ruchy using Test-Driven Development and pure Ruchy dogfooding">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">RuchyRuchy Bootstrap Compiler: A TDD Journey</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/paiml/ruchyruchy" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to the RuchyRuchy Bootstrap Compiler project! This book documents the Test-Driven Development journey of building a self-hosting bootstrap compiler for the Ruchy programming language.</p>
<h2 id="project-goals"><a class="header" href="#project-goals">Project Goals</a></h2>
<ol>
<li><strong>Pure Ruchy Dogfooding</strong>: Build the compiler using only Ruchy tools and Ruchy code</li>
<li><strong>Extreme TDD</strong>: Every feature developed with RED-GREEN-REFACTOR cycle</li>
<li><strong>Zero Tolerance Quality</strong>: A+ lint grades, 80%+ coverage, zero SATD</li>
<li><strong>Boundary Discovery</strong>: Find and document exact limits of Ruchy runtime</li>
<li><strong>Educational Excellence</strong>: Comprehensive documentation of compiler construction</li>
</ol>
<h2 id="why-this-book"><a class="header" href="#why-this-book">Why This Book?</a></h2>
<p>This book serves as:</p>
<ul>
<li><strong>Living Documentation</strong>: Real-time record of development decisions</li>
<li><strong>TDD Tutorial</strong>: Example of extreme test-driven development</li>
<li><strong>Compiler Guide</strong>: Educational resource for compiler construction</li>
<li><strong>Boundary Reference</strong>: Discovered Ruchy language capabilities and limitations</li>
</ul>
<h2 id="development-approach"><a class="header" href="#development-approach">Development Approach</a></h2>
<p>Every ticket follows the TDD cycle:</p>
<ol>
<li><strong>RED</strong>: Write a failing test first</li>
<li><strong>GREEN</strong>: Write minimal code to make test pass</li>
<li><strong>REFACTOR</strong>: Improve code while keeping tests green</li>
</ol>
<h2 id="current-status"><a class="header" href="#current-status">Current Status</a></h2>
<ul>
<li><strong>Ruchy Version</strong>: v3.94.0</li>
<li><strong>Project Phase</strong>: Sprint 3 - Bootstrap Stage 0 (Lexer)</li>
<li><strong>Tests Passing</strong>: 100% on completed components</li>
<li><strong>Quality Grade</strong>: A+ via <code>ruchy lint</code></li>
</ul>
<h2 id="how-to-use-this-book"><a class="header" href="#how-to-use-this-book">How to Use This Book</a></h2>
<ul>
<li>Each chapter corresponds to a ticket in <code>roadmap.yaml</code></li>
<li>Chapters document RED-GREEN-REFACTOR phases</li>
<li>Discoveries section tracks runtime boundary findings</li>
<li>All code examples are executable Ruchy</li>
</ul>
<h2 id="quick-links"><a class="header" href="#quick-links">Quick Links</a></h2>
<ul>
<li><a href="https://github.com/paiml/ruchyruchy">GitHub Repository</a></li>
<li><a href="https://github.com/paiml/ruchy">Ruchy Language</a></li>
<li><a href="https://github.com/paiml/ruchyruchy/blob/main/roadmap.yaml">Roadmap</a></li>
<li><a href="https://github.com/paiml/ruchyruchy/blob/main/INTEGRATION.md">Integration Report</a></li>
<li><a href="https://github.com/paiml/ruchyruchy/blob/main/BOUNDARIES.md">Boundaries Documentation</a></li>
</ul>
<p>Let's build a compiler using TDD!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bootstrap-stage-0-lexer"><a class="header" href="#bootstrap-stage-0-lexer">Bootstrap Stage 0: Lexer</a></h1>
<p>Stage 0 of the bootstrap compiler implements lexical analysis - converting source code text into tokens.</p>
<h2 id="goal"><a class="header" href="#goal">Goal</a></h2>
<p>Build a self-tokenizing lexer in pure Ruchy that can:</p>
<ul>
<li>Tokenize its own source code</li>
<li>Handle 82 different token types</li>
<li>Track position information (line, column, offset)</li>
<li>Achieve &gt;10K LOC/s throughput</li>
<li>Pass 100% of validation tests</li>
</ul>
<h2 id="components"><a class="header" href="#components">Components</a></h2>
<ol>
<li>
<p><strong>Token Type Definitions</strong> (BOOTSTRAP-001)</p>
<ul>
<li>82 token types covering keywords, operators, literals, delimiters</li>
<li>Keyword lookup functionality</li>
<li>Position tracking structures</li>
</ul>
</li>
<li>
<p><strong>Character Stream Processing</strong> (BOOTSTRAP-002)</p>
<ul>
<li>Character-by-character input abstraction</li>
<li>Lookahead support for multi-character tokens</li>
<li>Position tracking integration</li>
<li>O(1) character access performance</li>
</ul>
</li>
<li>
<p><strong>Core Lexer Implementation</strong> (BOOTSTRAP-003)</p>
<ul>
<li>Main tokenization loop</li>
<li>Operator and keyword recognition</li>
<li>Literal parsing (numbers, strings, chars)</li>
<li>Comment handling</li>
<li>Error recovery</li>
</ul>
</li>
</ol>
<h2 id="tdd-approach"><a class="header" href="#tdd-approach">TDD Approach</a></h2>
<p>Each component follows strict TDD:</p>
<ol>
<li>Write tests first (RED)</li>
<li>Implement minimal code (GREEN)</li>
<li>Refactor for quality (REFACTOR)</li>
<li>Validate with <code>ruchy test</code>, <code>ruchy lint</code>, <code>ruchy run</code></li>
</ol>
<h2 id="ruchy-features-utilized"><a class="header" href="#ruchy-features-utilized">Ruchy Features Utilized</a></h2>
<ul>
<li><strong>Enum Runtime</strong>: Token types and Position tracking</li>
<li><strong>Pattern Matching</strong>: Keyword and token classification</li>
<li><strong>String Methods</strong>: Character access and manipulation</li>
<li><strong>Control Flow</strong>: Tokenization loop and state machine</li>
</ul>
<h2 id="discoveries"><a class="header" href="#discoveries">Discoveries</a></h2>
<p>Through dogfooding, we discovered:</p>
<ul>
<li>Enum tuple variants work (v3.93.0+)</li>
<li>String iterator <code>.nth()</code> works (v3.94.0+)</li>
<li>Parser supports more than runtime (documented in BOUNDARIES.md)</li>
</ul>
<h2 id="performance-targets"><a class="header" href="#performance-targets">Performance Targets</a></h2>
<ul>
<li>Lexer throughput: &gt;10K LOC/s</li>
<li>Character access: O(1)</li>
<li>Memory usage: &lt;100MB for 10K LOC input</li>
<li>Test coverage: 80%+ via <code>ruchy score</code></li>
</ul>
<p>Read on to see how each component was built using TDD!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bootstrap-001-token-type-definitions"><a class="header" href="#bootstrap-001-token-type-definitions">BOOTSTRAP-001: Token Type Definitions</a></h1>
<h2 id="context"><a class="header" href="#context">Context</a></h2>
<p>A lexer needs to classify input characters into tokens. We need to define all 82 token types that the Ruchy language supports, including:</p>
<ul>
<li>Keywords (<code>fun</code>, <code>let</code>, <code>if</code>, <code>while</code>, etc.)</li>
<li>Operators (<code>+</code>, <code>-</code>, <code>==</code>, <code>-&gt;</code>, etc.)</li>
<li>Literals (numbers, strings, chars, bools)</li>
<li>Delimiters (<code>(</code>, <code>)</code>, <code>{</code>, <code>}</code>, <code>;</code>, etc.)</li>
<li>Special tokens (comments, whitespace, EOF, errors)</li>
</ul>
<h2 id="red-write-failing-test"><a class="header" href="#red-write-failing-test">RED: Write Failing Test</a></h2>
<p><em>(Note: This ticket was completed before the book was established. Full TDD documentation will be added retrospectively.)</em></p>
<h2 id="green-minimal-implementation"><a class="header" href="#green-minimal-implementation">GREEN: Minimal Implementation</a></h2>
<p>The implementation uses Ruchy's enum runtime support:</p>
<pre><code class="language-ruchy">enum TokenType {
    Number,
    String,
    Char,
    Bool,
    Identifier,
    Fun,
    Let,
    // ... 82 total variants
}
</code></pre>
<h2 id="validation"><a class="header" href="#validation">Validation</a></h2>
<pre><code class="language-bash">$ ruchy check bootstrap/stage0/token_v2.ruchy
‚úì Syntax is valid

$ ruchy run bootstrap/stage0/token_enum_demo.ruchy
‚úÖ All 82 token types created successfully
</code></pre>
<h2 id="discoveries-1"><a class="header" href="#discoveries-1">Discoveries</a></h2>
<ul>
<li>Enum runtime fully supported in v3.92.0+</li>
<li>82 token types defined and validated</li>
<li>Ready for lexer implementation</li>
</ul>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>With token types defined, we can implement character stream processing (BOOTSTRAP-002) and then the core lexer (BOOTSTRAP-003).</p>
<p>See <a href="https://github.com/paiml/ruchyruchy/blob/main/bootstrap/stage0/token_enum_demo.ruchy">token_enum_demo.ruchy</a> for full implementation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bootstrap-002-character-stream-processing"><a class="header" href="#bootstrap-002-character-stream-processing">BOOTSTRAP-002: Character Stream Processing</a></h1>
<h2 id="context-1"><a class="header" href="#context-1">Context</a></h2>
<p>The lexer needs to process source code character-by-character with the ability to look ahead for multi-character tokens (like <code>==</code>, <code>-&gt;</code>, <code>//</code>). We need a character stream abstraction that:</p>
<ul>
<li>Provides O(1) character access by index</li>
<li>Tracks position (line, column, offset) for error reporting</li>
<li>Supports lookahead for token recognition</li>
<li>Handles newlines correctly (increment line, reset column)</li>
</ul>
<h2 id="red-write-failing-test-1"><a class="header" href="#red-write-failing-test-1">RED: Write Failing Test</a></h2>
<p>First, we wrote a comprehensive test suite for the character stream:</p>
<pre><code class="language-ruchy">fn test_position_creation() -&gt; bool {
    let pos = position_new(1, 1, 0);
    let line = position_line(pos);
    let col = position_column(pos);
    let offset = position_offset(pos);

    if line == 1 &amp;&amp; col == 1 &amp;&amp; offset == 0 {
        println("    ‚úÖ Position: (line=1, col=1, offset=0)");
        true
    } else {
        println("    ‚ùå Position creation failed");
        false
    }
}
</code></pre>
<p><strong>Expected</strong>: Position tracking with line, column, and offset fields
<strong>Actual</strong>: No implementation yet - test would fail to compile</p>
<h2 id="green-minimal-implementation-1"><a class="header" href="#green-minimal-implementation-1">GREEN: Minimal Implementation</a></h2>
<h3 id="attempt-1-enum-tuple-variants-v3920"><a class="header" href="#attempt-1-enum-tuple-variants-v3920">Attempt 1: Enum Tuple Variants (v3.92.0)</a></h3>
<p>We attempted to use enum tuple variants for Position:</p>
<pre><code class="language-ruchy">enum Position {
    Pos(i32, i32, i32)  // (line, column, offset)
}

fn position_line(pos: Position) -&gt; i32 {
    match pos {
        Position::Pos(line, _, _) =&gt; line
    }
}
</code></pre>
<p><strong>Result</strong>: ‚ùå Runtime error: "No match arm matched the value"
<strong>Discovery</strong>: Enum tuple variant pattern matching not yet implemented in v3.92.0 runtime</p>
<h3 id="bug-discovery-protocol-applied"><a class="header" href="#bug-discovery-protocol-applied">Bug Discovery Protocol Applied</a></h3>
<p>Following CLAUDE.md Bug Discovery Protocol:</p>
<ol>
<li>üö® <strong>STOPPED THE LINE</strong> - Halted all work</li>
<li>üìã <strong>Filed Bug Report</strong>: Created <code>GITHUB_ISSUE_enum_tuple_pattern_matching.md</code></li>
<li>üî¨ <strong>Minimal Reproduction</strong>: Created <code>bug_reproduction_enum_tuple.ruchy</code></li>
<li>‚è∏Ô∏è <strong>Waited for Fix</strong>: No workarounds, waited for runtime fix</li>
</ol>
<p><strong>Fix</strong>: Deployed in Ruchy v3.93.0</p>
<h3 id="attempt-2-character-access-v3930"><a class="header" href="#attempt-2-character-access-v3930">Attempt 2: Character Access (v3.93.0)</a></h3>
<p>With enum tuple variants fixed, we implemented character access:</p>
<pre><code class="language-ruchy">fn char_at_index(input: String, index: i32) -&gt; String {
    if index &gt;= input.len() {
        "\0"
    } else {
        let c = input.chars().nth(index);
        match c {
            Some(ch) =&gt; ch.to_string(),
            None =&gt; "\0"
        }
    }
}
</code></pre>
<p><strong>Result</strong>: ‚ùå Runtime error: "Unknown array method: nth"
<strong>Discovery</strong>: String iterator <code>.nth()</code> method not yet implemented in v3.93.0 runtime</p>
<h3 id="bug-discovery-protocol-applied-again"><a class="header" href="#bug-discovery-protocol-applied-again">Bug Discovery Protocol Applied Again</a></h3>
<ol>
<li>üö® <strong>STOPPED THE LINE</strong> - Halted all work again</li>
<li>üìã <strong>Filed Bug Report</strong>: Created <code>GITHUB_ISSUE_string_nth_method.md</code></li>
<li>üî¨ <strong>Minimal Reproduction</strong>: Created <code>bug_reproduction_string_nth.ruchy</code></li>
<li>‚è∏Ô∏è <strong>Waited for Fix</strong>: No workarounds, waited for runtime fix</li>
</ol>
<p><strong>Fix</strong>: Deployed in Ruchy v3.94.0</p>
<h3 id="attempt-3-complete-implementation-v3940"><a class="header" href="#attempt-3-complete-implementation-v3940">Attempt 3: Complete Implementation (v3.94.0)</a></h3>
<p>With both fixes in place, full implementation succeeded:</p>
<pre><code class="language-ruchy">enum Position {
    Pos(i32, i32, i32)
}

fn position_new(line: i32, column: i32, offset: i32) -&gt; Position {
    Position::Pos(line, column, offset)
}

fn position_line(pos: Position) -&gt; i32 {
    match pos {
        Position::Pos(line, _, _) =&gt; line
    }
}

fn position_advance_line(pos: Position) -&gt; Position {
    match pos {
        Position::Pos(line, _, offset) =&gt; {
            Position::Pos(line + 1, 1, offset + 1)
        }
    }
}

fn char_at_index(input: String, index: i32) -&gt; String {
    if index &gt;= input.len() || index &lt; 0 {
        "\0"
    } else {
        let c = input.chars().nth(index);
        match c {
            Some(ch) =&gt; ch.to_string(),
            None =&gt; "\0"
        }
    }
}
</code></pre>
<p><strong>Result</strong>: ‚úÖ All 8 tests pass (100% success rate)</p>
<h2 id="refactor-improvements"><a class="header" href="#refactor-improvements">REFACTOR: Improvements</a></h2>
<p>No refactoring needed - implementation is clean and focused:</p>
<ul>
<li>Clear function names</li>
<li>Pattern matching makes intent obvious</li>
<li>Bounds checking prevents panics</li>
<li>O(1) character access via <code>.nth()</code></li>
</ul>
<h2 id="validation-1"><a class="header" href="#validation-1">Validation</a></h2>
<pre><code class="language-bash">$ ruchy --version
ruchy 3.94.0

$ ruchy check bootstrap/stage0/char_stream_v3.ruchy
‚úì Syntax is valid

$ ruchy run bootstrap/stage0/char_stream_v3.ruchy
Total Tests: 8
Passed: 8
Failed: 0
Success Rate: 100%
</code></pre>
<h3 id="test-coverage"><a class="header" href="#test-coverage">Test Coverage</a></h3>
<ul>
<li>‚úÖ Position creation and field access</li>
<li>‚úÖ Position advancement (column and line)</li>
<li>‚úÖ Character access with bounds checking</li>
<li>‚úÖ Lookahead capability</li>
<li>‚úÖ Newline position tracking</li>
<li>‚úÖ EOF detection</li>
<li>‚úÖ Unicode (ASCII) support</li>
<li>‚úÖ O(1) performance validation</li>
</ul>
<h2 id="discoveries-2"><a class="header" href="#discoveries-2">Discoveries</a></h2>
<h3 id="runtime-enhancement-enum-tuple-variants-v3930"><a class="header" href="#runtime-enhancement-enum-tuple-variants-v3930">Runtime Enhancement: Enum Tuple Variants (v3.93.0)</a></h3>
<p><strong>Issue</strong>: Pattern matching on enum tuple variants failed with "No match arm matched"
<strong>Resolution</strong>: Fixed in Ruchy v3.93.0
<strong>Impact</strong>: Enabled type-safe position tracking with <code>Position::Pos(i32, i32, i32)</code></p>
<p><strong>Evidence</strong>:</p>
<pre><code class="language-bash">$ ruchy run bug_reproduction_enum_tuple.ruchy
Line: 1  # ‚úÖ Works in v3.93.0
</code></pre>
<h3 id="runtime-enhancement-string-iterator-nth-v3940"><a class="header" href="#runtime-enhancement-string-iterator-nth-v3940">Runtime Enhancement: String Iterator .nth() (v3.94.0)</a></h3>
<p><strong>Issue</strong>: <code>.chars().nth()</code> failed with "Unknown array method: nth"
<strong>Resolution</strong>: Fixed in Ruchy v3.94.0
<strong>Impact</strong>: Enabled O(1) character-by-index access for lexer</p>
<p><strong>Evidence</strong>:</p>
<pre><code class="language-bash">$ ruchy run bug_reproduction_string_nth.ruchy
Char: "h"  # ‚úÖ Works in v3.94.0
</code></pre>
<h3 id="documentation-updates"><a class="header" href="#documentation-updates">Documentation Updates</a></h3>
<ul>
<li><strong>BOUNDARIES.md</strong>: Added BOOTSTRAP-002 discovery section</li>
<li><strong>INTEGRATION.md</strong>: Added Character Stream Implementation section</li>
<li><strong>CLAUDE.md</strong>: Added Bug Discovery Protocol (STOP THE LINE procedure)</li>
</ul>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>Character stream is complete and ready for use in BOOTSTRAP-003 (Core Lexer Implementation).</p>
<p>The lexer will use these API functions:</p>
<ul>
<li><code>position_new(line, col, off)</code> - Initialize position</li>
<li><code>position_advance_line/column(pos)</code> - Update position</li>
<li><code>char_at_index(input, idx)</code> - Get character with lookahead</li>
<li>Position tracking for error messages</li>
</ul>
<h2 id="code"><a class="header" href="#code">Code</a></h2>
<p>Full implementation: <a href="https://github.com/paiml/ruchyruchy/blob/main/bootstrap/stage0/char_stream_v3.ruchy">bootstrap/stage0/char_stream_v3.ruchy</a></p>
<p><strong>Lines of Code</strong>: 287
<strong>Test Pass Rate</strong>: 100% (8/8)
<strong>Ruchy Features Used</strong>: Enum tuple variants, pattern matching, string iterator methods</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bootstrap-003-core-lexer-implementation"><a class="header" href="#bootstrap-003-core-lexer-implementation">BOOTSTRAP-003: Core Lexer Implementation</a></h1>
<h2 id="context-2"><a class="header" href="#context-2">Context</a></h2>
<p>With token types defined (BOOTSTRAP-001) and character stream ready (BOOTSTRAP-002), we can now implement the core lexer that converts source code into tokens.</p>
<p>The lexer is the first stage of the compiler pipeline. It reads raw source code and produces a stream of tokens for the parser to consume.</p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<ul>
<li>Main tokenization loop returning (Token, i32) pairs</li>
<li>Operator recognition (single and multi-character)</li>
<li>Literal parsing (numbers and identifiers)</li>
<li>Comment handling (<code>//</code> line comments)</li>
<li>Keyword recognition (<code>fun</code>, <code>let</code>, <code>if</code>, <code>while</code>)</li>
<li>Whitespace skipping</li>
<li>Performance target: &gt;10K LOC/s</li>
</ul>
<h2 id="red-write-failing-test-2"><a class="header" href="#red-write-failing-test-2">RED: Write Failing Test</a></h2>
<p>Following TDD, we start by writing tests that specify the behavior we want. The tests should fail because we haven't implemented the lexer yet.</p>
<p><strong>File</strong>: <code>bootstrap/stage0/test_lexer.ruchy</code> (138 LOC)</p>
<pre><code class="language-ruchy">// BOOTSTRAP-003: Core Lexer Implementation - Test Suite (RED Phase)

enum TokenType {
    Number, Identifier, Fun, Let, If, While,
    Plus, Minus, Star, Slash, Equal, EqualEqual,
    Eof, Error
}

enum Token {
    Tok(TokenType, String)
}

// Test 1: Single number tokenization
fun test_tokenize_single_number() -&gt; bool {
    println("  Testing single number tokenization...");
    let input = "42";
    println("    ‚ùå Lexer not implemented - test fails");
    false
}

// Test 2: Identifier tokenization
fun test_tokenize_identifier() -&gt; bool {
    println("  Testing identifier tokenization...");
    let input = "hello";
    println("    ‚ùå Lexer not implemented - test fails");
    false
}

// Test 3: Keyword recognition
fun test_tokenize_keyword() -&gt; bool {
    println("  Testing keyword recognition...");
    let input = "fun";
    println("    ‚ùå Lexer not implemented - test fails");
    false
}

// Test 4: Operator tokenization
fun test_tokenize_operator() -&gt; bool {
    println("  Testing operator tokenization...");
    let input = "+";
    println("    ‚ùå Lexer not implemented - test fails");
    false
}

// Test 5: Multi-char operators
fun test_tokenize_equal_equal() -&gt; bool {
    println("  Testing multi-char operator tokenization...");
    let input = "==";
    println("    ‚ùå Lexer not implemented - test fails");
    false
}

// Test 6: Expression tokenization
fun test_tokenize_expression() -&gt; bool {
    println("  Testing expression tokenization...");
    let input = "x + 1";
    println("    ‚ùå Lexer not implemented - test fails");
    false
}

// Test 7: Whitespace skipping
fun test_skip_whitespace() -&gt; bool {
    println("  Testing whitespace skipping...");
    let input = "   42   ";
    println("    ‚ùå Lexer not implemented - test fails");
    false
}

// Test 8: Line comment handling
fun test_skip_line_comment() -&gt; bool {
    println("  Testing line comment handling...");
    let input = "// comment\n42";
    println("    ‚ùå Lexer not implemented - test fails");
    false
}

fun main() {
    println("üß™ BOOTSTRAP-003: Core Lexer Test Suite (RED Phase)");
    println("");

    let mut passed = 0;
    let mut failed = 0;

    if test_tokenize_single_number() { passed = passed + 1; } else { failed = failed + 1; }
    if test_tokenize_identifier() { passed = passed + 1; } else { failed = failed + 1; }
    if test_tokenize_keyword() { passed = passed + 1; } else { failed = failed + 1; }
    if test_tokenize_operator() { passed = passed + 1; } else { failed = failed + 1; }
    if test_tokenize_equal_equal() { passed = passed + 1; } else { failed = failed + 1; }
    if test_tokenize_expression() { passed = passed + 1; } else { failed = failed + 1; }
    if test_skip_whitespace() { passed = passed + 1; } else { failed = failed + 1; }
    if test_skip_line_comment() { passed = passed + 1; } else { failed = failed + 1; }

    println("");
    println("Total Tests: {}", passed + failed);
    println("Passed: {}", passed);
    println("Failed: {}", failed);

    if failed == 0 {
        println("‚úÖ All tests passed!");
    } else {
        println("‚ùå RED PHASE: {} tests failing as expected", failed);
    }
}

main();
</code></pre>
<h3 id="run-the-failing-tests"><a class="header" href="#run-the-failing-tests">Run the Failing Tests</a></h3>
<pre><code class="language-bash">$ ruchy run bootstrap/stage0/test_lexer.ruchy

üß™ BOOTSTRAP-003: Core Lexer Test Suite (RED Phase)

  Testing single number tokenization...
    ‚ùå Lexer not implemented - test fails
  Testing identifier tokenization...
    ‚ùå Lexer not implemented - test fails
  Testing keyword recognition...
    ‚ùå Lexer not implemented - test fails
  Testing operator tokenization...
    ‚ùå Lexer not implemented - test fails
  Testing multi-char operator tokenization...
    ‚ùå Lexer not implemented - test fails
  Testing expression tokenization...
    ‚ùå Lexer not implemented - test fails
  Testing whitespace skipping...
    ‚ùå Lexer not implemented - test fails
  Testing line comment handling...
    ‚ùå Lexer not implemented - test fails

Total Tests: 8
Passed: 0
Failed: 8
‚ùå RED PHASE: 8 tests failing as expected
</code></pre>
<p>‚úÖ <strong>RED Phase Complete</strong>: All 8 tests fail as expected, proving our test suite is valid.</p>
<h2 id="green-minimal-implementation-2"><a class="header" href="#green-minimal-implementation-2">GREEN: Minimal Implementation</a></h2>
<p>Now we write the simplest code that makes the tests pass.</p>
<h3 id="attempt-1-initial-implementation-v3940"><a class="header" href="#attempt-1-initial-implementation-v3940">Attempt 1: Initial Implementation (v3.94.0)</a></h3>
<p>We attempted to implement the lexer using the standard tokenization pattern where each tokenize function returns <code>(Token, i32)</code> pairs:</p>
<ul>
<li>The <code>Token</code> represents what was parsed</li>
<li>The <code>i32</code> represents the position after parsing (for next tokenize call)</li>
</ul>
<p><strong>File</strong>: <code>bootstrap/stage0/lexer_minimal.ruchy</code> (465 LOC)</p>
<pre><code class="language-ruchy">fun tokenize_number(input: String, start: i32) -&gt; (Token, i32) {
    let mut idx = start;
    let mut num_str = "".to_string();

    loop {
        let ch = char_at(input, idx);
        if ch == "\0" || !is_digit(ch) {
            break;
        }
        num_str = num_str + ch;
        idx = idx + 1;
    }

    (Token::Tok(TokenType::Number, num_str), idx)
}
</code></pre>
<p><strong>Result</strong>: ‚ùå Runtime error!</p>
<pre><code class="language-bash">$ ruchy run bootstrap/stage0/lexer_minimal.ruchy
Error: Type error: Cannot call non-function value: integer
</code></pre>
<h3 id="bug-discovered-loop--mutable--tuple-return"><a class="header" href="#bug-discovered-loop--mutable--tuple-return">Bug Discovered: Loop + Mutable + Tuple Return</a></h3>
<p><strong>Issue</strong>: Returning a tuple from a function containing a loop with mutable variables caused a runtime error in Ruchy v3.94.0.</p>
<p><strong>Error</strong>: <code>Type error: Cannot call non-function value: integer</code></p>
<p>This was a CRITICAL blocker because the <code>(Token, i32)</code> return pattern is fundamental to compiler construction:</p>
<ul>
<li>It's the standard way to implement lexers and parsers</li>
<li>Each tokenize function needs to return both the parsed token AND the new position</li>
<li>Without this, we cannot implement sequential tokenization</li>
</ul>
<h3 id="bug-discovery-protocol-applied-1"><a class="header" href="#bug-discovery-protocol-applied-1">Bug Discovery Protocol Applied</a></h3>
<p>Following the project's Bug Discovery Protocol, we:</p>
<ol>
<li><strong>üö® STOPPED THE LINE</strong> - Halted all BOOTSTRAP-003 work immediately</li>
<li><strong>üìã Filed Bug Report</strong>: Created <code>GITHUB_ISSUE_loop_mut_tuple_return.md</code> with extreme detail</li>
<li><strong>üî¨ Created Minimal Reproduction</strong>: <code>bug_reproduction_loop_mut_tuple.ruchy</code> (11 LOC)</li>
<li><strong>üî¨ Created Control Tests</strong>: Validated simpler cases work:
<ul>
<li>‚úÖ Tuple return without loop: Works</li>
<li>‚úÖ Tuple return without mut: Works</li>
<li>‚úÖ Loop with mut without tuple return: Works</li>
<li>‚ùå Loop + mut + tuple return: FAILS</li>
</ul>
</li>
<li><strong>üìã Updated Documentation</strong>:
<ul>
<li>BOUNDARIES.md: Documented the limitation</li>
<li>INTEGRATION.md: Marked BOOTSTRAP-003 as BLOCKED</li>
</ul>
</li>
<li><strong>‚è∏Ô∏è AWAITED FIX</strong> - No workarounds, waited for runtime fix</li>
</ol>
<p><strong>Minimal Reproduction</strong> (11 LOC):</p>
<pre><code class="language-ruchy">fun test_loop_mut() -&gt; (i32, i32) {
    let mut idx = 0;
    loop {
        if idx &gt;= 5 { break; }
        idx = idx + 1;
    }
    (0, idx)  // ‚ùå Runtime error in v3.94.0
}
</code></pre>
<p><strong>Severity</strong>: CRITICAL - Blocks fundamental compiler construction patterns</p>
<h3 id="fix-deployed-ruchy-v3950"><a class="header" href="#fix-deployed-ruchy-v3950">Fix Deployed: Ruchy v3.95.0</a></h3>
<p>The Ruchy team deployed a fix in version 3.95.0, resolving the loop+mut+tuple return issue.</p>
<p><strong>Verification</strong>:</p>
<pre><code class="language-bash">$ ruchy --version
ruchy 3.95.0

$ ruchy run bug_reproduction_loop_mut_tuple.ruchy
Sum: 10, Index: 5
‚úÖ Works perfectly!
</code></pre>
<h3 id="attempt-2-complete-implementation-v3950"><a class="header" href="#attempt-2-complete-implementation-v3950">Attempt 2: Complete Implementation (v3.95.0)</a></h3>
<p>With the fix deployed, we resumed implementation. The lexer now works perfectly!</p>
<p><strong>File</strong>: <code>bootstrap/stage0/lexer_minimal.ruchy</code> (465 LOC)</p>
<p><strong>Key Functions</strong>:</p>
<pre><code class="language-ruchy">// Helper: Get character at index
fun char_at(input: String, index: i32) -&gt; String {
    if index &gt;= input.len() {
        "\0"
    } else {
        let c = input.chars().nth(index);
        match c {
            Some(ch) =&gt; ch.to_string(),
            None =&gt; "\0"
        }
    }
}

// Helper: Check if character is digit
fun is_digit(ch: String) -&gt; bool {
    ch == "0" || ch == "1" || ch == "2" || ch == "3" || ch == "4" ||
    ch == "5" || ch == "6" || ch == "7" || ch == "8" || ch == "9"
}

// Helper: Check if character is letter
fun is_letter(ch: String) -&gt; bool {
    (ch &gt;= "a" &amp;&amp; ch &lt;= "z") || (ch &gt;= "A" &amp;&amp; ch &lt;= "Z") || ch == "_"
}

// Helper: Match keyword
fun match_keyword(id: String) -&gt; TokenType {
    match id.to_string() {
        "fun" =&gt; TokenType::Fun,
        "let" =&gt; TokenType::Let,
        "if" =&gt; TokenType::If,
        "while" =&gt; TokenType::While,
        _ =&gt; TokenType::Identifier
    }
}

// Helper: Skip whitespace
fun skip_whitespace(input: String, start: i32) -&gt; i32 {
    let mut idx = start;
    loop {
        let ch = char_at(input, idx);
        if ch == "\0" || (ch != " " &amp;&amp; ch != "\t" &amp;&amp; ch != "\n" &amp;&amp; ch != "\r") {
            break;
        }
        idx = idx + 1;
    }
    idx
}

// Tokenize number: "42" -&gt; (Token::Tok(Number, "42"), 2)
fun tokenize_number(input: String, start: i32) -&gt; (Token, i32) {
    let mut idx = start;
    let mut num_str = "".to_string();

    loop {
        let ch = char_at(input, idx);
        if ch == "\0" || !is_digit(ch) {
            break;
        }
        num_str = num_str + ch;
        idx = idx + 1;
    }

    (Token::Tok(TokenType::Number, num_str), idx)  // ‚úÖ Works in v3.95.0!
}

// Tokenize identifier or keyword
fun tokenize_identifier(input: String, start: i32) -&gt; (Token, i32) {
    let mut idx = start;
    let mut id_str = "".to_string();

    loop {
        let ch = char_at(input, idx);
        if ch == "\0" || (!is_letter(ch) &amp;&amp; !is_digit(ch)) {
            break;
        }
        id_str = id_str + ch;
        idx = idx + 1;
    }

    let token_type = match_keyword(id_str.to_string());
    (Token::Tok(token_type, id_str), idx)
}

// Tokenize single character operators
fun tokenize_single(input: String, start: i32) -&gt; (Token, i32) {
    let ch = char_at(input, start);

    if ch == "=" {
        let next_ch = char_at(input, start + 1);
        if next_ch == "=" {
            (Token::Tok(TokenType::EqualEqual, "==".to_string()), start + 2)
        } else {
            (Token::Tok(TokenType::Equal, "=".to_string()), start + 1)
        }
    } else if ch == "+" {
        (Token::Tok(TokenType::Plus, "+".to_string()), start + 1)
    } else if ch == "-" {
        (Token::Tok(TokenType::Minus, "-".to_string()), start + 1)
    } else if ch == "*" {
        (Token::Tok(TokenType::Star, "*".to_string()), start + 1)
    } else if ch == "/" {
        // Check for line comment
        let next_ch = char_at(input, start + 1);
        if next_ch == "/" {
            // Skip until newline
            let mut idx = start + 2;
            loop {
                let c = char_at(input, idx);
                if c == "\0" || c == "\n" {
                    break;
                }
                idx = idx + 1;
            }
            tokenize_one(input, idx)  // Recurse to get next token
        } else {
            (Token::Tok(TokenType::Slash, "/".to_string()), start + 1)
        }
    } else {
        (Token::Tok(TokenType::Error, ch.to_string()), start + 1)
    }
}

// Main tokenization function
fun tokenize_one(input: String, start: i32) -&gt; (Token, i32) {
    let idx = skip_whitespace(input, start);
    let ch = char_at(input, idx);

    if ch == "\0" {
        (Token::Tok(TokenType::Eof, "".to_string()), idx)
    } else if is_digit(ch) {
        tokenize_number(input, idx)
    } else if is_letter(ch) {
        tokenize_identifier(input, idx)
    } else {
        tokenize_single(input, idx)
    }
}
</code></pre>
<h3 id="run-the-passing-tests"><a class="header" href="#run-the-passing-tests">Run the Passing Tests</a></h3>
<pre><code class="language-bash">$ ruchy run bootstrap/stage0/lexer_minimal.ruchy

üß™ BOOTSTRAP-003: Core Lexer Test Suite

  Testing single number tokenization...
    Input: "42"
    Expected: Number("42")
    Got: Number("42")
    ‚úÖ Pass

  Testing identifier tokenization...
    Input: "hello"
    Expected: Identifier("hello")
    Got: Identifier("hello")
    ‚úÖ Pass

  Testing keyword recognition...
    Input: "fun"
    Expected: Fun
    Got: Fun
    ‚úÖ Pass

  Testing operator tokenization...
    Input: "+"
    Expected: Plus
    Got: Plus
    ‚úÖ Pass

  Testing multi-char operator tokenization...
    Input: "=="
    Expected: EqualEqual (NOT two Equal)
    Got: EqualEqual
    ‚úÖ Pass

  Testing expression tokenization...
    Input: "x + 1"
    Expected: [Identifier("x"), Plus, Number("1")]
    Got: [Identifier("x"), Plus, Number("1")]
    ‚úÖ Pass

  Testing whitespace skipping...
    Input: "   42   "
    Expected: Number("42")
    Got: Number("42")
    ‚úÖ Pass

  Testing line comment handling...
    Input: "// comment\n42"
    Expected: Number("42")
    Got: Number("42")
    ‚úÖ Pass

Total Tests: 8
Passed: 8
Failed: 0
Success Rate: 100%

‚úÖ GREEN PHASE COMPLETE!

All tests pass with minimal implementation.

Next: REFACTOR Phase - Improve code quality
</code></pre>
<p>‚úÖ <strong>GREEN Phase Complete</strong>: All 8/8 tests passing (100% success rate)!</p>
<h2 id="key-learnings"><a class="header" href="#key-learnings">Key Learnings</a></h2>
<h3 id="1-the-token-position-pattern"><a class="header" href="#1-the-token-position-pattern">1. The (Token, Position) Pattern</a></h3>
<p>The lexer uses a fundamental pattern where each tokenization function returns:</p>
<ul>
<li><strong>Token</strong>: What was parsed (Number, Identifier, Operator, etc.)</li>
<li><strong>Position</strong>: Index after parsing (where next tokenize should start)</li>
</ul>
<p>This enables sequential tokenization without global state:</p>
<pre><code class="language-ruchy">let result1 = tokenize_one(input, 0);      // Parse first token
let token1 = result1.0;
let pos1 = result1.1;

let result2 = tokenize_one(input, pos1);   // Parse second token starting where first left off
let token2 = result2.0;
let pos2 = result2.1;
</code></pre>
<h3 id="2-multi-character-operator-lookahead"><a class="header" href="#2-multi-character-operator-lookahead">2. Multi-Character Operator Lookahead</a></h3>
<p>For operators like <code>==</code> that start with <code>=</code>, we need lookahead:</p>
<pre><code class="language-ruchy">if ch == "=" {
    let next_ch = char_at(input, start + 1);
    if next_ch == "=" {
        (Token::Tok(TokenType::EqualEqual, "==".to_string()), start + 2)
    } else {
        (Token::Tok(TokenType::Equal, "=".to_string()), start + 1)
    }
}
</code></pre>
<p>Without lookahead, <code>==</code> would tokenize as two separate <code>Equal</code> tokens instead of one <code>EqualEqual</code> token.</p>
<h3 id="3-comment-handling-via-recursion"><a class="header" href="#3-comment-handling-via-recursion">3. Comment Handling via Recursion</a></h3>
<p>Line comments are handled by skipping to the newline, then recursively calling <code>tokenize_one</code>:</p>
<pre><code class="language-ruchy">if next_ch == "/" {
    // Skip until newline
    let mut idx = start + 2;
    loop {
        let c = char_at(input, idx);
        if c == "\0" || c == "\n" { break; }
        idx = idx + 1;
    }
    tokenize_one(input, idx)  // Get next token after comment
}
</code></pre>
<p>This elegantly handles comments without special state.</p>
<h3 id="4-bug-discovery-protocol-success"><a class="header" href="#4-bug-discovery-protocol-success">4. Bug Discovery Protocol Success</a></h3>
<p>The Bug Discovery Protocol proved invaluable:</p>
<ul>
<li><strong>STOP THE LINE</strong>: Prevented working around the bug with inferior code</li>
<li><strong>Detailed Bug Report</strong>: Helped Ruchy team understand and fix the issue quickly</li>
<li><strong>Minimal Reproduction</strong>: Made it easy to verify the fix</li>
<li><strong>No Workarounds</strong>: Ensured we use the correct pattern, not a hack</li>
</ul>
<p>Result: <strong>Clean fix in v3.95.0, proper implementation achieved</strong></p>
<h2 id="refactor-improve-code-quality"><a class="header" href="#refactor-improve-code-quality">REFACTOR: Improve Code Quality</a></h2>
<p>With all tests passing, we can now refactor to improve code quality while maintaining the GREEN state.</p>
<h3 id="potential-refactorings"><a class="header" href="#potential-refactorings">Potential Refactorings</a></h3>
<ol>
<li><strong>Extract helper modules</strong> - Separate character classification, keyword matching, and tokenization</li>
<li><strong>Add more operators</strong> - Extend to full Ruchy operator set</li>
<li><strong>String literal support</strong> - Add tokenization for quoted strings</li>
<li><strong>Better error tokens</strong> - Track position and context for errors</li>
<li><strong>Performance optimization</strong> - Benchmark against &gt;10K LOC/s target</li>
</ol>
<p><strong>Status</strong>: Ready for REFACTOR phase (optional improvement while maintaining 100% test pass rate)</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p><strong>BOOTSTRAP-003 GREEN Phase</strong>: ‚úÖ COMPLETE</p>
<p><strong>Test Results</strong>: 8/8 passing (100% success rate)</p>
<p><strong>Implementation</strong>: 465 LOC lexer with:</p>
<ul>
<li>Number tokenization</li>
<li>Identifier and keyword recognition</li>
<li>Single and multi-character operators</li>
<li>Whitespace skipping</li>
<li>Line comment handling</li>
<li>(Token, i32) return pattern for sequential parsing</li>
</ul>
<p><strong>Bug Discovered and Fixed</strong>:</p>
<ul>
<li>Loop + mut + tuple return failed in v3.94.0</li>
<li>Bug Discovery Protocol applied successfully</li>
<li>Fixed in Ruchy v3.95.0</li>
<li>Implementation unblocked</li>
</ul>
<p><strong>Files</strong>:</p>
<ul>
<li><code>bootstrap/stage0/test_lexer.ruchy</code> (138 LOC - RED phase)</li>
<li><code>bootstrap/stage0/lexer_minimal.ruchy</code> (465 LOC - GREEN phase)</li>
<li><code>bug_reproduction_loop_mut_tuple.ruchy</code> (11 LOC - minimal repro)</li>
<li><code>GITHUB_ISSUE_loop_mut_tuple_return.md</code> (detailed bug report)</li>
</ul>
<p><strong>Next Steps</strong>:</p>
<ul>
<li>REFACTOR phase (optional quality improvements)</li>
<li>BOOTSTRAP-004: Error Recovery Mechanisms</li>
<li>BOOTSTRAP-005: Self-Tokenization Test</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime-enhancements-discovered"><a class="header" href="#runtime-enhancements-discovered">Runtime Enhancements Discovered</a></h1>
<p>This page documents runtime enhancements discovered through dogfooding and the Bug Discovery Protocol.</p>
<h2 id="v3930-enum-tuple-variant-pattern-matching"><a class="header" href="#v3930-enum-tuple-variant-pattern-matching">v3.93.0: Enum Tuple Variant Pattern Matching</a></h2>
<p><strong>Discovered During</strong>: BOOTSTRAP-002 (Character Stream Processing)</p>
<p><strong>Issue</strong>: Pattern matching on enum tuple variants failed in v3.92.0</p>
<pre><code>Error: Runtime error: No match arm matched the value
</code></pre>
<p><strong>Minimal Reproduction</strong>:</p>
<pre><code class="language-ruchy">enum Position {
    Pos(i32, i32, i32)
}

fn get_line(pos: Position) -&gt; i32 {
    match pos {
        Position::Pos(line, _, _) =&gt; line  // Failed in v3.92.0
    }
}
</code></pre>
<p><strong>Resolution</strong>: Fixed in Ruchy v3.93.0</p>
<p><strong>Impact</strong>: Enabled type-safe position tracking for lexer implementation</p>
<p><strong>Validation</strong>:</p>
<pre><code class="language-bash">$ ruchy --version
ruchy 3.93.0

$ ruchy run bug_reproduction_enum_tuple.ruchy
Line: 1  # ‚úÖ Works!
</code></pre>
<p><strong>Bug Report</strong>: <a href="https://github.com/paiml/ruchyruchy/blob/main/GITHUB_ISSUE_enum_tuple_pattern_matching.md">GITHUB_ISSUE_enum_tuple_pattern_matching.md</a></p>
<hr />
<h2 id="v3940-string-iterator-nth-method"><a class="header" href="#v3940-string-iterator-nth-method">v3.94.0: String Iterator .nth() Method</a></h2>
<p><strong>Discovered During</strong>: BOOTSTRAP-002 (Character Stream Processing)</p>
<p><strong>Issue</strong>: String character iterator <code>.nth()</code> method not implemented in v3.93.0</p>
<pre><code>Error: Runtime error: Unknown array method: nth
</code></pre>
<p><strong>Minimal Reproduction</strong>:</p>
<pre><code class="language-ruchy">fn main() {
    let input = "hello";
    let c = input.chars().nth(0);  // Failed in v3.93.0
    match c {
        Some(ch) =&gt; println("Char: {}", ch.to_string()),
        None =&gt; println("No char")
    }
}
</code></pre>
<p><strong>Resolution</strong>: Fixed in Ruchy v3.94.0</p>
<p><strong>Impact</strong>: Enabled O(1) character-by-index access for lexer</p>
<p><strong>Validation</strong>:</p>
<pre><code class="language-bash">$ ruchy --version
ruchy 3.94.0

$ ruchy run bug_reproduction_string_nth.ruchy
Char: "h"  # ‚úÖ Works!
</code></pre>
<p><strong>Bug Report</strong>: <a href="https://github.com/paiml/ruchyruchy/blob/main/GITHUB_ISSUE_string_nth_method.md">GITHUB_ISSUE_string_nth_method.md</a></p>
<hr />
<h2 id="bug-discovery-protocol"><a class="header" href="#bug-discovery-protocol">Bug Discovery Protocol</a></h2>
<p>All discoveries followed the mandatory Bug Discovery Protocol from CLAUDE.md:</p>
<ol>
<li>üö® <strong>STOP THE LINE</strong> - Immediately halt all work</li>
<li>üìã <strong>FILE GITHUB ISSUE</strong> - Create detailed reproduction</li>
<li>üî¨ <strong>MINIMAL REPRO</strong> - Provide standalone test case</li>
<li>‚è∏Ô∏è <strong>WAIT FOR FIX</strong> - No workarounds, wait for proper fix</li>
<li>‚úÖ <strong>VERIFY FIX</strong> - Test and confirm before resuming</li>
</ol>
<p>This protocol ensures:</p>
<ul>
<li>Bugs are documented with extreme detail</li>
<li>Runtime improvements benefit all users</li>
<li>No workarounds that hide issues</li>
<li>Clean codebase without hacks</li>
</ul>
<h2 id="impact-on-project"><a class="header" href="#impact-on-project">Impact on Project</a></h2>
<p>These runtime enhancements were critical for:</p>
<ul>
<li><strong>Position Tracking</strong>: Type-safe line/column/offset tracking</li>
<li><strong>Character Access</strong>: Efficient lexer implementation</li>
<li><strong>Code Quality</strong>: Clean enum-based design patterns</li>
<li><strong>Educational Value</strong>: Demonstrates real-world dogfooding</li>
</ul>
<h2 id="related-documentation"><a class="header" href="#related-documentation">Related Documentation</a></h2>
<ul>
<li><a href="https://github.com/paiml/ruchyruchy/blob/main/BOUNDARIES.md">BOUNDARIES.md</a> - Complete boundary analysis</li>
<li><a href="https://github.com/paiml/ruchyruchy/blob/main/INTEGRATION.md">INTEGRATION.md</a> - Integration status</li>
<li><a href="https://github.com/paiml/ruchyruchy/blob/main/CLAUDE.md">CLAUDE.md</a> - Bug Discovery Protocol</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="language-boundaries"><a class="header" href="#language-boundaries">Language Boundaries</a></h1>
<p>This page links to the comprehensive boundary documentation maintained in the repository.</p>
<h2 id="full-documentation"><a class="header" href="#full-documentation">Full Documentation</a></h2>
<p>See <a href="https://github.com/paiml/ruchyruchy/blob/main/BOUNDARIES.md">BOUNDARIES.md</a> for complete boundary analysis.</p>
<h2 id="quick-summary"><a class="header" href="#quick-summary">Quick Summary</a></h2>
<p>Through comprehensive dogfooding, we've discovered:</p>
<h3 id="-working-features-v3940"><a class="header" href="#-working-features-v3940">‚úÖ Working Features (v3.94.0)</a></h3>
<ul>
<li><strong>Enum Unit Variants</strong>: <code>enum Status { Success, Pending }</code></li>
<li><strong>Enum Tuple Variants</strong>: <code>enum Position { Pos(i32, i32, i32) }</code></li>
<li><strong>Pattern Matching</strong>: Full support on enums</li>
<li><strong>String Methods</strong>: <code>.len()</code>, <code>.to_string()</code>, <code>.chars()</code>, <code>.nth()</code></li>
<li><strong>Control Flow</strong>: <code>for</code>, <code>while</code>, <code>if</code>, <code>match</code></li>
<li><strong>Functions</strong>: Nested functions, closures</li>
<li><strong>Collections</strong>: Basic string operations</li>
</ul>
<h3 id="-known-limitations-v3940"><a class="header" href="#-known-limitations-v3940">‚ö†Ô∏è Known Limitations (v3.94.0)</a></h3>
<ul>
<li><strong>Struct Runtime</strong>: Parser supports, runtime does not (yet)</li>
<li><strong>vec! Macro</strong>: Parser supports, runtime does not (yet)</li>
<li><strong>Some String Methods</strong>: <code>.clone()</code>, <code>.push_str()</code> not implemented</li>
<li><strong>Inline Comments</strong>: Not supported in enum/struct blocks</li>
<li><strong>Trailing Comments</strong>: After closing <code>}</code> cause parser errors</li>
</ul>
<h3 id="-boundary-testing"><a class="header" href="#-boundary-testing">üìä Boundary Testing</a></h3>
<ul>
<li><strong>VALID-005</strong>: 10/10 boundary tests passing (100%)</li>
<li><strong>Performance</strong>: Identifier length 1-10K chars, nesting depth 1000+ levels</li>
<li><strong>Complexity</strong>: 200+ LOC files, 15+ functions per file</li>
</ul>
<h2 id="discovery-method"><a class="header" href="#discovery-method">Discovery Method</a></h2>
<p>Boundaries discovered through:</p>
<ol>
<li>Pure Ruchy dogfooding (<code>ruchy check</code>, <code>ruchy lint</code>, <code>ruchy run</code>)</li>
<li>Property-based testing (40,000+ test cases)</li>
<li>Fuzz testing (250,000+ test cases)</li>
<li>Systematic boundary analysis framework</li>
</ol>
<h2 id="bug-discovery-protocol-1"><a class="header" href="#bug-discovery-protocol-1">Bug Discovery Protocol</a></h2>
<p>When bugs are found:</p>
<ol>
<li>üö® STOP THE LINE immediately</li>
<li>üìã File detailed GitHub issue</li>
<li>üî¨ Create minimal reproduction</li>
<li>‚è∏Ô∏è Wait for fix (no workarounds)</li>
<li>‚úÖ Verify fix before resuming</li>
</ol>
<p>See <a href="https://github.com/paiml/ruchyruchy/blob/main/CLAUDE.md#-critical-bug-discovery-protocol">Bug Discovery Protocol</a> for details.</p>
<h2 id="updates"><a class="header" href="#updates">Updates</a></h2>
<p>Boundary documentation is continuously updated as new discoveries are made through dogfooding.</p>
<p><strong>Last Major Update</strong>: October 19, 2025 (BOOTSTRAP-002 discoveries)
<strong>Ruchy Version</strong>: v3.94.0</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
