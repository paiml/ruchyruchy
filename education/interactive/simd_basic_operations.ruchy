// simd_basic_operations.ruchy
//
// This file demonstrates the basic SIMD operations available in WebAssembly
// and how they can be used for performance optimization.
//
// Part of the WASM-004 TOOL phase documentation.

fun main() {
  // Run all examples
  vector_creation_example();
  arithmetic_example();
  bitwise_example();
  comparison_example();
  shuffle_example();
  
  // Performance benchmark
  benchmark_addition();
}

// Example 1: Vector Creation and Lane Access
fun vector_creation_example() {
  println("== Vector Creation and Lane Access ==");
  
  // Create a vector with all lanes set to the same value (splat)
  let v1 = i32x4.splat(42);
  println("i32x4.splat(42) = " + v1.toString());
  
  // Create a vector with specific values for each lane
  let v2 = i32x4(1, 2, 3, 4);
  println("i32x4(1, 2, 3, 4) = " + v2.toString());
  
  // Extract a lane value
  let x = i32x4.extract_lane(v2, 0);
  println("i32x4.extract_lane(v2, 0) = " + x.toString());
  
  // Replace a lane value
  let v3 = i32x4.replace_lane(v2, 0, 99);
  println("i32x4.replace_lane(v2, 0, 99) = " + v3.toString());
  
  println("");
}

// Example 2: Arithmetic Operations
fun arithmetic_example() {
  println("== Arithmetic Operations ==");
  
  let a = f32x4(1.0, 2.0, 3.0, 4.0);
  let b = f32x4(5.0, 6.0, 7.0, 8.0);
  
  println("a = " + a.toString());
  println("b = " + b.toString());
  
  // Addition (element-wise)
  let sum = f32x4.add(a, b);
  println("f32x4.add(a, b) = " + sum.toString());
  
  // Subtraction (element-wise)
  let diff = f32x4.sub(b, a);
  println("f32x4.sub(b, a) = " + diff.toString());
  
  // Multiplication (element-wise)
  let prod = f32x4.mul(a, b);
  println("f32x4.mul(a, b) = " + prod.toString());
  
  // Division (element-wise)
  let quot = f32x4.div(b, a);
  println("f32x4.div(b, a) = " + quot.toString());
  
  // Minimum (element-wise)
  let min_result = f32x4.min(a, b);
  println("f32x4.min(a, b) = " + min_result.toString());
  
  // Maximum (element-wise)
  let max_result = f32x4.max(a, b);
  println("f32x4.max(a, b) = " + max_result.toString());
  
  // Square root (element-wise)
  let sqrt_result = f32x4.sqrt(a);
  println("f32x4.sqrt(a) = " + sqrt_result.toString());
  
  println("");
}

// Example 3: Bitwise Operations
fun bitwise_example() {
  println("== Bitwise Operations ==");
  
  let a = i32x4(0xFF, 0x00, 0xF0, 0x0F);
  let b = i32x4(0x0F, 0xF0, 0xFF, 0x00);
  
  println("a = " + a.toString());
  println("b = " + b.toString());
  
  // Bitwise AND
  let and_result = v128.and(a, b);
  println("v128.and(a, b) = " + and_result.toString());
  
  // Bitwise OR
  let or_result = v128.or(a, b);
  println("v128.or(a, b) = " + or_result.toString());
  
  // Bitwise XOR
  let xor_result = v128.xor(a, b);
  println("v128.xor(a, b) = " + xor_result.toString());
  
  // Bitwise NOT (complement)
  let not_result = v128.not(a);
  println("v128.not(a) = " + not_result.toString());
  
  // Bitwise shift left
  let shl_result = i32x4.shl(a, 2);
  println("i32x4.shl(a, 2) = " + shl_result.toString());
  
  // Bitwise shift right
  let shr_result = i32x4.shr_u(a, 2);
  println("i32x4.shr_u(a, 2) = " + shr_result.toString());
  
  println("");
}

// Example 4: Comparison Operations
fun comparison_example() {
  println("== Comparison Operations ==");
  
  let a = f32x4(1.0, 2.0, 3.0, 4.0);
  let b = f32x4(4.0, 3.0, 2.0, 1.0);
  
  println("a = " + a.toString());
  println("b = " + b.toString());
  
  // Element-wise equality comparison
  // Results in -1 (all bits set) for true, 0 for false
  let eq = f32x4.eq(a, b);
  println("f32x4.eq(a, b) = " + eq.toString());
  
  // Element-wise not-equal comparison
  let ne = f32x4.ne(a, b);
  println("f32x4.ne(a, b) = " + ne.toString());
  
  // Element-wise greater-than comparison
  let gt = f32x4.gt(a, b);
  println("f32x4.gt(a, b) = " + gt.toString());
  
  // Element-wise less-than comparison
  let lt = f32x4.lt(a, b);
  println("f32x4.lt(a, b) = " + lt.toString());
  
  // Element-wise greater-than-or-equal comparison
  let ge = f32x4.ge(a, b);
  println("f32x4.ge(a, b) = " + ge.toString());
  
  // Element-wise less-than-or-equal comparison
  let le = f32x4.le(a, b);
  println("f32x4.le(a, b) = " + le.toString());
  
  println("");
}

// Example 5: Data Movement and Shuffling
fun shuffle_example() {
  println("== Data Movement and Shuffling ==");
  
  let a = i8x16(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16);
  let b = i8x16(17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32);
  
  println("a = " + a.toString());
  println("b = " + b.toString());
  
  // Shuffle bytes from two vectors based on indices
  // Select bytes alternating from a and b
  let indices = i8x16(0, 16, 1, 17, 2, 18, 3, 19, 4, 20, 5, 21, 6, 22, 7, 23);
  let shuffled = i8x16.shuffle(a, b, indices);
  println("i8x16.shuffle(a, b, indices) = " + shuffled.toString());
  
  // Swizzle: Shuffle bytes within a single vector
  let swizzle_indices = i8x16(15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0);
  let swizzled = i8x16.swizzle(a, swizzle_indices);
  println("i8x16.swizzle(a, indices) = " + swizzled.toString() + " (reversed)");
  
  println("");
}

// Performance benchmark: Compare scalar vs SIMD addition
fun benchmark_addition() {
  println("== Performance Benchmark: Scalar vs SIMD Addition ==");
  
  // Create test data - large arrays of floats
  const ARRAY_SIZE = 10000000; // 10 million elements
  let array_a = new Float32Array(ARRAY_SIZE);
  let array_b = new Float32Array(ARRAY_SIZE);
  let result_scalar = new Float32Array(ARRAY_SIZE);
  let result_simd = new Float32Array(ARRAY_SIZE);
  
  // Initialize with test data
  for (let i = 0; i < ARRAY_SIZE; i++) {
    array_a[i] = i * 0.01;
    array_b[i] = i * 0.02;
  }
  
  // Scalar addition
  let start_scalar = performance.now();
  for (let i = 0; i < ARRAY_SIZE; i++) {
    result_scalar[i] = array_a[i] + array_b[i];
  }
  let end_scalar = performance.now();
  let scalar_time = end_scalar - start_scalar;
  
  // SIMD addition
  let start_simd = performance.now();
  for (let i = 0; i < ARRAY_SIZE; i += 4) {
    // Load 4 elements from each array
    let va = v128.load(array_a.buffer, i * 4);
    let vb = v128.load(array_b.buffer, i * 4);
    
    // Add them
    let vresult = f32x4.add(va, vb);
    
    // Store the result
    v128.store(result_simd.buffer, i * 4, vresult);
  }
  let end_simd = performance.now();
  let simd_time = end_simd - start_simd;
  
  // Verify results
  let matches = true;
  for (let i = 0; i < ARRAY_SIZE; i++) {
    if (Math.abs(result_scalar[i] - result_simd[i]) > 0.0001) {
      matches = false;
      println("Mismatch at index " + i + ": " + 
              result_scalar[i] + " vs " + result_simd[i]);
      break;
    }
  }
  
  println("Scalar implementation: " + scalar_time.toFixed(2) + " ms");
  println("SIMD implementation: " + simd_time.toFixed(2) + " ms");
  println("Speedup: " + (scalar_time / simd_time).toFixed(2) + "x");
  println("Results match: " + (matches ? "Yes" : "No"));
}

// Helper function to detect SIMD support
fun simd_supported() {
  try {
    // Try to instantiate a module with SIMD instructions
    const bytes = new Uint8Array([
      0x00, 0x61, 0x73, 0x6d, // wasm magic
      0x01, 0x00, 0x00, 0x00, // wasm version
      // Module with a single SIMD instruction
    ]);
    return WebAssembly.validate(bytes);
  } catch (e) {
    return false;
  }
}

// Main entry point
if (simd_supported()) {
  main();
} else {
  println("WebAssembly SIMD is not supported in your environment.");
}