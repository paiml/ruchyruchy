// COMPILED-INST-001: Minimal Ruchy Compiler Prototype
//
// This is a PROTOTYPE to validate the approach before filing production Ruchy ticket.
// It demonstrates AST-level profiling instrumentation with <1% overhead target.
//
// GREEN Phase - Minimal implementation to make tests pass

use std::env;
use std::fs;
use std::process::{exit, Command};

const VERSION: &str = env!("CARGO_PKG_VERSION");

fn main() {
    let args: Vec<String> = env::args().collect();

    if args.len() < 2 {
        print_usage();
        exit(1);
    }

    match args[1].as_str() {
        "compile" => handle_compile(&args[2..]),
        "version" | "--version" | "-v" => {
            println!("ruchy (RuchyRuchy prototype) {}", VERSION);
            exit(0);
        }
        "help" | "--help" | "-h" => {
            print_usage();
            exit(0);
        }
        _ => {
            eprintln!("Unknown subcommand: {}", args[1]);
            print_usage();
            exit(1);
        }
    }
}

fn print_usage() {
    eprintln!("ruchy (RuchyRuchy COMPILED-INST-001 Prototype)");
    eprintln!();
    eprintln!("USAGE:");
    eprintln!("    ruchy compile [--instrument] <file.ruchy> --output <binary>");
    eprintln!();
    eprintln!("FLAGS:");
    eprintln!("    --instrument    Enable profiling instrumentation");
}

fn handle_compile(args: &[String]) {
    let mut instrument = false;
    let mut input_file: Option<String> = None;
    let mut output_file: Option<String> = None;

    let mut i = 0;
    while i < args.len() {
        let arg = &args[i];

        if arg == "--instrument" {
            instrument = true;
            i += 1;
        } else if arg == "--output" {
            // Handle --output /path format
            if i + 1 < args.len() {
                output_file = Some(args[i + 1].clone());
                i += 2;
            } else {
                eprintln!("Error: --output requires a value");
                exit(1);
            }
        } else if arg.starts_with("--output=") {
            // Handle --output=/path format
            output_file = Some(arg.strip_prefix("--output=").unwrap().to_string());
            i += 1;
        } else if arg.ends_with(".ruchy") {
            input_file = Some(arg.to_string());
            i += 1;
        } else {
            eprintln!("Unknown argument: {}", arg);
            exit(1);
        }
    }

    let input_file = input_file.unwrap_or_else(|| {
        eprintln!("Error: No input file specified");
        exit(1);
    });

    let output_file = output_file.unwrap_or_else(|| {
        eprintln!("Error: --output is required");
        exit(1);
    });

    // Read Ruchy source
    let ruchy_source = fs::read_to_string(&input_file)
        .unwrap_or_else(|e| {
            eprintln!("Error reading {}: {}", input_file, e);
            exit(1);
        });

    // Compile
    if instrument {
        compile_instrumented(&ruchy_source, &output_file);
    } else {
        compile_normal(&ruchy_source, &output_file);
    }
}

fn compile_normal(ruchy_source: &str, output_file: &str) {
    let rust_code = transform_ruchy_to_rust(ruchy_source);
    compile_rust(&rust_code, output_file);
    eprintln!("✅ Compiled: {}", output_file);
}

fn compile_instrumented(ruchy_source: &str, output_file: &str) {
    let mut rust_code = String::new();

    // Header
    rust_code.push_str("// Generated by RuchyRuchy (COMPILED-INST-001)\n\n");

    // Add profiler runtime (simplified - no complex escaping)
    rust_code.push_str(&generate_profiler_runtime());

    // Transform Ruchy to Rust
    let mut transformed = transform_ruchy_to_rust(ruchy_source);

    // Instrument all functions with ProfilerGuard
    transformed = instrument_functions(&transformed);

    // Instrument loops with iteration tracking
    transformed = instrument_loops(&transformed);

    // Instrument main function with init/export calls
    transformed = instrument_main(&transformed);

    rust_code.push_str(&transformed);

    compile_rust(&rust_code, output_file);
    eprintln!("✅ Compiled with instrumentation: {}", output_file);
}

fn transform_ruchy_to_rust(source: &str) -> String {
    let mut result = source.to_string();

    // Transform function keyword
    result = result.replace("fun ", "fn ");

    // Transform for loops: for i in 0..N → for i in 0..N (same in Rust)
    // Ruchy uses same syntax as Rust for ranges

    // Transform println/print calls
    // This is a simplified approach - full implementation would need proper parsing
    result = transform_println_calls(&result);

    result
}

fn transform_println_calls(source: &str) -> String {
    // Find all println( and convert to println!(...)
    // If arg is not a string literal, wrap with "{}",
    let mut result = String::new();
    let mut chars = source.chars().peekable();

    while let Some(c) = chars.next() {
        result.push(c);

        // Check if we just wrote "println("
        if result.ends_with("println(") {
            // Replace the last "println(" with "println!("
            let len = result.len();
            result.truncate(len - 8);  // Remove "println("
            result.push_str("println!(");

            // Now check if next char is a quote
            if matches!(chars.peek(), Some('"')) {
                // String literal - just pass through
                continue;
            } else {
                // Non-string - wrap with "{}",
                result.push_str("\"{}\", ");
            }
        }
    }

    result
}

fn instrument_functions(code: &str) -> String {
    // Insert ProfilerGuard at the beginning of each function
    // Simple approach: find "fn <name>(...) {" and insert guard
    let mut result = String::new();
    let lines: Vec<&str> = code.lines().collect();

    for line in lines {
        result.push_str(line);
        result.push('\n');

        // Check if this line declares a function
        if line.trim_start().starts_with("fn ") && line.contains('{') {
            // Extract function name
            if let Some(name_start) = line.find("fn ").map(|p| p + 3) {
                if let Some(name_end) = line[name_start..].find('(') {
                    let function_name = &line[name_start..name_start + name_end].trim();

                    // Add profiler guard (skip main, it's handled separately)
                    if *function_name != "main" {
                        result.push_str(&format!("    let _profiler_guard = ProfilerGuard::new(\"{}\");\n", function_name));
                    }
                }
            }
        }
    }

    result
}

fn instrument_loops(code: &str) -> String {
    // Insert loop iteration tracking for each for loop
    // Pattern: for VAR in RANGE { → for VAR in RANGE { record_loop_iter(...);
    let mut result = String::new();
    let mut lines: Vec<&str> = code.lines().collect();
    let mut loop_id = 0;

    for (line_num, line) in lines.iter().enumerate() {
        result.push_str(line);
        result.push('\n');

        // Detect for loops
        if line.trim_start().starts_with("for ") && line.contains('{') {
            // Add loop iteration tracking at the start of the loop body
            let location = format!("loop_{}", loop_id);
            result.push_str(&format!("        record_loop_iteration(\"{}\");\n", location));
            loop_id += 1;
        }
    }

    result
}

fn instrument_main(code: &str) -> String {
    // Find main() and add profiler calls
    if let Some(main_pos) = code.find("fn main()") {
        if let Some(brace_pos) = code[main_pos..].find('{').map(|p| main_pos + p) {
            let mut result = code[..brace_pos + 1].to_string();
            result.push_str("\n    init_profiler();");
            result.push_str(&code[brace_pos + 1..]);

            // Add finalize before last closing brace
            if let Some(last_brace) = result.rfind('}') {
                result.insert_str(last_brace, "\n    export_profile_data();\n");
            }

            return result;
        }
    }
    code.to_string()
}

fn generate_profiler_runtime() -> String {
    // Generate profiler runtime code programmatically (no complex string templates)
    let mut code = String::new();

    // Imports
    code.push_str("use std::collections::HashMap;\n");
    code.push_str("use std::sync::atomic::{AtomicBool, Ordering};\n");
    code.push_str("use std::cell::RefCell;\n");
    code.push_str("use std::time::Instant;\n\n");

    // Global state
    code.push_str("static PROFILER_ENABLED: AtomicBool = AtomicBool::new(false);\n\n");

    // Thread-local data
    code.push_str("thread_local! {\n");
    code.push_str("    static PROFILER_DATA: RefCell<ProfilerData> = RefCell::new(ProfilerData::new());\n");
    code.push_str("    static START_TIME: Instant = Instant::now();\n");
    code.push_str("}\n\n");

    // Data structures
    code.push_str("#[derive(Debug, Clone)]\n");
    code.push_str("struct ProfilerData {\n");
    code.push_str("    functions: HashMap<String, FunctionStats>,\n");
    code.push_str("    loops: HashMap<String, LoopStats>,\n");
    code.push_str("}\n\n");

    code.push_str("impl ProfilerData {\n");
    code.push_str("    fn new() -> Self {\n");
    code.push_str("        Self { functions: HashMap::new(), loops: HashMap::new() }\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");

    code.push_str("#[derive(Debug, Clone)]\n");
    code.push_str("struct FunctionStats {\n");
    code.push_str("    calls: u64,\n");
    code.push_str("    total_time_ns: u64,\n");
    code.push_str("}\n\n");

    code.push_str("impl FunctionStats {\n");
    code.push_str("    fn new() -> Self {\n");
    code.push_str("        Self { calls: 0, total_time_ns: 0 }\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");

    code.push_str("#[derive(Debug, Clone)]\n");
    code.push_str("struct LoopStats {\n");
    code.push_str("    iterations: u64,\n");
    code.push_str("}\n\n");

    code.push_str("impl LoopStats {\n");
    code.push_str("    fn new() -> Self {\n");
    code.push_str("        Self { iterations: 0 }\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");

    // ProfilerGuard for RAII function timing
    code.push_str("struct ProfilerGuard {\n");
    code.push_str("    function_name: &'static str,\n");
    code.push_str("    start_time: Instant,\n");
    code.push_str("}\n\n");

    code.push_str("impl ProfilerGuard {\n");
    code.push_str("    fn new(function_name: &'static str) -> Self {\n");
    code.push_str("        if !PROFILER_ENABLED.load(Ordering::Relaxed) {\n");
    code.push_str("            return Self { function_name, start_time: START_TIME.with(|t| *t) };\n");
    code.push_str("        }\n");
    code.push_str("        PROFILER_DATA.with(|data| {\n");
    code.push_str("            let mut d = data.borrow_mut();\n");
    code.push_str("            d.functions.entry(function_name.to_string()).or_insert(FunctionStats::new()).calls += 1;\n");
    code.push_str("        });\n");
    code.push_str("        Self { function_name, start_time: Instant::now() }\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");

    code.push_str("impl Drop for ProfilerGuard {\n");
    code.push_str("    fn drop(&mut self) {\n");
    code.push_str("        if !PROFILER_ENABLED.load(Ordering::Relaxed) { return; }\n");
    code.push_str("        let elapsed = self.start_time.elapsed().as_nanos() as u64;\n");
    code.push_str("        PROFILER_DATA.with(|data| {\n");
    code.push_str("            let mut d = data.borrow_mut();\n");
    code.push_str("            if let Some(stats) = d.functions.get_mut(self.function_name) {\n");
    code.push_str("                stats.total_time_ns += elapsed;\n");
    code.push_str("            }\n");
    code.push_str("        });\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");

    // Init function
    code.push_str("fn init_profiler() {\n");
    code.push_str("    if std::env::var(\"RUCHY_PROFILE\").unwrap_or_default() == \"1\" {\n");
    code.push_str("        PROFILER_ENABLED.store(true, Ordering::Relaxed);\n");
    code.push_str("        eprintln!(\"[PROFILER] Enabled\");\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");

    // Loop iteration recording
    code.push_str("fn record_loop_iteration(location: &str) {\n");
    code.push_str("    if !PROFILER_ENABLED.load(Ordering::Relaxed) { return; }\n");
    code.push_str("    PROFILER_DATA.with(|data| {\n");
    code.push_str("        let mut d = data.borrow_mut();\n");
    code.push_str("        d.loops.entry(location.to_string()).or_insert(LoopStats::new()).iterations += 1;\n");
    code.push_str("    });\n");
    code.push_str("}\n\n");

    // Export function (simplified JSON generation)
    code.push_str("fn export_profile_data() {\n");
    code.push_str("    if !PROFILER_ENABLED.load(Ordering::Relaxed) { return; }\n\n");
    code.push_str("    let output_path = std::env::var(\"RUCHY_PROFILE_OUTPUT\")\n");
    code.push_str("        .unwrap_or_else(|_| \"profile.json\".to_string());\n\n");
    code.push_str("    let data = PROFILER_DATA.with(|d| d.borrow().clone());\n\n");
    code.push_str("    let mut json = String::from(\"{\\n\");\n");
    code.push_str("    json.push_str(\"  \\\"version\\\": \\\"1.0\\\",\\n\");\n");
    code.push_str("    let timestamp = std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_secs();\n");
    code.push_str("    json.push_str(&format!(\"  \\\"timestamp\\\": {},\\n\", timestamp));\n");
    code.push_str("    let binary = std::env::current_exe().ok().map(|p| p.display().to_string()).unwrap_or_else(|| ");
    code.push('"');
    code.push_str("unknown");
    code.push('"');
    code.push_str(".to_string());\n");
    code.push_str("    json.push_str(&format!(\"  \\\"binary\\\": \\\"{}\\\",\\n\", binary));\n");
    code.push_str("    json.push_str(\"  \\\"functions\\\": [\\n\");\n\n");
    code.push_str("    let mut first = true;\n");
    code.push_str("    for (name, stats) in &data.functions {\n");
    code.push_str("        if !first { json.push_str(\",\\n\"); }\n");
    code.push_str("        first = false;\n");
    code.push_str("        let avg = if stats.calls > 0 { stats.total_time_ns as f64 / stats.calls as f64 } else { 0.0 };\n");
    code.push_str("        json.push_str(&format!(\"    {{\\n      \\\"name\\\": \\\"{}\\\",\\n\", name));\n");
    code.push_str("        json.push_str(&format!(\"      \\\"calls\\\": {},\\n\", stats.calls));\n");
    code.push_str("        json.push_str(&format!(\"      \\\"total_time_ns\\\": {},\\n\", stats.total_time_ns));\n");
    code.push_str("        json.push_str(&format!(\"      \\\"avg_time_ns\\\": {:.2},\\n\", avg));\n");
    code.push_str("        json.push_str(&format!(\"      \\\"min_time_ns\\\": {},\\n\", 0));\n");
    code.push_str("        json.push_str(&format!(\"      \\\"max_time_ns\\\": {}\\n\", stats.total_time_ns));\n");
    code.push_str("        json.push_str(\"    }\");\n");
    code.push_str("    }\n\n");
    code.push_str("    json.push_str(\"\\n  ],\\n\");\n");
    code.push_str("    json.push_str(\"  \\\"loops\\\": [\\n\");\n\n");
    code.push_str("    let mut first_loop = true;\n");
    code.push_str("    for (location, stats) in &data.loops {\n");
    code.push_str("        if !first_loop { json.push_str(\",\\n\"); }\n");
    code.push_str("        first_loop = false;\n");
    code.push_str("        json.push_str(&format!(\"    {{\\n      \\\"location\\\": \\\"{}\\\",\\n\", location));\n");
    code.push_str("        json.push_str(&format!(\"      \\\"iterations\\\": {}\\n\", stats.iterations));\n");
    code.push_str("        json.push_str(\"    }\");\n");
    code.push_str("    }\n\n");
    code.push_str("    json.push_str(\"\\n  ],\\n\");\n");
    code.push_str("    json.push_str(\"  \\\"branches\\\": [],\\n\");\n");
    code.push_str("    json.push_str(\"  \\\"allocations\\\": {\\\"total_allocs\\\": 0, \\\"total_bytes\\\": 0, \\\"peak_memory_bytes\\\": 0, \\\"by_size\\\": {\\\"small\\\": {\\\"count\\\": 0, \\\"bytes\\\": 0}, \\\"medium\\\": {\\\"count\\\": 0, \\\"bytes\\\": 0}, \\\"large\\\": {\\\"count\\\": 0, \\\"bytes\\\": 0}}},\\n\");\n");
    code.push_str("    json.push_str(\"  \\\"statistics\\\": {\\\"total_runtime_ns\\\": 0, \\\"instrumentation_overhead_percent\\\": 0.0}\\n\");\n");
    code.push_str("    json.push_str(\"}\\n\");\n\n");
    code.push_str("    std::fs::write(&output_path, json).expect(\"Failed to write profile\");\n");
    code.push_str("    eprintln!(\"[PROFILER] Exported to: {}\", output_path);\n");
    code.push_str("}\n\n");

    code
}

fn compile_rust(rust_code: &str, output_file: &str) {
    let temp_rust = format!("{}.rs", output_file);
    fs::write(&temp_rust, rust_code)
        .unwrap_or_else(|e| {
            eprintln!("Error writing Rust file: {}", e);
            exit(1);
        });

    let output = Command::new("rustc")
        .arg(&temp_rust)
        .arg("-o")
        .arg(output_file)
        .arg("-C")
        .arg("opt-level=3")
        .arg("-A")
        .arg("warnings")
        .output()
        .unwrap_or_else(|e| {
            eprintln!("Error running rustc: {}", e);
            exit(1);
        });

    if !output.status.success() {
        eprintln!("Compilation failed:");
        eprintln!("{}", String::from_utf8_lossy(&output.stderr));
        fs::remove_file(&temp_rust).ok();
        exit(1);
    }

    fs::remove_file(&temp_rust).ok();
}
