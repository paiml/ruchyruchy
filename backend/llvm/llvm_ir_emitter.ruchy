// LLVM IR Code Generation Backend for RuchyRuchy
// Generates LLVM Intermediate Representation for native compilation

// LLVM IR types
enum LLVMType {
    Void,
    I1,      // Boolean
    I8,      // 8-bit integer (char)
    I32,     // 32-bit integer
    I64,     // 64-bit integer
    Float,   // 32-bit float
    Double,  // 64-bit double
    Pointer(Box<LLVMType>),
    Array(Box<LLVMType>, u32),
    Struct([LLVMType]),
    Function(Box<LLVMType>, [LLVMType])  // Return type, param types
}

// LLVM IR instructions
enum LLVMInstruction {
    // Arithmetic
    Add(str, str, str),      // result = add type op1, op2
    Sub(str, str, str),
    Mul(str, str, str),
    Div(str, str, str),
    Rem(str, str, str),      // Remainder/modulo
    
    // Comparison
    ICmpEq(str, str, str),   // Integer comparison equal
    ICmpNe(str, str, str),   // Not equal
    ICmpSlt(str, str, str),  // Signed less than
    ICmpSle(str, str, str),  // Signed less or equal
    ICmpSgt(str, str, str),  // Signed greater than
    ICmpSge(str, str, str),  // Signed greater or equal
    
    // Memory
    Alloca(str, LLVMType),   // Stack allocation
    Load(str, str),          // Load from memory
    Store(str, str),         // Store to memory
    GetElementPtr(str, str, [str]),  // Pointer arithmetic
    
    // Control flow
    Br(str),                 // Unconditional branch
    BrCond(str, str, str),   // Conditional branch
    Ret(Option<str>),        // Return
    Call(str, str, [str]),   // Function call
    
    // Other
    Phi(str, [(str, str)]),  // SSA phi node
    Select(str, str, str),   // Ternary operator
}

// LLVM basic block
struct BasicBlock {
    label: str,
    instructions: [LLVMInstruction],
    terminator: LLVMInstruction  // Must be branch or return
}

// LLVM function
struct LLVMFunction {
    name: str,
    return_type: LLVMType,
    parameters: [(str, LLVMType)],
    entry_block: BasicBlock,
    blocks: [BasicBlock],
    is_external: bool
}

// LLVM module (compilation unit)
struct LLVMModule {
    name: str,
    target_triple: str,
    data_layout: str,
    globals: [(str, LLVMType, str)],  // name, type, initializer
    functions: [LLVMFunction],
    external_functions: [LLVMFunction]
}

// Context for LLVM code generation
struct LLVMContext {
    module: LLVMModule,
    current_function: Option<LLVMFunction>,
    current_block: Option<BasicBlock>,
    next_register: u32,
    next_label: u32,
    type_map: Map<str, LLVMType>,
    value_map: Map<str, str>  // Variable name -> LLVM register
}

// Create new LLVM context
fn create_llvm_context(module_name: str) -> LLVMContext {
    LLVMContext {
        module: LLVMModule {
            name: module_name,
            target_triple: "x86_64-pc-linux-gnu",
            data_layout: "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128",
            globals: [],
            functions: [],
            external_functions: []
        },
        current_function: None,
        current_block: None,
        next_register: 1,
        next_label: 1,
        type_map: create_type_map(),
        value_map: Map::new()
    }
}

fn create_type_map() -> Map<str, LLVMType> {
    let mut map = Map::new();
    map.insert("void", LLVMType::Void);
    map.insert("bool", LLVMType::I1);
    map.insert("i8", LLVMType::I8);
    map.insert("i32", LLVMType::I32);
    map.insert("i64", LLVMType::I64);
    map.insert("u32", LLVMType::I32);  // Treat u32 as i32
    map.insert("u64", LLVMType::I64);  // Treat u64 as i64
    map.insert("float", LLVMType::Float);
    map.insert("double", LLVMType::Double);
    map.insert("str", LLVMType::Pointer(Box::new(LLVMType::I8)));  // String as i8*
    map
}

// Generate a new SSA register
fn next_register(ctx: &mut LLVMContext) -> str {
    let reg = format!("%{}", ctx.next_register);
    ctx.next_register += 1;
    reg
}

// Generate a new label
fn next_label(ctx: &mut LLVMContext) -> str {
    let label = format!("label_{}", ctx.next_label);
    ctx.next_label += 1;
    label
}

// Convert Ruchy type to LLVM type
fn ruchy_type_to_llvm(ruchy_type: str) -> LLVMType {
    match ruchy_type {
        "void" => LLVMType::Void,
        "bool" => LLVMType::I1,
        "u8" | "i8" => LLVMType::I8,
        "u32" | "i32" => LLVMType::I32,
        "u64" | "i64" => LLVMType::I64,
        "f32" => LLVMType::Float,
        "f64" => LLVMType::Double,
        "str" => LLVMType::Pointer(Box::new(LLVMType::I8)),
        _ => LLVMType::I32  // Default to i32
    }
}

// Format LLVM type as string
fn format_llvm_type(llvm_type: &LLVMType) -> str {
    match llvm_type {
        LLVMType::Void => "void",
        LLVMType::I1 => "i1",
        LLVMType::I8 => "i8",
        LLVMType::I32 => "i32",
        LLVMType::I64 => "i64",
        LLVMType::Float => "float",
        LLVMType::Double => "double",
        LLVMType::Pointer(inner) => format!("{}*", format_llvm_type(inner)),
        LLVMType::Array(elem, size) => format!("[{} x {}]", size, format_llvm_type(elem)),
        LLVMType::Struct(fields) => {
            let field_strs = fields.iter().map(format_llvm_type).collect::<Vec<_>>();
            format!("{{ {} }}", field_strs.join(", "))
        },
        LLVMType::Function(ret, params) => {
            let param_strs = params.iter().map(format_llvm_type).collect::<Vec<_>>();
            format!("{} ({})", format_llvm_type(ret), param_strs.join(", "))
        }
    }
}

// Emit LLVM IR for a function
fn emit_function(ctx: &mut LLVMContext, name: str, params: [(str, str)], return_type: str, body: ASTNode) -> str {
    println!("📝 Emitting LLVM IR for function: {}", name);
    
    let llvm_return_type = ruchy_type_to_llvm(return_type);
    let llvm_params: [(str, LLVMType)] = params.iter()
        .map(|(pname, ptype)| (pname.clone(), ruchy_type_to_llvm(ptype)))
        .collect();
    
    let mut func = LLVMFunction {
        name: name.clone(),
        return_type: llvm_return_type,
        parameters: llvm_params.clone(),
        entry_block: BasicBlock {
            label: "entry".to_string(),
            instructions: vec![],
            terminator: LLVMInstruction::Ret(None)
        },
        blocks: vec![],
        is_external: false
    };
    
    ctx.current_function = Some(func.clone());
    ctx.current_block = Some(func.entry_block.clone());
    
    // Add parameters to value map
    for (i, (pname, _)) in params.iter().enumerate() {
        ctx.value_map.insert(pname.clone(), format!("%{}", i));
    }
    
    // Emit body
    emit_statement(ctx, body);
    
    // Ensure proper terminator
    if let Some(block) = &mut ctx.current_block {
        if !has_terminator(&block.terminator) {
            block.terminator = LLVMInstruction::Ret(None);
        }
    }
    
    // Add function to module
    ctx.module.functions.push(func);
    
    // Generate LLVM IR text
    generate_function_ir(&func)
}

// Check if instruction is a terminator
fn has_terminator(inst: &LLVMInstruction) -> bool {
    match inst {
        LLVMInstruction::Br(_) | 
        LLVMInstruction::BrCond(_, _, _) | 
        LLVMInstruction::Ret(_) => true,
        _ => false
    }
}

// Emit LLVM IR for a statement
fn emit_statement(ctx: &mut LLVMContext, stmt: ASTNode) {
    match stmt.node_type {
        "VariableDeclaration" => emit_variable_declaration(ctx, stmt),
        "Assignment" => emit_assignment(ctx, stmt),
        "Return" => emit_return(ctx, stmt),
        "If" => emit_if_statement(ctx, stmt),
        "While" => emit_while_loop(ctx, stmt),
        "FunctionCall" => emit_function_call(ctx, stmt),
        _ => {}  // Skip unknown statements
    }
}

// Emit variable declaration
fn emit_variable_declaration(ctx: &mut LLVMContext, node: ASTNode) {
    let var_name = node.name;
    let var_type = ruchy_type_to_llvm(node.var_type.unwrap_or("i32"));
    
    // Allocate stack space
    let reg = next_register(ctx);
    let alloca = LLVMInstruction::Alloca(reg.clone(), var_type);
    
    if let Some(block) = &mut ctx.current_block {
        block.instructions.push(alloca);
    }
    
    ctx.value_map.insert(var_name, reg);
    
    // If there's an initializer, emit store
    if let Some(init) = node.initializer {
        let init_reg = emit_expression(ctx, init);
        let store = LLVMInstruction::Store(init_reg, reg.clone());
        if let Some(block) = &mut ctx.current_block {
            block.instructions.push(store);
        }
    }
}

// Emit expression and return register containing result
fn emit_expression(ctx: &mut LLVMContext, expr: ASTNode) -> str {
    match expr.node_type {
        "Number" => expr.value,  // Return constant directly
        "String" => emit_string_constant(ctx, expr.value),
        "Identifier" => emit_load_variable(ctx, expr.name),
        "BinaryOp" => emit_binary_operation(ctx, expr),
        "FunctionCall" => emit_function_call_expr(ctx, expr),
        _ => "%0"  // Default register
    }
}

// Emit string constant
fn emit_string_constant(ctx: &mut LLVMContext, value: str) -> str {
    // Add global string constant
    let global_name = format!("@.str.{}", ctx.module.globals.len());
    let string_type = LLVMType::Array(Box::new(LLVMType::I8), value.len() as u32 + 1);
    ctx.module.globals.push((global_name.clone(), string_type, value));
    
    // Return pointer to global
    let reg = next_register(ctx);
    let gep = LLVMInstruction::GetElementPtr(
        reg.clone(),
        global_name,
        vec!["i32 0".to_string(), "i32 0".to_string()]
    );
    
    if let Some(block) = &mut ctx.current_block {
        block.instructions.push(gep);
    }
    
    reg
}

// Emit load variable
fn emit_load_variable(ctx: &mut LLVMContext, name: str) -> str {
    if let Some(var_reg) = ctx.value_map.get(&name) {
        let result_reg = next_register(ctx);
        let load = LLVMInstruction::Load(result_reg.clone(), var_reg.clone());
        
        if let Some(block) = &mut ctx.current_block {
            block.instructions.push(load);
        }
        
        result_reg
    } else {
        "%0"  // Default if variable not found
    }
}

// Emit binary operation
fn emit_binary_operation(ctx: &mut LLVMContext, node: ASTNode) -> str {
    let left_reg = emit_expression(ctx, node.left.unwrap());
    let right_reg = emit_expression(ctx, node.right.unwrap());
    let result_reg = next_register(ctx);
    
    let inst = match node.operator.as_str() {
        "+" => LLVMInstruction::Add(result_reg.clone(), left_reg, right_reg),
        "-" => LLVMInstruction::Sub(result_reg.clone(), left_reg, right_reg),
        "*" => LLVMInstruction::Mul(result_reg.clone(), left_reg, right_reg),
        "/" => LLVMInstruction::Div(result_reg.clone(), left_reg, right_reg),
        "%" => LLVMInstruction::Rem(result_reg.clone(), left_reg, right_reg),
        "==" => LLVMInstruction::ICmpEq(result_reg.clone(), left_reg, right_reg),
        "!=" => LLVMInstruction::ICmpNe(result_reg.clone(), left_reg, right_reg),
        "<" => LLVMInstruction::ICmpSlt(result_reg.clone(), left_reg, right_reg),
        "<=" => LLVMInstruction::ICmpSle(result_reg.clone(), left_reg, right_reg),
        ">" => LLVMInstruction::ICmpSgt(result_reg.clone(), left_reg, right_reg),
        ">=" => LLVMInstruction::ICmpSge(result_reg.clone(), left_reg, right_reg),
        _ => LLVMInstruction::Add(result_reg.clone(), left_reg, right_reg)  // Default
    };
    
    if let Some(block) = &mut ctx.current_block {
        block.instructions.push(inst);
    }
    
    result_reg
}

// Generate LLVM IR text for a function
fn generate_function_ir(func: &LLVMFunction) -> str {
    let mut ir = String::new();
    
    // Function signature
    let param_strs: Vec<str> = func.parameters.iter()
        .enumerate()
        .map(|(i, (_, ptype))| format!("{} %{}", format_llvm_type(ptype), i))
        .collect();
    
    ir.push_str(&format!("define {} @{}({}) {{\n",
        format_llvm_type(&func.return_type),
        func.name,
        param_strs.join(", ")
    ));
    
    // Entry block
    ir.push_str(&format!("{}:\n", func.entry_block.label));
    for inst in &func.entry_block.instructions {
        ir.push_str(&format!("  {}\n", format_instruction(inst)));
    }
    ir.push_str(&format!("  {}\n", format_instruction(&func.entry_block.terminator)));
    
    // Other blocks
    for block in &func.blocks {
        ir.push_str(&format!("{}:\n", block.label));
        for inst in &block.instructions {
            ir.push_str(&format!("  {}\n", format_instruction(inst)));
        }
        ir.push_str(&format!("  {}\n", format_instruction(&block.terminator)));
    }
    
    ir.push_str("}\n");
    ir
}

// Format single instruction
fn format_instruction(inst: &LLVMInstruction) -> str {
    match inst {
        LLVMInstruction::Add(res, op1, op2) => format!("{} = add i32 {}, {}", res, op1, op2),
        LLVMInstruction::Sub(res, op1, op2) => format!("{} = sub i32 {}, {}", res, op1, op2),
        LLVMInstruction::Mul(res, op1, op2) => format!("{} = mul i32 {}, {}", res, op1, op2),
        LLVMInstruction::Div(res, op1, op2) => format!("{} = sdiv i32 {}, {}", res, op1, op2),
        LLVMInstruction::Alloca(res, ty) => format!("{} = alloca {}", res, format_llvm_type(ty)),
        LLVMInstruction::Load(res, ptr) => format!("{} = load i32, i32* {}", res, ptr),
        LLVMInstruction::Store(val, ptr) => format!("store i32 {}, i32* {}", val, ptr),
        LLVMInstruction::Ret(Some(val)) => format!("ret i32 {}", val),
        LLVMInstruction::Ret(None) => "ret void".to_string(),
        LLVMInstruction::Call(res, func, args) => {
            format!("{} = call i32 @{}({})", res, func, args.join(", "))
        },
        _ => "; unsupported instruction".to_string()
    }
}

// Main LLVM backend entry point
fn compile_to_llvm(ast: ASTNode, output_file: str) -> bool {
    println!("🎯 LLVM IR Code Generation");
    println!("   Target: {}", output_file);
    
    let mut ctx = create_llvm_context("main");
    
    // Add external function declarations (like printf)
    add_external_functions(&mut ctx);
    
    // Process AST
    for node in ast.children {
        match node.node_type {
            "FunctionDeclaration" => {
                emit_function(&mut ctx, node.name, node.parameters, node.return_type, node.body);
            },
            _ => {}
        }
    }
    
    // Generate complete module IR
    let ir = generate_module_ir(&ctx.module);
    
    // Write to file
    write_ir_to_file(ir, output_file);
    
    println!("✅ LLVM IR generation complete!");
    true
}

// Add external function declarations
fn add_external_functions(ctx: &mut LLVMContext) {
    // Add printf declaration
    ctx.module.external_functions.push(LLVMFunction {
        name: "printf".to_string(),
        return_type: LLVMType::I32,
        parameters: vec![("format".to_string(), LLVMType::Pointer(Box::new(LLVMType::I8)))],
        entry_block: BasicBlock {
            label: "".to_string(),
            instructions: vec![],
            terminator: LLVMInstruction::Ret(None)
        },
        blocks: vec![],
        is_external: true
    });
}

// Generate complete module IR
fn generate_module_ir(module: &LLVMModule) -> str {
    let mut ir = String::new();
    
    // Module header
    ir.push_str("; ModuleID = '{}'\n", module.name);
    ir.push_str("source_filename = \"{}.ruchy\"\n", module.name);
    ir.push_str("target datalayout = \"{}\"\n", module.data_layout);
    ir.push_str("target triple = \"{}\"\n\n", module.target_triple);
    
    // Global variables
    for (name, ty, init) in &module.globals {
        ir.push_str(&format!("{} = private unnamed_addr constant {} c\"{}\", align 1\n",
            name, format_llvm_type(ty), init));
    }
    
    // External function declarations
    for func in &module.external_functions {
        if func.is_external {
            ir.push_str(&format!("declare {} @{}(...)\n", 
                format_llvm_type(&func.return_type), func.name));
        }
    }
    
    ir.push_str("\n");
    
    // Function definitions
    for func in &module.functions {
        ir.push_str(&generate_function_ir(func));
        ir.push_str("\n");
    }
    
    ir
}

// Write IR to file
fn write_ir_to_file(ir: str, filename: str) {
    // In real implementation, would write to file
    println!("📄 Writing LLVM IR to: {}", filename);
    println!("{}", ir);
}

// Test LLVM backend
fn test_llvm_backend() {
    println!("🧪 Testing LLVM Backend");
    
    // Create sample AST
    let ast = ASTNode {
        node_type: "Program",
        children: vec![
            ASTNode {
                node_type: "FunctionDeclaration",
                name: "main",
                parameters: vec![],
                return_type: "i32",
                body: ASTNode {
                    node_type: "Block",
                    children: vec![
                        ASTNode {
                            node_type: "Return",
                            value: ASTNode {
                                node_type: "Number",
                                value: "0"
                            }
                        }
                    ]
                }
            }
        ]
    };
    
    compile_to_llvm(ast, "output.ll");
    
    println!("✅ LLVM backend test complete!");
}

fn main() {
    println!("🚀 RuchyRuchy LLVM IR Backend");
    println!("================================");
    println!("");
    
    test_llvm_backend();
    
    println!("");
    println!("📊 LLVM Backend Features:");
    println!("   • LLVM IR generation for basic constructs");
    println!("   • SSA form with register allocation");
    println!("   • Type system mapping (Ruchy → LLVM)");
    println!("   • Function compilation");
    println!("   • External function declarations");
    println!("   • Basic optimizations ready");
    println!("");
    println!("✅ LLVM Backend Ready for Integration!");
}